/**
 * Packages
 *
 * '$' is an object generated by the devDependencies in package.json. If needed,
 * console.log($) can be used to check $'s so long as 'lazy: false' is set.
 */
const gulp = require('gulp');
const gulpEslint = require('gulp-eslint');
const gulpStyleLint = require('gulp-stylelint');
const gulpSass = require('gulp-sass');
const gulpInlineBase64 = require('gulp-inline-base64');
const gulpAutoprefixer = require('gulp-autoprefixer');
const gulpConcat = require('gulp-concat');
const gulpCleanCSS = require('gulp-clean-css');

const gulpSourcemaps = require('gulp-sourcemaps');

const browserSync = require('browser-sync');
const webpack = require('webpack');
const webpackStream = require('webpack-stream');

const webpackConfig = require('./webpack.dev.js');


/**
 * ASSET PATHS
 *
 * Object that contains paths for all asset types. Useful for changing build
 * environments.
 */
const APP_DOMAIN_DEV = 'frontpage.localhost.leagueoflegends.com:8888';
const NAMESPACE = 'preseason-update';
const PATH = {
    scss:   './lib/scss',
    es6:    './lib/js',
    css:    './dist/css',
    js:     './dist/js',
    vendor: './dist/vendor',
};


/**
 * Browsersync (http://www.browsersync.io/docs/api/)
 */
gulp.task('browser-sync', () => {
    browserSync({
        ghostMode: false,
        proxy: `${APP_DOMAIN_DEV}/en_US/featured/${NAMESPACE}`,
        notify: false,
        ui: {
            weinre: {
                port: 9090,
            },
        },
    });
});


/**
 * SCSS Linting
 */
function scssLint() {
    return gulp.src(`${PATH.scss}/**/*.scss`)
        .pipe(gulpStyleLint({
            failAfterError: false, // Keep going (defaults to true)
            reporters: [{
                formatter: 'string',
                console: true,
            }],
        }));
}

gulp.task('scss-lint', scssLint);

/**
 * Compile SCSS, auto-prefix, and minify in one step, for clean sourcemaps.
 */
function sass() {
    return gulp.src(`${PATH.scss}/**/*.scss`)
        // Init sourcemaps
        .pipe(gulpSourcemaps.init())
        // Sass pre-processing
        .pipe(gulpSass().on('error', function (err) {
            console.log(err.message);
            this.emit('end'); // Prevent gulp from catching the error and exiting watch process.
        }))

        // Inline images as base64 into the css
        .pipe(gulpInlineBase64({
            baseDir: PATH.scss,
            // 12kb max size
            maxSize: 1024 * 12,
            // Debug output in the console
            debug: false,
        }))

        // Autoprefixer process
        .pipe(gulpAutoprefixer())

        // End sourcemaps, write to CSS path and update br
        .pipe(gulpSourcemaps.write('.'))
        .pipe(gulp.dest(PATH.css))
        .pipe(browserSync.stream({
            match: '**/*.css',
        }));
}

gulp.task('sass', sass);


/**
 * Build production.min.css
 */
function css() {
    return gulp
        .src([
            `${PATH.vendor}/normalize/normalize.css`,
            `${PATH.css}/global.css`,
        ])
        .pipe(gulpConcat('production.min.css'))
        .pipe(gulpCleanCSS({
            compatibility: 'ie8',
            mediaMerging: false,
            advanced: false,
        }))
        .pipe(gulp.dest(PATH.css));
}

gulp.task('css', css);


/**
 * Styles series and parallel functions
 */
const styles = gulp.parallel('scss-lint', gulp.series('sass', 'css'));


/**
 * Lint the main js file. Don't routinely ESLINT the file as part of the main task,
 * because it's slow. Expect that devs are live-linting locally as they work.
 */

gulp.task('eslint', () =>
    // ESLint ignores files with "node_modules" paths.
    // So, it's best to have gulp ignore the directory as well.
    // Also, Be sure to return the stream from the task;
    // Otherwise, the task may end before the stream has finished.
    gulp.src([`${PATH.es6}/**/*.js`])
        // eslint() attaches the lint output to the "eslint" property
        // of the file object so it can be used by other modules.
        .pipe(gulpEslint())
        // eslint.format() outputs the lint results to the console.
        // Alternatively use eslint.formatEach() (see Docs).
        .pipe(gulpEslint.format())
        // To have the process exit with an error code (1) on
        // lint error, return the stream and pipe to failAfterError last.
        .pipe(gulpEslint.failAfterError())
);


// Bundler function
function bundle() {
    return gulp
        .src(`${PATH.es6}/main.js`)
        .pipe(webpackStream(webpackConfig, webpack))
        .pipe(gulp.dest(PATH.js))
        .pipe(browserSync.reload({
            stream: true,
        }));
}

gulp.task('bundle', bundle);


const scripts = gulp.series('bundle');


/**
 * Build task to process styles and scripts concurrently.
 */
const build = gulp.parallel(styles, scripts);

gulp.task('build', build);


/**
 * Watch for changes
 */
function watch() {
    gulp.watch(`${PATH.scss}/**/*.scss`, styles);
    gulp.watch([
        `${PATH.es6}/**/*.js`,
        `${PATH.es6}/**/*.jsx`,
    ],
    scripts);

    // bundler.on('update', scripts);

    gulp.watch('*.html', () =>
        gulp.src('*.html')
            .pipe(browserSync.reload({
                stream: true,
            }))
    );

    // Stop old gulp watch when gulpfile is modified.
    // https://gist.github.com/pornel/ca9631f5348383b61bc7b359e96ced38
    gulp.watch('gulpfile.js', () => {
        process.exit(0);
    });
}

gulp.task('watch', gulp.parallel('browser-sync', gulp.series('build', watch)));


/**
 * Build process + watch for dev
 */
gulp.task('dev:build', watch);


/**
 * Default
 */
gulp.task('default', build);

/******/
(function(modules) { // webpackBootstrap
    /******/ // The module cache
    /******/
    var installedModules = {};
    /******/
    /******/ // The require function
    /******/
    function __webpack_require__(moduleId) {
        /******/
        /******/ // Check if module is in cache
        /******/
        if (installedModules[moduleId]) {
            /******/
            return installedModules[moduleId].exports;
            /******/
        }
        /******/ // Create a new module (and put it into the cache)
        /******/
        var module = installedModules[moduleId] = {
            /******/
            i: moduleId,
            /******/
            l: false,
            /******/
            exports: {}
            /******/
        };
        /******/
        /******/ // Execute the module function
        /******/
        modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
        /******/
        /******/ // Flag the module as loaded
        /******/
        module.l = true;
        /******/
        /******/ // Return the exports of the module
        /******/
        return module.exports;
        /******/
    }
    /******/
    /******/
    /******/ // expose the modules object (__webpack_modules__)
    /******/
    __webpack_require__.m = modules;
    /******/
    /******/ // expose the module cache
    /******/
    __webpack_require__.c = installedModules;
    /******/
    /******/ // define getter function for harmony exports
    /******/
    __webpack_require__.d = function(exports, name, getter) {
        /******/
        if (!__webpack_require__.o(exports, name)) {
            /******/
            Object.defineProperty(exports, name, {
                /******/
                configurable: false,
                /******/
                enumerable: true,
                /******/
                get: getter
                    /******/
            });
            /******/
        }
        /******/
    };
    /******/
    /******/ // getDefaultExport function for compatibility with non-harmony modules
    /******/
    __webpack_require__.n = function(module) {
        /******/
        var getter = module && module.__esModule ?
            /******/
            function getDefault() {
                return module['default'];
            } :
            /******/
            function getModuleExports() {
                return module;
            };
        /******/
        __webpack_require__.d(getter, 'a', getter);
        /******/
        return getter;
        /******/
    };
    /******/
    /******/ // Object.prototype.hasOwnProperty.call
    /******/
    __webpack_require__.o = function(object, property) {
        return Object.prototype.hasOwnProperty.call(object, property);
    };
    /******/
    /******/ // __webpack_public_path__
    /******/
    __webpack_require__.p = "";
    /******/
    /******/ // Load entry module and return exports
    /******/
    return __webpack_require__(__webpack_require__.s = 12);
    /******/
})
/************************************************************************/
/******/
([
    /* 0 */
    /***/
    (function(module, exports, __webpack_require__) {

        var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;
        /**
         * Fizzy UI utils v2.0.5
         * MIT license
         */

        /*jshint browser: true, undef: true, unused: true, strict: true */

        (function(window, factory) {
            // universal module definition
            /*jshint strict: false */
            /*globals define, module, require */

            if (true) {
                // AMD
                !(__WEBPACK_AMD_DEFINE_ARRAY__ = [
                        __webpack_require__(24)
                    ], __WEBPACK_AMD_DEFINE_RESULT__ = function(matchesSelector) {
                        return factory(window, matchesSelector);
                    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
                    __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
            } else if (typeof module == 'object' && module.exports) {
                // CommonJS
                module.exports = factory(
                    window,
                    require('desandro-matches-selector')
                );
            } else {
                // browser global
                window.fizzyUIUtils = factory(
                    window,
                    window.matchesSelector
                );
            }

        }(window, function factory(window, matchesSelector) {

            'use strict';

            var utils = {};

            // ----- extend ----- //

            // extends objects
            utils.extend = function(a, b) {
                for (var prop in b) {
                    a[prop] = b[prop];
                }
                return a;
            };

            // ----- modulo ----- //

            utils.modulo = function(num, div) {
                return ((num % div) + div) % div;
            };

            // ----- makeArray ----- //

            // turn element or nodeList into an array
            utils.makeArray = function(obj) {
                var ary = [];
                if (Array.isArray(obj)) {
                    // use object if already an array
                    ary = obj;
                } else if (obj && typeof obj == 'object' &&
                    typeof obj.length == 'number') {
                    // convert nodeList to array
                    for (var i = 0; i < obj.length; i++) {
                        ary.push(obj[i]);
                    }
                } else {
                    // array of single index
                    ary.push(obj);
                }
                return ary;
            };

            // ----- removeFrom ----- //

            utils.removeFrom = function(ary, obj) {
                var index = ary.indexOf(obj);
                if (index != -1) {
                    ary.splice(index, 1);
                }
            };

            // ----- getParent ----- //

            utils.getParent = function(elem, selector) {
                while (elem.parentNode && elem != document.body) {
                    elem = elem.parentNode;
                    if (matchesSelector(elem, selector)) {
                        return elem;
                    }
                }
            };

            // ----- getQueryElement ----- //

            // use element as selector string
            utils.getQueryElement = function(elem) {
                if (typeof elem == 'string') {
                    return document.querySelector(elem);
                }
                return elem;
            };

            // ----- handleEvent ----- //

            // enable .ontype to trigger from .addEventListener( elem, 'type' )
            utils.handleEvent = function(event) {
                var method = 'on' + event.type;
                if (this[method]) {
                    this[method](event);
                }
            };

            // ----- filterFindElements ----- //

            utils.filterFindElements = function(elems, selector) {
                // make array of elems
                elems = utils.makeArray(elems);
                var ffElems = [];

                elems.forEach(function(elem) {
                    // check that elem is an actual element
                    if (!(elem instanceof HTMLElement)) {
                        return;
                    }
                    // add elem if no selector
                    if (!selector) {
                        ffElems.push(elem);
                        return;
                    }
                    // filter & find items if we have a selector
                    // filter
                    if (matchesSelector(elem, selector)) {
                        ffElems.push(elem);
                    }
                    // find children
                    var childElems = elem.querySelectorAll(selector);
                    // concat childElems to filterFound array
                    for (var i = 0; i < childElems.length; i++) {
                        ffElems.push(childElems[i]);
                    }
                });

                return ffElems;
            };

            // ----- debounceMethod ----- //

            utils.debounceMethod = function(_class, methodName, threshold) {
                // original method
                var method = _class.prototype[methodName];
                var timeoutName = methodName + 'Timeout';

                _class.prototype[methodName] = function() {
                    var timeout = this[timeoutName];
                    if (timeout) {
                        clearTimeout(timeout);
                    }
                    var args = arguments;

                    var _this = this;
                    this[timeoutName] = setTimeout(function() {
                        method.apply(_this, args);
                        delete _this[timeoutName];
                    }, threshold || 100);
                };
            };

            // ----- docReady ----- //

            utils.docReady = function(callback) {
                var readyState = document.readyState;
                if (readyState == 'complete' || readyState == 'interactive') {
                    // do async to allow for other scripts to run. metafizzy/flickity#441
                    setTimeout(callback);
                } else {
                    document.addEventListener('DOMContentLoaded', callback);
                }
            };

            // ----- htmlInit ----- //

            // http://jamesroberts.name/blog/2010/02/22/string-functions-for-javascript-trim-to-camel-case-to-dashed-and-to-underscore/
            utils.toDashed = function(str) {
                return str.replace(/(.)([A-Z])/g, function(match, $1, $2) {
                    return $1 + '-' + $2;
                }).toLowerCase();
            };

            var console = window.console;
            /**
             * allow user to initialize classes via [data-namespace] or .js-namespace class
             * htmlInit( Widget, 'widgetName' )
             * options are parsed from data-namespace-options
             */
            utils.htmlInit = function(WidgetClass, namespace) {
                utils.docReady(function() {
                    var dashedNamespace = utils.toDashed(namespace);
                    var dataAttr = 'data-' + dashedNamespace;
                    var dataAttrElems = document.querySelectorAll('[' + dataAttr + ']');
                    var jsDashElems = document.querySelectorAll('.js-' + dashedNamespace);
                    var elems = utils.makeArray(dataAttrElems)
                        .concat(utils.makeArray(jsDashElems));
                    var dataOptionsAttr = dataAttr + '-options';
                    var jQuery = window.jQuery;

                    elems.forEach(function(elem) {
                        var attr = elem.getAttribute(dataAttr) ||
                            elem.getAttribute(dataOptionsAttr);
                        var options;
                        try {
                            options = attr && JSON.parse(attr);
                        } catch (error) {
                            // log error, do not initialize
                            if (console) {
                                console.error('Error parsing ' + dataAttr + ' on ' + elem.className +
                                    ': ' + error);
                            }
                            return;
                        }
                        // initialize
                        var instance = new WidgetClass(elem, options);
                        // make available via $().data('namespace')
                        if (jQuery) {
                            jQuery.data(elem, namespace, instance);
                        }
                    });

                });
            };

            // -----  ----- //

            return utils;

        }));


        /***/
    }),
    /* 1 */
    /***/
    (function(module, exports, __webpack_require__) {

        var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__; // Flickity main
        (function(window, factory) {
            // universal module definition
            /* jshint strict: false */
            if (true) {
                // AMD
                !(__WEBPACK_AMD_DEFINE_ARRAY__ = [
                        __webpack_require__(4),
                        __webpack_require__(5),
                        __webpack_require__(0),
                        __webpack_require__(25),
                        __webpack_require__(26),
                        __webpack_require__(27)
                    ], __WEBPACK_AMD_DEFINE_RESULT__ = function(EvEmitter, getSize, utils, Cell, Slide, animatePrototype) {
                        return factory(window, EvEmitter, getSize, utils, Cell, Slide, animatePrototype);
                    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
                    __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
            } else if (typeof module == 'object' && module.exports) {
                // CommonJS
                module.exports = factory(
                    window,
                    require('ev-emitter'),
                    require('get-size'),
                    require('fizzy-ui-utils'),
                    require('./cell'),
                    require('./slide'),
                    require('./animate')
                );
            } else {
                // browser global
                var _Flickity = window.Flickity;

                window.Flickity = factory(
                    window,
                    window.EvEmitter,
                    window.getSize,
                    window.fizzyUIUtils,
                    _Flickity.Cell,
                    _Flickity.Slide,
                    _Flickity.animatePrototype
                );
            }

        }(window, function factory(window, EvEmitter, getSize,
            utils, Cell, Slide, animatePrototype) {

            'use strict';

            // vars
            var jQuery = window.jQuery;
            var getComputedStyle = window.getComputedStyle;
            var console = window.console;

            function moveElements(elems, toElem) {
                elems = utils.makeArray(elems);
                while (elems.length) {
                    toElem.appendChild(elems.shift());
                }
            }

            // -------------------------- Flickity -------------------------- //

            // globally unique identifiers
            var GUID = 0;
            // internal store of all Flickity intances
            var instances = {};

            function Flickity(element, options) {
                var queryElement = utils.getQueryElement(element);
                if (!queryElement) {
                    if (console) {
                        console.error('Bad element for Flickity: ' + (queryElement || element));
                    }
                    return;
                }
                this.element = queryElement;
                // do not initialize twice on same element
                if (this.element.flickityGUID) {
                    var instance = instances[this.element.flickityGUID];
                    instance.option(options);
                    return instance;
                }

                // add jQuery
                if (jQuery) {
                    this.$element = jQuery(this.element);
                }
                // options
                this.options = utils.extend({}, this.constructor.defaults);
                this.option(options);

                // kick things off
                this._create();
            }

            Flickity.defaults = {
                accessibility: true,
                // adaptiveHeight: false,
                cellAlign: 'center',
                // cellSelector: undefined,
                // contain: false,
                freeScrollFriction: 0.075, // friction when free-scrolling
                friction: 0.28, // friction when selecting
                namespaceJQueryEvents: true,
                // initialIndex: 0,
                percentPosition: true,
                resize: true,
                selectedAttraction: 0.025,
                setGallerySize: true
                    // watchCSS: false,
                    // wrapAround: false
            };

            // hash of methods triggered on _create()
            Flickity.createMethods = [];

            var proto = Flickity.prototype;
            // inherit EventEmitter
            utils.extend(proto, EvEmitter.prototype);

            proto._create = function() {
                // add id for Flickity.data
                var id = this.guid = ++GUID;
                this.element.flickityGUID = id; // expando
                instances[id] = this; // associate via id
                // initial properties
                this.selectedIndex = 0;
                // how many frames slider has been in same position
                this.restingFrames = 0;
                // initial physics properties
                this.x = 0;
                this.velocity = 0;
                this.originSide = this.options.rightToLeft ? 'right' : 'left';
                // create viewport & slider
                this.viewport = document.createElement('div');
                this.viewport.className = 'flickity-viewport';
                this._createSlider();

                if (this.options.resize || this.options.watchCSS) {
                    window.addEventListener('resize', this);
                }

                Flickity.createMethods.forEach(function(method) {
                    this[method]();
                }, this);

                if (this.options.watchCSS) {
                    this.watchCSS();
                } else {
                    this.activate();
                }

            };

            /**
             * set options
             * @param {Object} opts
             */
            proto.option = function(opts) {
                utils.extend(this.options, opts);
            };

            proto.activate = function() {
                if (this.isActive) {
                    return;
                }
                this.isActive = true;
                this.element.classList.add('flickity-enabled');
                if (this.options.rightToLeft) {
                    this.element.classList.add('flickity-rtl');
                }

                this.getSize();
                // move initial cell elements so they can be loaded as cells
                var cellElems = this._filterFindCellElements(this.element.children);
                moveElements(cellElems, this.slider);
                this.viewport.appendChild(this.slider);
                this.element.appendChild(this.viewport);
                // get cells from children
                this.reloadCells();

                if (this.options.accessibility) {
                    // allow element to focusable
                    this.element.tabIndex = 0;
                    // listen for key presses
                    this.element.addEventListener('keydown', this);
                }

                this.emitEvent('activate');

                var index;
                var initialIndex = this.options.initialIndex;
                if (this.isInitActivated) {
                    index = this.selectedIndex;
                } else if (initialIndex !== undefined) {
                    index = this.cells[initialIndex] ? initialIndex : 0;
                } else {
                    index = 0;
                }
                // select instantly
                this.select(index, false, true);
                // flag for initial activation, for using initialIndex
                this.isInitActivated = true;
            };

            // slider positions the cells
            proto._createSlider = function() {
                // slider element does all the positioning
                var slider = document.createElement('div');
                slider.className = 'flickity-slider';
                slider.style[this.originSide] = 0;
                this.slider = slider;
            };

            proto._filterFindCellElements = function(elems) {
                return utils.filterFindElements(elems, this.options.cellSelector);
            };

            // goes through all children
            proto.reloadCells = function() {
                // collection of item elements
                this.cells = this._makeCells(this.slider.children);
                this.positionCells();
                this._getWrapShiftCells();
                this.setGallerySize();
            };

            /**
             * turn elements into Flickity.Cells
             * @param {Array or NodeList or HTMLElement} elems
             * @returns {Array} items - collection of new Flickity Cells
             */
            proto._makeCells = function(elems) {
                var cellElems = this._filterFindCellElements(elems);

                // create new Flickity for collection
                var cells = cellElems.map(function(cellElem) {
                    return new Cell(cellElem, this);
                }, this);

                return cells;
            };

            proto.getLastCell = function() {
                return this.cells[this.cells.length - 1];
            };

            proto.getLastSlide = function() {
                return this.slides[this.slides.length - 1];
            };

            // positions all cells
            proto.positionCells = function() {
                // size all cells
                this._sizeCells(this.cells);
                // position all cells
                this._positionCells(0);
            };

            /**
             * position certain cells
             * @param {Integer} index - which cell to start with
             */
            proto._positionCells = function(index) {
                index = index || 0;
                // also measure maxCellHeight
                // start 0 if positioning all cells
                this.maxCellHeight = index ? this.maxCellHeight || 0 : 0;
                var cellX = 0;
                // get cellX
                if (index > 0) {
                    var startCell = this.cells[index - 1];
                    cellX = startCell.x + startCell.size.outerWidth;
                }
                var len = this.cells.length;
                for (var i = index; i < len; i++) {
                    var cell = this.cells[i];
                    cell.setPosition(cellX);
                    cellX += cell.size.outerWidth;
                    this.maxCellHeight = Math.max(cell.size.outerHeight, this.maxCellHeight);
                }
                // keep track of cellX for wrap-around
                this.slideableWidth = cellX;
                // slides
                this.updateSlides();
                // contain slides target
                this._containSlides();
                // update slidesWidth
                this.slidesWidth = len ? this.getLastSlide().target - this.slides[0].target : 0;
            };

            /**
             * cell.getSize() on multiple cells
             * @param {Array} cells
             */
            proto._sizeCells = function(cells) {
                cells.forEach(function(cell) {
                    cell.getSize();
                });
            };

            // --------------------------  -------------------------- //

            proto.updateSlides = function() {
                this.slides = [];
                if (!this.cells.length) {
                    return;
                }

                var slide = new Slide(this);
                this.slides.push(slide);
                var isOriginLeft = this.originSide == 'left';
                var nextMargin = isOriginLeft ? 'marginRight' : 'marginLeft';

                var canCellFit = this._getCanCellFit();

                this.cells.forEach(function(cell, i) {
                    // just add cell if first cell in slide
                    if (!slide.cells.length) {
                        slide.addCell(cell);
                        return;
                    }

                    var slideWidth = (slide.outerWidth - slide.firstMargin) +
                        (cell.size.outerWidth - cell.size[nextMargin]);

                    if (canCellFit.call(this, i, slideWidth)) {
                        slide.addCell(cell);
                    } else {
                        // doesn't fit, new slide
                        slide.updateTarget();

                        slide = new Slide(this);
                        this.slides.push(slide);
                        slide.addCell(cell);
                    }
                }, this);
                // last slide
                slide.updateTarget();
                // update .selectedSlide
                this.updateSelectedSlide();
            };

            proto._getCanCellFit = function() {
                var groupCells = this.options.groupCells;
                if (!groupCells) {
                    return function() {
                        return false;
                    };
                } else if (typeof groupCells == 'number') {
                    // group by number. 3 -> [0,1,2], [3,4,5], ...
                    var number = parseInt(groupCells, 10);
                    return function(i) {
                        return (i % number) !== 0;
                    };
                }
                // default, group by width of slide
                // parse '75%
                var percentMatch = typeof groupCells == 'string' &&
                    groupCells.match(/^(\d+)%$/);
                var percent = percentMatch ? parseInt(percentMatch[1], 10) / 100 : 1;
                return function(i, slideWidth) {
                    return slideWidth <= (this.size.innerWidth + 1) * percent;
                };
            };

            // alias _init for jQuery plugin .flickity()
            proto._init =
                proto.reposition = function() {
                    this.positionCells();
                    this.positionSliderAtSelected();
                };

            proto.getSize = function() {
                this.size = getSize(this.element);
                this.setCellAlign();
                this.cursorPosition = this.size.innerWidth * this.cellAlign;
            };

            var cellAlignShorthands = {
                // cell align, then based on origin side
                center: {
                    left: 0.5,
                    right: 0.5
                },
                left: {
                    left: 0,
                    right: 1
                },
                right: {
                    right: 0,
                    left: 1
                }
            };

            proto.setCellAlign = function() {
                var shorthand = cellAlignShorthands[this.options.cellAlign];
                this.cellAlign = shorthand ? shorthand[this.originSide] : this.options.cellAlign;
            };

            proto.setGallerySize = function() {
                if (this.options.setGallerySize) {
                    var height = this.options.adaptiveHeight && this.selectedSlide ?
                        this.selectedSlide.height : this.maxCellHeight;
                    this.viewport.style.height = height + 'px';
                }
            };

            proto._getWrapShiftCells = function() {
                // only for wrap-around
                if (!this.options.wrapAround) {
                    return;
                }
                // unshift previous cells
                this._unshiftCells(this.beforeShiftCells);
                this._unshiftCells(this.afterShiftCells);
                // get before cells
                // initial gap
                var gapX = this.cursorPosition;
                var cellIndex = this.cells.length - 1;
                this.beforeShiftCells = this._getGapCells(gapX, cellIndex, -1);
                // get after cells
                // ending gap between last cell and end of gallery viewport
                gapX = this.size.innerWidth - this.cursorPosition;
                // start cloning at first cell, working forwards
                this.afterShiftCells = this._getGapCells(gapX, 0, 1);
            };

            proto._getGapCells = function(gapX, cellIndex, increment) {
                // keep adding cells until the cover the initial gap
                var cells = [];
                while (gapX > 0) {
                    var cell = this.cells[cellIndex];
                    if (!cell) {
                        break;
                    }
                    cells.push(cell);
                    cellIndex += increment;
                    gapX -= cell.size.outerWidth;
                }
                return cells;
            };

            // ----- contain ----- //

            // contain cell targets so no excess sliding
            proto._containSlides = function() {
                if (!this.options.contain || this.options.wrapAround || !this.cells.length) {
                    return;
                }
                var isRightToLeft = this.options.rightToLeft;
                var beginMargin = isRightToLeft ? 'marginRight' : 'marginLeft';
                var endMargin = isRightToLeft ? 'marginLeft' : 'marginRight';
                var contentWidth = this.slideableWidth - this.getLastCell().size[endMargin];
                // content is less than gallery size
                var isContentSmaller = contentWidth < this.size.innerWidth;
                // bounds
                var beginBound = this.cursorPosition + this.cells[0].size[beginMargin];
                var endBound = contentWidth - this.size.innerWidth * (1 - this.cellAlign);
                // contain each cell target
                this.slides.forEach(function(slide) {
                    if (isContentSmaller) {
                        // all cells fit inside gallery
                        slide.target = contentWidth * this.cellAlign;
                    } else {
                        // contain to bounds
                        slide.target = Math.max(slide.target, beginBound);
                        slide.target = Math.min(slide.target, endBound);
                    }
                }, this);
            };

            // -----  ----- //

            /**
             * emits events via eventEmitter and jQuery events
             * @param {String} type - name of event
             * @param {Event} event - original event
             * @param {Array} args - extra arguments
             */
            proto.dispatchEvent = function(type, event, args) {
                var emitArgs = event ? [event].concat(args) : args;
                this.emitEvent(type, emitArgs);

                if (jQuery && this.$element) {
                    // default trigger with type if no event
                    type += this.options.namespaceJQueryEvents ? '.flickity' : '';
                    var $event = type;
                    if (event) {
                        // create jQuery event
                        var jQEvent = jQuery.Event(event);
                        jQEvent.type = type;
                        $event = jQEvent;
                    }
                    this.$element.trigger($event, args);
                }
            };

            // -------------------------- select -------------------------- //

            /**
             * @param {Integer} index - index of the slide
             * @param {Boolean} isWrap - will wrap-around to last/first if at the end
             * @param {Boolean} isInstant - will immediately set position at selected cell
             */
            proto.select = function(index, isWrap, isInstant) {
                if (!this.isActive) {
                    return;
                }
                index = parseInt(index, 10);
                this._wrapSelect(index);

                if (this.options.wrapAround || isWrap) {
                    index = utils.modulo(index, this.slides.length);
                }
                // bail if invalid index
                if (!this.slides[index]) {
                    return;
                }
                this.selectedIndex = index;
                this.updateSelectedSlide();
                if (isInstant) {
                    this.positionSliderAtSelected();
                } else {
                    this.startAnimation();
                }
                if (this.options.adaptiveHeight) {
                    this.setGallerySize();
                }

                this.dispatchEvent('select');
                // old v1 event name, remove in v3
                this.dispatchEvent('cellSelect');
            };

            // wraps position for wrapAround, to move to closest slide. #113
            proto._wrapSelect = function(index) {
                var len = this.slides.length;
                var isWrapping = this.options.wrapAround && len > 1;
                if (!isWrapping) {
                    return index;
                }
                var wrapIndex = utils.modulo(index, len);
                // go to shortest
                var delta = Math.abs(wrapIndex - this.selectedIndex);
                var backWrapDelta = Math.abs((wrapIndex + len) - this.selectedIndex);
                var forewardWrapDelta = Math.abs((wrapIndex - len) - this.selectedIndex);
                if (!this.isDragSelect && backWrapDelta < delta) {
                    index += len;
                } else if (!this.isDragSelect && forewardWrapDelta < delta) {
                    index -= len;
                }
                // wrap position so slider is within normal area
                if (index < 0) {
                    this.x -= this.slideableWidth;
                } else if (index >= len) {
                    this.x += this.slideableWidth;
                }
            };

            proto.previous = function(isWrap, isInstant) {
                this.select(this.selectedIndex - 1, isWrap, isInstant);
            };

            proto.next = function(isWrap, isInstant) {
                this.select(this.selectedIndex + 1, isWrap, isInstant);
            };

            proto.updateSelectedSlide = function() {
                var slide = this.slides[this.selectedIndex];
                // selectedIndex could be outside of slides, if triggered before resize()
                if (!slide) {
                    return;
                }
                // unselect previous selected slide
                this.unselectSelectedSlide();
                // update new selected slide
                this.selectedSlide = slide;
                slide.select();
                this.selectedCells = slide.cells;
                this.selectedElements = slide.getCellElements();
                // HACK: selectedCell & selectedElement is first cell in slide, backwards compatibility
                // Remove in v3?
                this.selectedCell = slide.cells[0];
                this.selectedElement = this.selectedElements[0];
            };

            proto.unselectSelectedSlide = function() {
                if (this.selectedSlide) {
                    this.selectedSlide.unselect();
                }
            };

            /**
             * select slide from number or cell element
             * @param {Element or Number} elem
             */
            proto.selectCell = function(value, isWrap, isInstant) {
                // get cell
                var cell;
                if (typeof value == 'number') {
                    cell = this.cells[value];
                } else {
                    // use string as selector
                    if (typeof value == 'string') {
                        value = this.element.querySelector(value);
                    }
                    // get cell from element
                    cell = this.getCell(value);
                }
                // select slide that has cell
                for (var i = 0; cell && i < this.slides.length; i++) {
                    var slide = this.slides[i];
                    var index = slide.cells.indexOf(cell);
                    if (index != -1) {
                        this.select(i, isWrap, isInstant);
                        return;
                    }
                }
            };

            // -------------------------- get cells -------------------------- //

            /**
             * get Flickity.Cell, given an Element
             * @param {Element} elem
             * @returns {Flickity.Cell} item
             */
            proto.getCell = function(elem) {
                // loop through cells to get the one that matches
                for (var i = 0; i < this.cells.length; i++) {
                    var cell = this.cells[i];
                    if (cell.element == elem) {
                        return cell;
                    }
                }
            };

            /**
             * get collection of Flickity.Cells, given Elements
             * @param {Element, Array, NodeList} elems
             * @returns {Array} cells - Flickity.Cells
             */
            proto.getCells = function(elems) {
                elems = utils.makeArray(elems);
                var cells = [];
                elems.forEach(function(elem) {
                    var cell = this.getCell(elem);
                    if (cell) {
                        cells.push(cell);
                    }
                }, this);
                return cells;
            };

            /**
             * get cell elements
             * @returns {Array} cellElems
             */
            proto.getCellElements = function() {
                return this.cells.map(function(cell) {
                    return cell.element;
                });
            };

            /**
             * get parent cell from an element
             * @param {Element} elem
             * @returns {Flickit.Cell} cell
             */
            proto.getParentCell = function(elem) {
                // first check if elem is cell
                var cell = this.getCell(elem);
                if (cell) {
                    return cell;
                }
                // try to get parent cell elem
                elem = utils.getParent(elem, '.flickity-slider > *');
                return this.getCell(elem);
            };

            /**
             * get cells adjacent to a slide
             * @param {Integer} adjCount - number of adjacent slides
             * @param {Integer} index - index of slide to start
             * @returns {Array} cells - array of Flickity.Cells
             */
            proto.getAdjacentCellElements = function(adjCount, index) {
                if (!adjCount) {
                    return this.selectedSlide.getCellElements();
                }
                index = index === undefined ? this.selectedIndex : index;

                var len = this.slides.length;
                if (1 + (adjCount * 2) >= len) {
                    return this.getCellElements();
                }

                var cellElems = [];
                for (var i = index - adjCount; i <= index + adjCount; i++) {
                    var slideIndex = this.options.wrapAround ? utils.modulo(i, len) : i;
                    var slide = this.slides[slideIndex];
                    if (slide) {
                        cellElems = cellElems.concat(slide.getCellElements());
                    }
                }
                return cellElems;
            };

            // -------------------------- events -------------------------- //

            proto.uiChange = function() {
                this.emitEvent('uiChange');
            };

            proto.childUIPointerDown = function(event) {
                this.emitEvent('childUIPointerDown', [event]);
            };

            // ----- resize ----- //

            proto.onresize = function() {
                this.watchCSS();
                this.resize();
            };

            utils.debounceMethod(Flickity, 'onresize', 150);

            proto.resize = function() {
                if (!this.isActive) {
                    return;
                }
                this.getSize();
                // wrap values
                if (this.options.wrapAround) {
                    this.x = utils.modulo(this.x, this.slideableWidth);
                }
                this.positionCells();
                this._getWrapShiftCells();
                this.setGallerySize();
                this.emitEvent('resize');
                // update selected index for group slides, instant
                // TODO: position can be lost between groups of various numbers
                var selectedElement = this.selectedElements && this.selectedElements[0];
                this.selectCell(selectedElement, false, true);
            };

            // watches the :after property, activates/deactivates
            proto.watchCSS = function() {
                var watchOption = this.options.watchCSS;
                if (!watchOption) {
                    return;
                }

                var afterContent = getComputedStyle(this.element, ':after').content;
                // activate if :after { content: 'flickity' }
                if (afterContent.indexOf('flickity') != -1) {
                    this.activate();
                } else {
                    this.deactivate();
                }
            };

            // ----- keydown ----- //

            // go previous/next if left/right keys pressed
            proto.onkeydown = function(event) {
                // only work if element is in focus
                if (!this.options.accessibility ||
                    (document.activeElement && document.activeElement != this.element)) {
                    return;
                }

                if (event.keyCode == 37) {
                    // go left
                    var leftMethod = this.options.rightToLeft ? 'next' : 'previous';
                    this.uiChange();
                    this[leftMethod]();
                } else if (event.keyCode == 39) {
                    // go right
                    var rightMethod = this.options.rightToLeft ? 'previous' : 'next';
                    this.uiChange();
                    this[rightMethod]();
                }
            };

            // -------------------------- destroy -------------------------- //

            // deactivate all Flickity functionality, but keep stuff available
            proto.deactivate = function() {
                if (!this.isActive) {
                    return;
                }
                this.element.classList.remove('flickity-enabled');
                this.element.classList.remove('flickity-rtl');
                // destroy cells
                this.cells.forEach(function(cell) {
                    cell.destroy();
                });
                this.unselectSelectedSlide();
                this.element.removeChild(this.viewport);
                // move child elements back into element
                moveElements(this.slider.children, this.element);
                if (this.options.accessibility) {
                    this.element.removeAttribute('tabIndex');
                    this.element.removeEventListener('keydown', this);
                }
                // set flags
                this.isActive = false;
                this.emitEvent('deactivate');
            };

            proto.destroy = function() {
                this.deactivate();
                window.removeEventListener('resize', this);
                this.emitEvent('destroy');
                if (jQuery && this.$element) {
                    jQuery.removeData(this.element, 'flickity');
                }
                delete this.element.flickityGUID;
                delete instances[this.guid];
            };

            // -------------------------- prototype -------------------------- //

            utils.extend(proto, animatePrototype);

            // -------------------------- extras -------------------------- //

            /**
             * get Flickity instance from element
             * @param {Element} elem
             * @returns {Flickity}
             */
            Flickity.data = function(elem) {
                elem = utils.getQueryElement(elem);
                var id = elem && elem.flickityGUID;
                return id && instances[id];
            };

            utils.htmlInit(Flickity, 'flickity');

            if (jQuery && jQuery.bridget) {
                jQuery.bridget('flickity', Flickity);
            }

            // set internal jQuery, for Webpack + jQuery v3, #478
            Flickity.setJQuery = function(jq) {
                jQuery = jq;
            };

            Flickity.Cell = Cell;

            return Flickity;

        }));


        /***/
    }),
    /* 2 */
    /***/
    (function(module, exports, __webpack_require__) {

        var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;
        /*!
         * jQuery JavaScript Library v3.2.1
         * https://jquery.com/
         *
         * Includes Sizzle.js
         * https://sizzlejs.com/
         *
         * Copyright JS Foundation and other contributors
         * Released under the MIT license
         * https://jquery.org/license
         *
         * Date: 2017-03-20T18:59Z
         */
        (function(global, factory) {

            "use strict";

            if (typeof module === "object" && typeof module.exports === "object") {

                // For CommonJS and CommonJS-like environments where a proper `window`
                // is present, execute the factory and get jQuery.
                // For environments that do not have a `window` with a `document`
                // (such as Node.js), expose a factory as module.exports.
                // This accentuates the need for the creation of a real `window`.
                // e.g. var jQuery = require("jquery")(window);
                // See ticket #14549 for more info.
                module.exports = global.document ?
                    factory(global, true) :
                    function(w) {
                        if (!w.document) {
                            throw new Error("jQuery requires a window with a document");
                        }
                        return factory(w);
                    };
            } else {
                factory(global);
            }

            // Pass this if window is not defined yet
        })(typeof window !== "undefined" ? window : this, function(window, noGlobal) {

            // Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1
            // throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode
            // arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common
            // enough that all such attempts are guarded in a try block.
            "use strict";

            var arr = [];

            var document = window.document;

            var getProto = Object.getPrototypeOf;

            var slice = arr.slice;

            var concat = arr.concat;

            var push = arr.push;

            var indexOf = arr.indexOf;

            var class2type = {};

            var toString = class2type.toString;

            var hasOwn = class2type.hasOwnProperty;

            var fnToString = hasOwn.toString;

            var ObjectFunctionString = fnToString.call(Object);

            var support = {};



            function DOMEval(code, doc) {
                doc = doc || document;

                var script = doc.createElement("script");

                script.text = code;
                doc.head.appendChild(script).parentNode.removeChild(script);
            }
            /* global Symbol */
            // Defining this global in .eslintrc.json would create a danger of using the global
            // unguarded in another place, it seems safer to define global only for this module



            var
                version = "3.2.1",

                // Define a local copy of jQuery
                jQuery = function(selector, context) {

                    // The jQuery object is actually just the init constructor 'enhanced'
                    // Need init if jQuery is called (just allow error to be thrown if not included)
                    return new jQuery.fn.init(selector, context);
                },

                // Support: Android <=4.0 only
                // Make sure we trim BOM and NBSP
                rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,

                // Matches dashed string for camelizing
                rmsPrefix = /^-ms-/,
                rdashAlpha = /-([a-z])/g,

                // Used by jQuery.camelCase as callback to replace()
                fcamelCase = function(all, letter) {
                    return letter.toUpperCase();
                };

            jQuery.fn = jQuery.prototype = {

                // The current version of jQuery being used
                jquery: version,

                constructor: jQuery,

                // The default length of a jQuery object is 0
                length: 0,

                toArray: function() {
                    return slice.call(this);
                },

                // Get the Nth element in the matched element set OR
                // Get the whole matched element set as a clean array
                get: function(num) {

                    // Return all the elements in a clean array
                    if (num == null) {
                        return slice.call(this);
                    }

                    // Return just the one element from the set
                    return num < 0 ? this[num + this.length] : this[num];
                },

                // Take an array of elements and push it onto the stack
                // (returning the new matched element set)
                pushStack: function(elems) {

                    // Build a new jQuery matched element set
                    var ret = jQuery.merge(this.constructor(), elems);

                    // Add the old object onto the stack (as a reference)
                    ret.prevObject = this;

                    // Return the newly-formed element set
                    return ret;
                },

                // Execute a callback for every element in the matched set.
                each: function(callback) {
                    return jQuery.each(this, callback);
                },

                map: function(callback) {
                    return this.pushStack(jQuery.map(this, function(elem, i) {
                        return callback.call(elem, i, elem);
                    }));
                },

                slice: function() {
                    return this.pushStack(slice.apply(this, arguments));
                },

                first: function() {
                    return this.eq(0);
                },

                last: function() {
                    return this.eq(-1);
                },

                eq: function(i) {
                    var len = this.length,
                        j = +i + (i < 0 ? len : 0);
                    return this.pushStack(j >= 0 && j < len ? [this[j]] : []);
                },

                end: function() {
                    return this.prevObject || this.constructor();
                },

                // For internal use only.
                // Behaves like an Array's method, not like a jQuery method.
                push: push,
                sort: arr.sort,
                splice: arr.splice
            };

            jQuery.extend = jQuery.fn.extend = function() {
                var options, name, src, copy, copyIsArray, clone,
                    target = arguments[0] || {},
                    i = 1,
                    length = arguments.length,
                    deep = false;

                // Handle a deep copy situation
                if (typeof target === "boolean") {
                    deep = target;

                    // Skip the boolean and the target
                    target = arguments[i] || {};
                    i++;
                }

                // Handle case when target is a string or something (possible in deep copy)
                if (typeof target !== "object" && !jQuery.isFunction(target)) {
                    target = {};
                }

                // Extend jQuery itself if only one argument is passed
                if (i === length) {
                    target = this;
                    i--;
                }

                for (; i < length; i++) {

                    // Only deal with non-null/undefined values
                    if ((options = arguments[i]) != null) {

                        // Extend the base object
                        for (name in options) {
                            src = target[name];
                            copy = options[name];

                            // Prevent never-ending loop
                            if (target === copy) {
                                continue;
                            }

                            // Recurse if we're merging plain objects or arrays
                            if (deep && copy && (jQuery.isPlainObject(copy) ||
                                    (copyIsArray = Array.isArray(copy)))) {

                                if (copyIsArray) {
                                    copyIsArray = false;
                                    clone = src && Array.isArray(src) ? src : [];

                                } else {
                                    clone = src && jQuery.isPlainObject(src) ? src : {};
                                }

                                // Never move original objects, clone them
                                target[name] = jQuery.extend(deep, clone, copy);

                                // Don't bring in undefined values
                            } else if (copy !== undefined) {
                                target[name] = copy;
                            }
                        }
                    }
                }

                // Return the modified object
                return target;
            };

            jQuery.extend({

                // Unique for each copy of jQuery on the page
                expando: "jQuery" + (version + Math.random()).replace(/\D/g, ""),

                // Assume jQuery is ready without the ready module
                isReady: true,

                error: function(msg) {
                    throw new Error(msg);
                },

                noop: function() {},

                isFunction: function(obj) {
                    return jQuery.type(obj) === "function";
                },

                isWindow: function(obj) {
                    return obj != null && obj === obj.window;
                },

                isNumeric: function(obj) {

                    // As of jQuery 3.0, isNumeric is limited to
                    // strings and numbers (primitives or objects)
                    // that can be coerced to finite numbers (gh-2662)
                    var type = jQuery.type(obj);
                    return (type === "number" || type === "string") &&

                        // parseFloat NaNs numeric-cast false positives ("")
                        // ...but misinterprets leading-number strings, particularly hex literals ("0x...")
                        // subtraction forces infinities to NaN
                        !isNaN(obj - parseFloat(obj));
                },

                isPlainObject: function(obj) {
                    var proto, Ctor;

                    // Detect obvious negatives
                    // Use toString instead of jQuery.type to catch host objects
                    if (!obj || toString.call(obj) !== "[object Object]") {
                        return false;
                    }

                    proto = getProto(obj);

                    // Objects with no prototype (e.g., `Object.create( null )`) are plain
                    if (!proto) {
                        return true;
                    }

                    // Objects with prototype are plain iff they were constructed by a global Object function
                    Ctor = hasOwn.call(proto, "constructor") && proto.constructor;
                    return typeof Ctor === "function" && fnToString.call(Ctor) === ObjectFunctionString;
                },

                isEmptyObject: function(obj) {

                    /* eslint-disable no-unused-vars */
                    // See https://github.com/eslint/eslint/issues/6125
                    var name;

                    for (name in obj) {
                        return false;
                    }
                    return true;
                },

                type: function(obj) {
                    if (obj == null) {
                        return obj + "";
                    }

                    // Support: Android <=2.3 only (functionish RegExp)
                    return typeof obj === "object" || typeof obj === "function" ?
                        class2type[toString.call(obj)] || "object" :
                        typeof obj;
                },

                // Evaluates a script in a global context
                globalEval: function(code) {
                    DOMEval(code);
                },

                // Convert dashed to camelCase; used by the css and data modules
                // Support: IE <=9 - 11, Edge 12 - 13
                // Microsoft forgot to hump their vendor prefix (#9572)
                camelCase: function(string) {
                    return string.replace(rmsPrefix, "ms-").replace(rdashAlpha, fcamelCase);
                },

                each: function(obj, callback) {
                    var length, i = 0;

                    if (isArrayLike(obj)) {
                        length = obj.length;
                        for (; i < length; i++) {
                            if (callback.call(obj[i], i, obj[i]) === false) {
                                break;
                            }
                        }
                    } else {
                        for (i in obj) {
                            if (callback.call(obj[i], i, obj[i]) === false) {
                                break;
                            }
                        }
                    }

                    return obj;
                },

                // Support: Android <=4.0 only
                trim: function(text) {
                    return text == null ?
                        "" :
                        (text + "").replace(rtrim, "");
                },

                // results is for internal usage only
                makeArray: function(arr, results) {
                    var ret = results || [];

                    if (arr != null) {
                        if (isArrayLike(Object(arr))) {
                            jQuery.merge(ret,
                                typeof arr === "string" ? [arr] : arr
                            );
                        } else {
                            push.call(ret, arr);
                        }
                    }

                    return ret;
                },

                inArray: function(elem, arr, i) {
                    return arr == null ? -1 : indexOf.call(arr, elem, i);
                },

                // Support: Android <=4.0 only, PhantomJS 1 only
                // push.apply(_, arraylike) throws on ancient WebKit
                merge: function(first, second) {
                    var len = +second.length,
                        j = 0,
                        i = first.length;

                    for (; j < len; j++) {
                        first[i++] = second[j];
                    }

                    first.length = i;

                    return first;
                },

                grep: function(elems, callback, invert) {
                    var callbackInverse,
                        matches = [],
                        i = 0,
                        length = elems.length,
                        callbackExpect = !invert;

                    // Go through the array, only saving the items
                    // that pass the validator function
                    for (; i < length; i++) {
                        callbackInverse = !callback(elems[i], i);
                        if (callbackInverse !== callbackExpect) {
                            matches.push(elems[i]);
                        }
                    }

                    return matches;
                },

                // arg is for internal usage only
                map: function(elems, callback, arg) {
                    var length, value,
                        i = 0,
                        ret = [];

                    // Go through the array, translating each of the items to their new values
                    if (isArrayLike(elems)) {
                        length = elems.length;
                        for (; i < length; i++) {
                            value = callback(elems[i], i, arg);

                            if (value != null) {
                                ret.push(value);
                            }
                        }

                        // Go through every key on the object,
                    } else {
                        for (i in elems) {
                            value = callback(elems[i], i, arg);

                            if (value != null) {
                                ret.push(value);
                            }
                        }
                    }

                    // Flatten any nested arrays
                    return concat.apply([], ret);
                },

                // A global GUID counter for objects
                guid: 1,

                // Bind a function to a context, optionally partially applying any
                // arguments.
                proxy: function(fn, context) {
                    var tmp, args, proxy;

                    if (typeof context === "string") {
                        tmp = fn[context];
                        context = fn;
                        fn = tmp;
                    }

                    // Quick check to determine if target is callable, in the spec
                    // this throws a TypeError, but we will just return undefined.
                    if (!jQuery.isFunction(fn)) {
                        return undefined;
                    }

                    // Simulated bind
                    args = slice.call(arguments, 2);
                    proxy = function() {
                        return fn.apply(context || this, args.concat(slice.call(arguments)));
                    };

                    // Set the guid of unique handler to the same of original handler, so it can be removed
                    proxy.guid = fn.guid = fn.guid || jQuery.guid++;

                    return proxy;
                },

                now: Date.now,

                // jQuery.support is not used in Core but other projects attach their
                // properties to it so it needs to exist.
                support: support
            });

            if (typeof Symbol === "function") {
                jQuery.fn[Symbol.iterator] = arr[Symbol.iterator];
            }

            // Populate the class2type map
            jQuery.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "),
                function(i, name) {
                    class2type["[object " + name + "]"] = name.toLowerCase();
                });

            function isArrayLike(obj) {

                // Support: real iOS 8.2 only (not reproducible in simulator)
                // `in` check used to prevent JIT error (gh-2145)
                // hasOwn isn't used here due to false negatives
                // regarding Nodelist length in IE
                var length = !!obj && "length" in obj && obj.length,
                    type = jQuery.type(obj);

                if (type === "function" || jQuery.isWindow(obj)) {
                    return false;
                }

                return type === "array" || length === 0 ||
                    typeof length === "number" && length > 0 && (length - 1) in obj;
            }
            var Sizzle =
                /*!
                 * Sizzle CSS Selector Engine v2.3.3
                 * https://sizzlejs.com/
                 *
                 * Copyright jQuery Foundation and other contributors
                 * Released under the MIT license
                 * http://jquery.org/license
                 *
                 * Date: 2016-08-08
                 */
                (function(window) {

                    var i,
                        support,
                        Expr,
                        getText,
                        isXML,
                        tokenize,
                        compile,
                        select,
                        outermostContext,
                        sortInput,
                        hasDuplicate,

                        // Local document vars
                        setDocument,
                        document,
                        docElem,
                        documentIsHTML,
                        rbuggyQSA,
                        rbuggyMatches,
                        matches,
                        contains,

                        // Instance-specific data
                        expando = "sizzle" + 1 * new Date(),
                        preferredDoc = window.document,
                        dirruns = 0,
                        done = 0,
                        classCache = createCache(),
                        tokenCache = createCache(),
                        compilerCache = createCache(),
                        sortOrder = function(a, b) {
                            if (a === b) {
                                hasDuplicate = true;
                            }
                            return 0;
                        },

                        // Instance methods
                        hasOwn = ({}).hasOwnProperty,
                        arr = [],
                        pop = arr.pop,
                        push_native = arr.push,
                        push = arr.push,
                        slice = arr.slice,
                        // Use a stripped-down indexOf as it's faster than native
                        // https://jsperf.com/thor-indexof-vs-for/5
                        indexOf = function(list, elem) {
                            var i = 0,
                                len = list.length;
                            for (; i < len; i++) {
                                if (list[i] === elem) {
                                    return i;
                                }
                            }
                            return -1;
                        },

                        booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",

                        // Regular expressions

                        // http://www.w3.org/TR/css3-selectors/#whitespace
                        whitespace = "[\\x20\\t\\r\\n\\f]",

                        // http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
                        identifier = "(?:\\\\.|[\\w-]|[^\0-\\xa0])+",

                        // Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
                        attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +
                        // Operator (capture 2)
                        "*([*^$|!~]?=)" + whitespace +
                        // "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
                        "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace +
                        "*\\]",

                        pseudos = ":(" + identifier + ")(?:\\((" +
                        // To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
                        // 1. quoted (capture 3; capture 4 or capture 5)
                        "('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
                        // 2. simple (capture 6)
                        "((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +
                        // 3. anything else (capture 2)
                        ".*" +
                        ")\\)|)",

                        // Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
                        rwhitespace = new RegExp(whitespace + "+", "g"),
                        rtrim = new RegExp("^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g"),

                        rcomma = new RegExp("^" + whitespace + "*," + whitespace + "*"),
                        rcombinators = new RegExp("^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*"),

                        rattributeQuotes = new RegExp("=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g"),

                        rpseudo = new RegExp(pseudos),
                        ridentifier = new RegExp("^" + identifier + "$"),

                        matchExpr = {
                            "ID": new RegExp("^#(" + identifier + ")"),
                            "CLASS": new RegExp("^\\.(" + identifier + ")"),
                            "TAG": new RegExp("^(" + identifier + "|[*])"),
                            "ATTR": new RegExp("^" + attributes),
                            "PSEUDO": new RegExp("^" + pseudos),
                            "CHILD": new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +
                                "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
                                "*(\\d+)|))" + whitespace + "*\\)|)", "i"),
                            "bool": new RegExp("^(?:" + booleans + ")$", "i"),
                            // For use in libraries implementing .is()
                            // We use this for POS matching in `select`
                            "needsContext": new RegExp("^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
                                whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i")
                        },

                        rinputs = /^(?:input|select|textarea|button)$/i,
                        rheader = /^h\d$/i,

                        rnative = /^[^{]+\{\s*\[native \w/,

                        // Easily-parseable/retrievable ID or TAG or CLASS selectors
                        rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

                        rsibling = /[+~]/,

                        // CSS escapes
                        // http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
                        runescape = new RegExp("\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig"),
                        funescape = function(_, escaped, escapedWhitespace) {
                            var high = "0x" + escaped - 0x10000;
                            // NaN means non-codepoint
                            // Support: Firefox<24
                            // Workaround erroneous numeric interpretation of +"0x"
                            return high !== high || escapedWhitespace ?
                                escaped :
                                high < 0 ?
                                // BMP codepoint
                                String.fromCharCode(high + 0x10000) :
                                // Supplemental Plane codepoint (surrogate pair)
                                String.fromCharCode(high >> 10 | 0xD800, high & 0x3FF | 0xDC00);
                        },

                        // CSS string/identifier serialization
                        // https://drafts.csswg.org/cssom/#common-serializing-idioms
                        rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,
                        fcssescape = function(ch, asCodePoint) {
                            if (asCodePoint) {

                                // U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER
                                if (ch === "\0") {
                                    return "\uFFFD";
                                }

                                // Control characters and (dependent upon position) numbers get escaped as code points
                                return ch.slice(0, -1) + "\\" + ch.charCodeAt(ch.length - 1).toString(16) + " ";
                            }

                            // Other potentially-special ASCII characters get backslash-escaped
                            return "\\" + ch;
                        },

                        // Used for iframes
                        // See setDocument()
                        // Removing the function wrapper causes a "Permission Denied"
                        // error in IE
                        unloadHandler = function() {
                            setDocument();
                        },

                        disabledAncestor = addCombinator(
                            function(elem) {
                                return elem.disabled === true && ("form" in elem || "label" in elem);
                            }, {
                                dir: "parentNode",
                                next: "legend"
                            }
                        );

                    // Optimize for push.apply( _, NodeList )
                    try {
                        push.apply(
                            (arr = slice.call(preferredDoc.childNodes)),
                            preferredDoc.childNodes
                        );
                        // Support: Android<4.0
                        // Detect silently failing push.apply
                        arr[preferredDoc.childNodes.length].nodeType;
                    } catch (e) {
                        push = {
                            apply: arr.length ?

                                // Leverage slice if possible
                                function(target, els) {
                                    push_native.apply(target, slice.call(els));
                                } :

                                // Support: IE<9
                                // Otherwise append directly
                                function(target, els) {
                                    var j = target.length,
                                        i = 0;
                                    // Can't trust NodeList.length
                                    while ((target[j++] = els[i++])) {}
                                    target.length = j - 1;
                                }
                        };
                    }

                    function Sizzle(selector, context, results, seed) {
                        var m, i, elem, nid, match, groups, newSelector,
                            newContext = context && context.ownerDocument,

                            // nodeType defaults to 9, since context defaults to document
                            nodeType = context ? context.nodeType : 9;

                        results = results || [];

                        // Return early from calls with invalid selector or context
                        if (typeof selector !== "string" || !selector ||
                            nodeType !== 1 && nodeType !== 9 && nodeType !== 11) {

                            return results;
                        }

                        // Try to shortcut find operations (as opposed to filters) in HTML documents
                        if (!seed) {

                            if ((context ? context.ownerDocument || context : preferredDoc) !== document) {
                                setDocument(context);
                            }
                            context = context || document;

                            if (documentIsHTML) {

                                // If the selector is sufficiently simple, try using a "get*By*" DOM method
                                // (excepting DocumentFragment context, where the methods don't exist)
                                if (nodeType !== 11 && (match = rquickExpr.exec(selector))) {

                                    // ID selector
                                    if ((m = match[1])) {

                                        // Document context
                                        if (nodeType === 9) {
                                            if ((elem = context.getElementById(m))) {

                                                // Support: IE, Opera, Webkit
                                                // TODO: identify versions
                                                // getElementById can match elements by name instead of ID
                                                if (elem.id === m) {
                                                    results.push(elem);
                                                    return results;
                                                }
                                            } else {
                                                return results;
                                            }

                                            // Element context
                                        } else {

                                            // Support: IE, Opera, Webkit
                                            // TODO: identify versions
                                            // getElementById can match elements by name instead of ID
                                            if (newContext && (elem = newContext.getElementById(m)) &&
                                                contains(context, elem) &&
                                                elem.id === m) {

                                                results.push(elem);
                                                return results;
                                            }
                                        }

                                        // Type selector
                                    } else if (match[2]) {
                                        push.apply(results, context.getElementsByTagName(selector));
                                        return results;

                                        // Class selector
                                    } else if ((m = match[3]) && support.getElementsByClassName &&
                                        context.getElementsByClassName) {

                                        push.apply(results, context.getElementsByClassName(m));
                                        return results;
                                    }
                                }

                                // Take advantage of querySelectorAll
                                if (support.qsa &&
                                    !compilerCache[selector + " "] &&
                                    (!rbuggyQSA || !rbuggyQSA.test(selector))) {

                                    if (nodeType !== 1) {
                                        newContext = context;
                                        newSelector = selector;

                                        // qSA looks outside Element context, which is not what we want
                                        // Thanks to Andrew Dupont for this workaround technique
                                        // Support: IE <=8
                                        // Exclude object elements
                                    } else if (context.nodeName.toLowerCase() !== "object") {

                                        // Capture the context ID, setting it first if necessary
                                        if ((nid = context.getAttribute("id"))) {
                                            nid = nid.replace(rcssescape, fcssescape);
                                        } else {
                                            context.setAttribute("id", (nid = expando));
                                        }

                                        // Prefix every selector in the list
                                        groups = tokenize(selector);
                                        i = groups.length;
                                        while (i--) {
                                            groups[i] = "#" + nid + " " + toSelector(groups[i]);
                                        }
                                        newSelector = groups.join(",");

                                        // Expand context for sibling selectors
                                        newContext = rsibling.test(selector) && testContext(context.parentNode) ||
                                            context;
                                    }

                                    if (newSelector) {
                                        try {
                                            push.apply(results,
                                                newContext.querySelectorAll(newSelector)
                                            );
                                            return results;
                                        } catch (qsaError) {} finally {
                                            if (nid === expando) {
                                                context.removeAttribute("id");
                                            }
                                        }
                                    }
                                }
                            }
                        }

                        // All others
                        return select(selector.replace(rtrim, "$1"), context, results, seed);
                    }

                    /**
                     * Create key-value caches of limited size
                     * @returns {function(string, object)} Returns the Object data after storing it on itself with
                     *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
                     *	deleting the oldest entry
                     */
                    function createCache() {
                        var keys = [];

                        function cache(key, value) {
                            // Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
                            if (keys.push(key + " ") > Expr.cacheLength) {
                                // Only keep the most recent entries
                                delete cache[keys.shift()];
                            }
                            return (cache[key + " "] = value);
                        }
                        return cache;
                    }

                    /**
                     * Mark a function for special use by Sizzle
                     * @param {Function} fn The function to mark
                     */
                    function markFunction(fn) {
                        fn[expando] = true;
                        return fn;
                    }

                    /**
                     * Support testing using an element
                     * @param {Function} fn Passed the created element and returns a boolean result
                     */
                    function assert(fn) {
                        var el = document.createElement("fieldset");

                        try {
                            return !!fn(el);
                        } catch (e) {
                            return false;
                        } finally {
                            // Remove from its parent by default
                            if (el.parentNode) {
                                el.parentNode.removeChild(el);
                            }
                            // release memory in IE
                            el = null;
                        }
                    }

                    /**
                     * Adds the same handler for all of the specified attrs
                     * @param {String} attrs Pipe-separated list of attributes
                     * @param {Function} handler The method that will be applied
                     */
                    function addHandle(attrs, handler) {
                        var arr = attrs.split("|"),
                            i = arr.length;

                        while (i--) {
                            Expr.attrHandle[arr[i]] = handler;
                        }
                    }

                    /**
                     * Checks document order of two siblings
                     * @param {Element} a
                     * @param {Element} b
                     * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
                     */
                    function siblingCheck(a, b) {
                        var cur = b && a,
                            diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
                            a.sourceIndex - b.sourceIndex;

                        // Use IE sourceIndex if available on both nodes
                        if (diff) {
                            return diff;
                        }

                        // Check if b follows a
                        if (cur) {
                            while ((cur = cur.nextSibling)) {
                                if (cur === b) {
                                    return -1;
                                }
                            }
                        }

                        return a ? 1 : -1;
                    }

                    /**
                     * Returns a function to use in pseudos for input types
                     * @param {String} type
                     */
                    function createInputPseudo(type) {
                        return function(elem) {
                            var name = elem.nodeName.toLowerCase();
                            return name === "input" && elem.type === type;
                        };
                    }

                    /**
                     * Returns a function to use in pseudos for buttons
                     * @param {String} type
                     */
                    function createButtonPseudo(type) {
                        return function(elem) {
                            var name = elem.nodeName.toLowerCase();
                            return (name === "input" || name === "button") && elem.type === type;
                        };
                    }

                    /**
                     * Returns a function to use in pseudos for :enabled/:disabled
                     * @param {Boolean} disabled true for :disabled; false for :enabled
                     */
                    function createDisabledPseudo(disabled) {

                        // Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable
                        return function(elem) {

                            // Only certain elements can match :enabled or :disabled
                            // https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled
                            // https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled
                            if ("form" in elem) {

                                // Check for inherited disabledness on relevant non-disabled elements:
                                // * listed form-associated elements in a disabled fieldset
                                //   https://html.spec.whatwg.org/multipage/forms.html#category-listed
                                //   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled
                                // * option elements in a disabled optgroup
                                //   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled
                                // All such elements have a "form" property.
                                if (elem.parentNode && elem.disabled === false) {

                                    // Option elements defer to a parent optgroup if present
                                    if ("label" in elem) {
                                        if ("label" in elem.parentNode) {
                                            return elem.parentNode.disabled === disabled;
                                        } else {
                                            return elem.disabled === disabled;
                                        }
                                    }

                                    // Support: IE 6 - 11
                                    // Use the isDisabled shortcut property to check for disabled fieldset ancestors
                                    return elem.isDisabled === disabled ||

                                        // Where there is no isDisabled, check manually
                                        /* jshint -W018 */
                                        elem.isDisabled !== !disabled &&
                                        disabledAncestor(elem) === disabled;
                                }

                                return elem.disabled === disabled;

                                // Try to winnow out elements that can't be disabled before trusting the disabled property.
                                // Some victims get caught in our net (label, legend, menu, track), but it shouldn't
                                // even exist on them, let alone have a boolean value.
                            } else if ("label" in elem) {
                                return elem.disabled === disabled;
                            }

                            // Remaining elements are neither :enabled nor :disabled
                            return false;
                        };
                    }

                    /**
                     * Returns a function to use in pseudos for positionals
                     * @param {Function} fn
                     */
                    function createPositionalPseudo(fn) {
                        return markFunction(function(argument) {
                            argument = +argument;
                            return markFunction(function(seed, matches) {
                                var j,
                                    matchIndexes = fn([], seed.length, argument),
                                    i = matchIndexes.length;

                                // Match elements found at the specified indexes
                                while (i--) {
                                    if (seed[(j = matchIndexes[i])]) {
                                        seed[j] = !(matches[j] = seed[j]);
                                    }
                                }
                            });
                        });
                    }

                    /**
                     * Checks a node for validity as a Sizzle context
                     * @param {Element|Object=} context
                     * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
                     */
                    function testContext(context) {
                        return context && typeof context.getElementsByTagName !== "undefined" && context;
                    }

                    // Expose support vars for convenience
                    support = Sizzle.support = {};

                    /**
                     * Detects XML nodes
                     * @param {Element|Object} elem An element or a document
                     * @returns {Boolean} True iff elem is a non-HTML XML node
                     */
                    isXML = Sizzle.isXML = function(elem) {
                        // documentElement is verified for cases where it doesn't yet exist
                        // (such as loading iframes in IE - #4833)
                        var documentElement = elem && (elem.ownerDocument || elem).documentElement;
                        return documentElement ? documentElement.nodeName !== "HTML" : false;
                    };

                    /**
                     * Sets document-related variables once based on the current document
                     * @param {Element|Object} [doc] An element or document object to use to set the document
                     * @returns {Object} Returns the current document
                     */
                    setDocument = Sizzle.setDocument = function(node) {
                        var hasCompare, subWindow,
                            doc = node ? node.ownerDocument || node : preferredDoc;

                        // Return early if doc is invalid or already selected
                        if (doc === document || doc.nodeType !== 9 || !doc.documentElement) {
                            return document;
                        }

                        // Update global variables
                        document = doc;
                        docElem = document.documentElement;
                        documentIsHTML = !isXML(document);

                        // Support: IE 9-11, Edge
                        // Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)
                        if (preferredDoc !== document &&
                            (subWindow = document.defaultView) && subWindow.top !== subWindow) {

                            // Support: IE 11, Edge
                            if (subWindow.addEventListener) {
                                subWindow.addEventListener("unload", unloadHandler, false);

                                // Support: IE 9 - 10 only
                            } else if (subWindow.attachEvent) {
                                subWindow.attachEvent("onunload", unloadHandler);
                            }
                        }

                        /* Attributes
                        ---------------------------------------------------------------------- */

                        // Support: IE<8
                        // Verify that getAttribute really returns attributes and not properties
                        // (excepting IE8 booleans)
                        support.attributes = assert(function(el) {
                            el.className = "i";
                            return !el.getAttribute("className");
                        });

                        /* getElement(s)By*
                        ---------------------------------------------------------------------- */

                        // Check if getElementsByTagName("*") returns only elements
                        support.getElementsByTagName = assert(function(el) {
                            el.appendChild(document.createComment(""));
                            return !el.getElementsByTagName("*").length;
                        });

                        // Support: IE<9
                        support.getElementsByClassName = rnative.test(document.getElementsByClassName);

                        // Support: IE<10
                        // Check if getElementById returns elements by name
                        // The broken getElementById methods don't pick up programmatically-set names,
                        // so use a roundabout getElementsByName test
                        support.getById = assert(function(el) {
                            docElem.appendChild(el).id = expando;
                            return !document.getElementsByName || !document.getElementsByName(expando).length;
                        });

                        // ID filter and find
                        if (support.getById) {
                            Expr.filter["ID"] = function(id) {
                                var attrId = id.replace(runescape, funescape);
                                return function(elem) {
                                    return elem.getAttribute("id") === attrId;
                                };
                            };
                            Expr.find["ID"] = function(id, context) {
                                if (typeof context.getElementById !== "undefined" && documentIsHTML) {
                                    var elem = context.getElementById(id);
                                    return elem ? [elem] : [];
                                }
                            };
                        } else {
                            Expr.filter["ID"] = function(id) {
                                var attrId = id.replace(runescape, funescape);
                                return function(elem) {
                                    var node = typeof elem.getAttributeNode !== "undefined" &&
                                        elem.getAttributeNode("id");
                                    return node && node.value === attrId;
                                };
                            };

                            // Support: IE 6 - 7 only
                            // getElementById is not reliable as a find shortcut
                            Expr.find["ID"] = function(id, context) {
                                if (typeof context.getElementById !== "undefined" && documentIsHTML) {
                                    var node, i, elems,
                                        elem = context.getElementById(id);

                                    if (elem) {

                                        // Verify the id attribute
                                        node = elem.getAttributeNode("id");
                                        if (node && node.value === id) {
                                            return [elem];
                                        }

                                        // Fall back on getElementsByName
                                        elems = context.getElementsByName(id);
                                        i = 0;
                                        while ((elem = elems[i++])) {
                                            node = elem.getAttributeNode("id");
                                            if (node && node.value === id) {
                                                return [elem];
                                            }
                                        }
                                    }

                                    return [];
                                }
                            };
                        }

                        // Tag
                        Expr.find["TAG"] = support.getElementsByTagName ?
                            function(tag, context) {
                                if (typeof context.getElementsByTagName !== "undefined") {
                                    return context.getElementsByTagName(tag);

                                    // DocumentFragment nodes don't have gEBTN
                                } else if (support.qsa) {
                                    return context.querySelectorAll(tag);
                                }
                            } :

                            function(tag, context) {
                                var elem,
                                    tmp = [],
                                    i = 0,
                                    // By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
                                    results = context.getElementsByTagName(tag);

                                // Filter out possible comments
                                if (tag === "*") {
                                    while ((elem = results[i++])) {
                                        if (elem.nodeType === 1) {
                                            tmp.push(elem);
                                        }
                                    }

                                    return tmp;
                                }
                                return results;
                            };

                        // Class
                        Expr.find["CLASS"] = support.getElementsByClassName && function(className, context) {
                            if (typeof context.getElementsByClassName !== "undefined" && documentIsHTML) {
                                return context.getElementsByClassName(className);
                            }
                        };

                        /* QSA/matchesSelector
                        ---------------------------------------------------------------------- */

                        // QSA and matchesSelector support

                        // matchesSelector(:active) reports false when true (IE9/Opera 11.5)
                        rbuggyMatches = [];

                        // qSa(:focus) reports false when true (Chrome 21)
                        // We allow this because of a bug in IE8/9 that throws an error
                        // whenever `document.activeElement` is accessed on an iframe
                        // So, we allow :focus to pass through QSA all the time to avoid the IE error
                        // See https://bugs.jquery.com/ticket/13378
                        rbuggyQSA = [];

                        if ((support.qsa = rnative.test(document.querySelectorAll))) {
                            // Build QSA regex
                            // Regex strategy adopted from Diego Perini
                            assert(function(el) {
                                // Select is set to empty string on purpose
                                // This is to test IE's treatment of not explicitly
                                // setting a boolean content attribute,
                                // since its presence should be enough
                                // https://bugs.jquery.com/ticket/12359
                                docElem.appendChild(el).innerHTML = "<a id='" + expando + "'></a>" +
                                    "<select id='" + expando + "-\r\\' msallowcapture=''>" +
                                    "<option selected=''></option></select>";

                                // Support: IE8, Opera 11-12.16
                                // Nothing should be selected when empty strings follow ^= or $= or *=
                                // The test attribute must be unknown in Opera but "safe" for WinRT
                                // https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
                                if (el.querySelectorAll("[msallowcapture^='']").length) {
                                    rbuggyQSA.push("[*^$]=" + whitespace + "*(?:''|\"\")");
                                }

                                // Support: IE8
                                // Boolean attributes and "value" are not treated correctly
                                if (!el.querySelectorAll("[selected]").length) {
                                    rbuggyQSA.push("\\[" + whitespace + "*(?:value|" + booleans + ")");
                                }

                                // Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+
                                if (!el.querySelectorAll("[id~=" + expando + "-]").length) {
                                    rbuggyQSA.push("~=");
                                }

                                // Webkit/Opera - :checked should return selected option elements
                                // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
                                // IE8 throws error here and will not see later tests
                                if (!el.querySelectorAll(":checked").length) {
                                    rbuggyQSA.push(":checked");
                                }

                                // Support: Safari 8+, iOS 8+
                                // https://bugs.webkit.org/show_bug.cgi?id=136851
                                // In-page `selector#id sibling-combinator selector` fails
                                if (!el.querySelectorAll("a#" + expando + "+*").length) {
                                    rbuggyQSA.push(".#.+[+~]");
                                }
                            });

                            assert(function(el) {
                                el.innerHTML = "<a href='' disabled='disabled'></a>" +
                                    "<select disabled='disabled'><option/></select>";

                                // Support: Windows 8 Native Apps
                                // The type and name attributes are restricted during .innerHTML assignment
                                var input = document.createElement("input");
                                input.setAttribute("type", "hidden");
                                el.appendChild(input).setAttribute("name", "D");

                                // Support: IE8
                                // Enforce case-sensitivity of name attribute
                                if (el.querySelectorAll("[name=d]").length) {
                                    rbuggyQSA.push("name" + whitespace + "*[*^$|!~]?=");
                                }

                                // FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
                                // IE8 throws error here and will not see later tests
                                if (el.querySelectorAll(":enabled").length !== 2) {
                                    rbuggyQSA.push(":enabled", ":disabled");
                                }

                                // Support: IE9-11+
                                // IE's :disabled selector does not pick up the children of disabled fieldsets
                                docElem.appendChild(el).disabled = true;
                                if (el.querySelectorAll(":disabled").length !== 2) {
                                    rbuggyQSA.push(":enabled", ":disabled");
                                }

                                // Opera 10-11 does not throw on post-comma invalid pseudos
                                el.querySelectorAll("*,:x");
                                rbuggyQSA.push(",.*:");
                            });
                        }

                        if ((support.matchesSelector = rnative.test((matches = docElem.matches ||
                                docElem.webkitMatchesSelector ||
                                docElem.mozMatchesSelector ||
                                docElem.oMatchesSelector ||
                                docElem.msMatchesSelector)))) {

                            assert(function(el) {
                                // Check to see if it's possible to do matchesSelector
                                // on a disconnected node (IE 9)
                                support.disconnectedMatch = matches.call(el, "*");

                                // This should fail with an exception
                                // Gecko does not error, returns false instead
                                matches.call(el, "[s!='']:x");
                                rbuggyMatches.push("!=", pseudos);
                            });
                        }

                        rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join("|"));
                        rbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join("|"));

                        /* Contains
                        ---------------------------------------------------------------------- */
                        hasCompare = rnative.test(docElem.compareDocumentPosition);

                        // Element contains another
                        // Purposefully self-exclusive
                        // As in, an element does not contain itself
                        contains = hasCompare || rnative.test(docElem.contains) ?
                            function(a, b) {
                                var adown = a.nodeType === 9 ? a.documentElement : a,
                                    bup = b && b.parentNode;
                                return a === bup || !!(bup && bup.nodeType === 1 && (
                                    adown.contains ?
                                    adown.contains(bup) :
                                    a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16
                                ));
                            } :
                            function(a, b) {
                                if (b) {
                                    while ((b = b.parentNode)) {
                                        if (b === a) {
                                            return true;
                                        }
                                    }
                                }
                                return false;
                            };

                        /* Sorting
                        ---------------------------------------------------------------------- */

                        // Document order sorting
                        sortOrder = hasCompare ?
                            function(a, b) {

                                // Flag for duplicate removal
                                if (a === b) {
                                    hasDuplicate = true;
                                    return 0;
                                }

                                // Sort on method existence if only one input has compareDocumentPosition
                                var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
                                if (compare) {
                                    return compare;
                                }

                                // Calculate position if both inputs belong to the same document
                                compare = (a.ownerDocument || a) === (b.ownerDocument || b) ?
                                    a.compareDocumentPosition(b) :

                                    // Otherwise we know they are disconnected
                                    1;

                                // Disconnected nodes
                                if (compare & 1 ||
                                    (!support.sortDetached && b.compareDocumentPosition(a) === compare)) {

                                    // Choose the first element that is related to our preferred document
                                    if (a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a)) {
                                        return -1;
                                    }
                                    if (b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b)) {
                                        return 1;
                                    }

                                    // Maintain original order
                                    return sortInput ?
                                        (indexOf(sortInput, a) - indexOf(sortInput, b)) :
                                        0;
                                }

                                return compare & 4 ? -1 : 1;
                            } :
                            function(a, b) {
                                // Exit early if the nodes are identical
                                if (a === b) {
                                    hasDuplicate = true;
                                    return 0;
                                }

                                var cur,
                                    i = 0,
                                    aup = a.parentNode,
                                    bup = b.parentNode,
                                    ap = [a],
                                    bp = [b];

                                // Parentless nodes are either documents or disconnected
                                if (!aup || !bup) {
                                    return a === document ? -1 :
                                        b === document ? 1 :
                                        aup ? -1 :
                                        bup ? 1 :
                                        sortInput ?
                                        (indexOf(sortInput, a) - indexOf(sortInput, b)) :
                                        0;

                                    // If the nodes are siblings, we can do a quick check
                                } else if (aup === bup) {
                                    return siblingCheck(a, b);
                                }

                                // Otherwise we need full lists of their ancestors for comparison
                                cur = a;
                                while ((cur = cur.parentNode)) {
                                    ap.unshift(cur);
                                }
                                cur = b;
                                while ((cur = cur.parentNode)) {
                                    bp.unshift(cur);
                                }

                                // Walk down the tree looking for a discrepancy
                                while (ap[i] === bp[i]) {
                                    i++;
                                }

                                return i ?
                                    // Do a sibling check if the nodes have a common ancestor
                                    siblingCheck(ap[i], bp[i]) :

                                    // Otherwise nodes in our document sort first
                                    ap[i] === preferredDoc ? -1 :
                                    bp[i] === preferredDoc ? 1 :
                                    0;
                            };

                        return document;
                    };

                    Sizzle.matches = function(expr, elements) {
                        return Sizzle(expr, null, null, elements);
                    };

                    Sizzle.matchesSelector = function(elem, expr) {
                        // Set document vars if needed
                        if ((elem.ownerDocument || elem) !== document) {
                            setDocument(elem);
                        }

                        // Make sure that attribute selectors are quoted
                        expr = expr.replace(rattributeQuotes, "='$1']");

                        if (support.matchesSelector && documentIsHTML &&
                            !compilerCache[expr + " "] &&
                            (!rbuggyMatches || !rbuggyMatches.test(expr)) &&
                            (!rbuggyQSA || !rbuggyQSA.test(expr))) {

                            try {
                                var ret = matches.call(elem, expr);

                                // IE 9's matchesSelector returns false on disconnected nodes
                                if (ret || support.disconnectedMatch ||
                                    // As well, disconnected nodes are said to be in a document
                                    // fragment in IE 9
                                    elem.document && elem.document.nodeType !== 11) {
                                    return ret;
                                }
                            } catch (e) {}
                        }

                        return Sizzle(expr, document, null, [elem]).length > 0;
                    };

                    Sizzle.contains = function(context, elem) {
                        // Set document vars if needed
                        if ((context.ownerDocument || context) !== document) {
                            setDocument(context);
                        }
                        return contains(context, elem);
                    };

                    Sizzle.attr = function(elem, name) {
                        // Set document vars if needed
                        if ((elem.ownerDocument || elem) !== document) {
                            setDocument(elem);
                        }

                        var fn = Expr.attrHandle[name.toLowerCase()],
                            // Don't get fooled by Object.prototype properties (jQuery #13807)
                            val = fn && hasOwn.call(Expr.attrHandle, name.toLowerCase()) ?
                            fn(elem, name, !documentIsHTML) :
                            undefined;

                        return val !== undefined ?
                            val :
                            support.attributes || !documentIsHTML ?
                            elem.getAttribute(name) :
                            (val = elem.getAttributeNode(name)) && val.specified ?
                            val.value :
                            null;
                    };

                    Sizzle.escape = function(sel) {
                        return (sel + "").replace(rcssescape, fcssescape);
                    };

                    Sizzle.error = function(msg) {
                        throw new Error("Syntax error, unrecognized expression: " + msg);
                    };

                    /**
                     * Document sorting and removing duplicates
                     * @param {ArrayLike} results
                     */
                    Sizzle.uniqueSort = function(results) {
                        var elem,
                            duplicates = [],
                            j = 0,
                            i = 0;

                        // Unless we *know* we can detect duplicates, assume their presence
                        hasDuplicate = !support.detectDuplicates;
                        sortInput = !support.sortStable && results.slice(0);
                        results.sort(sortOrder);

                        if (hasDuplicate) {
                            while ((elem = results[i++])) {
                                if (elem === results[i]) {
                                    j = duplicates.push(i);
                                }
                            }
                            while (j--) {
                                results.splice(duplicates[j], 1);
                            }
                        }

                        // Clear input after sorting to release objects
                        // See https://github.com/jquery/sizzle/pull/225
                        sortInput = null;

                        return results;
                    };

                    /**
                     * Utility function for retrieving the text value of an array of DOM nodes
                     * @param {Array|Element} elem
                     */
                    getText = Sizzle.getText = function(elem) {
                        var node,
                            ret = "",
                            i = 0,
                            nodeType = elem.nodeType;

                        if (!nodeType) {
                            // If no nodeType, this is expected to be an array
                            while ((node = elem[i++])) {
                                // Do not traverse comment nodes
                                ret += getText(node);
                            }
                        } else if (nodeType === 1 || nodeType === 9 || nodeType === 11) {
                            // Use textContent for elements
                            // innerText usage removed for consistency of new lines (jQuery #11153)
                            if (typeof elem.textContent === "string") {
                                return elem.textContent;
                            } else {
                                // Traverse its children
                                for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
                                    ret += getText(elem);
                                }
                            }
                        } else if (nodeType === 3 || nodeType === 4) {
                            return elem.nodeValue;
                        }
                        // Do not include comment or processing instruction nodes

                        return ret;
                    };

                    Expr = Sizzle.selectors = {

                        // Can be adjusted by the user
                        cacheLength: 50,

                        createPseudo: markFunction,

                        match: matchExpr,

                        attrHandle: {},

                        find: {},

                        relative: {
                            ">": {
                                dir: "parentNode",
                                first: true
                            },
                            " ": {
                                dir: "parentNode"
                            },
                            "+": {
                                dir: "previousSibling",
                                first: true
                            },
                            "~": {
                                dir: "previousSibling"
                            }
                        },

                        preFilter: {
                            "ATTR": function(match) {
                                match[1] = match[1].replace(runescape, funescape);

                                // Move the given value to match[3] whether quoted or unquoted
                                match[3] = (match[3] || match[4] || match[5] || "").replace(runescape, funescape);

                                if (match[2] === "~=") {
                                    match[3] = " " + match[3] + " ";
                                }

                                return match.slice(0, 4);
                            },

                            "CHILD": function(match) {
                                /* matches from matchExpr["CHILD"]
                                	1 type (only|nth|...)
                                	2 what (child|of-type)
                                	3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
                                	4 xn-component of xn+y argument ([+-]?\d*n|)
                                	5 sign of xn-component
                                	6 x of xn-component
                                	7 sign of y-component
                                	8 y of y-component
                                */
                                match[1] = match[1].toLowerCase();

                                if (match[1].slice(0, 3) === "nth") {
                                    // nth-* requires argument
                                    if (!match[3]) {
                                        Sizzle.error(match[0]);
                                    }

                                    // numeric x and y parameters for Expr.filter.CHILD
                                    // remember that false/true cast respectively to 0/1
                                    match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * (match[3] === "even" || match[3] === "odd"));
                                    match[5] = +((match[7] + match[8]) || match[3] === "odd");

                                    // other types prohibit arguments
                                } else if (match[3]) {
                                    Sizzle.error(match[0]);
                                }

                                return match;
                            },

                            "PSEUDO": function(match) {
                                var excess,
                                    unquoted = !match[6] && match[2];

                                if (matchExpr["CHILD"].test(match[0])) {
                                    return null;
                                }

                                // Accept quoted arguments as-is
                                if (match[3]) {
                                    match[2] = match[4] || match[5] || "";

                                    // Strip excess characters from unquoted arguments
                                } else if (unquoted && rpseudo.test(unquoted) &&
                                    // Get excess from tokenize (recursively)
                                    (excess = tokenize(unquoted, true)) &&
                                    // advance to the next closing parenthesis
                                    (excess = unquoted.indexOf(")", unquoted.length - excess) - unquoted.length)) {

                                    // excess is a negative index
                                    match[0] = match[0].slice(0, excess);
                                    match[2] = unquoted.slice(0, excess);
                                }

                                // Return only captures needed by the pseudo filter method (type and argument)
                                return match.slice(0, 3);
                            }
                        },

                        filter: {

                            "TAG": function(nodeNameSelector) {
                                var nodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();
                                return nodeNameSelector === "*" ?
                                    function() {
                                        return true;
                                    } :
                                    function(elem) {
                                        return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
                                    };
                            },

                            "CLASS": function(className) {
                                var pattern = classCache[className + " "];

                                return pattern ||
                                    (pattern = new RegExp("(^|" + whitespace + ")" + className + "(" + whitespace + "|$)")) &&
                                    classCache(className, function(elem) {
                                        return pattern.test(typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "");
                                    });
                            },

                            "ATTR": function(name, operator, check) {
                                return function(elem) {
                                    var result = Sizzle.attr(elem, name);

                                    if (result == null) {
                                        return operator === "!=";
                                    }
                                    if (!operator) {
                                        return true;
                                    }

                                    result += "";

                                    return operator === "=" ? result === check :
                                        operator === "!=" ? result !== check :
                                        operator === "^=" ? check && result.indexOf(check) === 0 :
                                        operator === "*=" ? check && result.indexOf(check) > -1 :
                                        operator === "$=" ? check && result.slice(-check.length) === check :
                                        operator === "~=" ? (" " + result.replace(rwhitespace, " ") + " ").indexOf(check) > -1 :
                                        operator === "|=" ? result === check || result.slice(0, check.length + 1) === check + "-" :
                                        false;
                                };
                            },

                            "CHILD": function(type, what, argument, first, last) {
                                var simple = type.slice(0, 3) !== "nth",
                                    forward = type.slice(-4) !== "last",
                                    ofType = what === "of-type";

                                return first === 1 && last === 0 ?

                                    // Shortcut for :nth-*(n)
                                    function(elem) {
                                        return !!elem.parentNode;
                                    } :

                                    function(elem, context, xml) {
                                        var cache, uniqueCache, outerCache, node, nodeIndex, start,
                                            dir = simple !== forward ? "nextSibling" : "previousSibling",
                                            parent = elem.parentNode,
                                            name = ofType && elem.nodeName.toLowerCase(),
                                            useCache = !xml && !ofType,
                                            diff = false;

                                        if (parent) {

                                            // :(first|last|only)-(child|of-type)
                                            if (simple) {
                                                while (dir) {
                                                    node = elem;
                                                    while ((node = node[dir])) {
                                                        if (ofType ?
                                                            node.nodeName.toLowerCase() === name :
                                                            node.nodeType === 1) {

                                                            return false;
                                                        }
                                                    }
                                                    // Reverse direction for :only-* (if we haven't yet done so)
                                                    start = dir = type === "only" && !start && "nextSibling";
                                                }
                                                return true;
                                            }

                                            start = [forward ? parent.firstChild : parent.lastChild];

                                            // non-xml :nth-child(...) stores cache data on `parent`
                                            if (forward && useCache) {

                                                // Seek `elem` from a previously-cached index

                                                // ...in a gzip-friendly way
                                                node = parent;
                                                outerCache = node[expando] || (node[expando] = {});

                                                // Support: IE <9 only
                                                // Defend against cloned attroperties (jQuery gh-1709)
                                                uniqueCache = outerCache[node.uniqueID] ||
                                                    (outerCache[node.uniqueID] = {});

                                                cache = uniqueCache[type] || [];
                                                nodeIndex = cache[0] === dirruns && cache[1];
                                                diff = nodeIndex && cache[2];
                                                node = nodeIndex && parent.childNodes[nodeIndex];

                                                while ((node = ++nodeIndex && node && node[dir] ||

                                                        // Fallback to seeking `elem` from the start
                                                        (diff = nodeIndex = 0) || start.pop())) {

                                                    // When found, cache indexes on `parent` and break
                                                    if (node.nodeType === 1 && ++diff && node === elem) {
                                                        uniqueCache[type] = [dirruns, nodeIndex, diff];
                                                        break;
                                                    }
                                                }

                                            } else {
                                                // Use previously-cached element index if available
                                                if (useCache) {
                                                    // ...in a gzip-friendly way
                                                    node = elem;
                                                    outerCache = node[expando] || (node[expando] = {});

                                                    // Support: IE <9 only
                                                    // Defend against cloned attroperties (jQuery gh-1709)
                                                    uniqueCache = outerCache[node.uniqueID] ||
                                                        (outerCache[node.uniqueID] = {});

                                                    cache = uniqueCache[type] || [];
                                                    nodeIndex = cache[0] === dirruns && cache[1];
                                                    diff = nodeIndex;
                                                }

                                                // xml :nth-child(...)
                                                // or :nth-last-child(...) or :nth(-last)?-of-type(...)
                                                if (diff === false) {
                                                    // Use the same loop as above to seek `elem` from the start
                                                    while ((node = ++nodeIndex && node && node[dir] ||
                                                            (diff = nodeIndex = 0) || start.pop())) {

                                                        if ((ofType ?
                                                                node.nodeName.toLowerCase() === name :
                                                                node.nodeType === 1) &&
                                                            ++diff) {

                                                            // Cache the index of each encountered element
                                                            if (useCache) {
                                                                outerCache = node[expando] || (node[expando] = {});

                                                                // Support: IE <9 only
                                                                // Defend against cloned attroperties (jQuery gh-1709)
                                                                uniqueCache = outerCache[node.uniqueID] ||
                                                                    (outerCache[node.uniqueID] = {});

                                                                uniqueCache[type] = [dirruns, diff];
                                                            }

                                                            if (node === elem) {
                                                                break;
                                                            }
                                                        }
                                                    }
                                                }
                                            }

                                            // Incorporate the offset, then check against cycle size
                                            diff -= last;
                                            return diff === first || (diff % first === 0 && diff / first >= 0);
                                        }
                                    };
                            },

                            "PSEUDO": function(pseudo, argument) {
                                // pseudo-class names are case-insensitive
                                // http://www.w3.org/TR/selectors/#pseudo-classes
                                // Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
                                // Remember that setFilters inherits from pseudos
                                var args,
                                    fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] ||
                                    Sizzle.error("unsupported pseudo: " + pseudo);

                                // The user may use createPseudo to indicate that
                                // arguments are needed to create the filter function
                                // just as Sizzle does
                                if (fn[expando]) {
                                    return fn(argument);
                                }

                                // But maintain support for old signatures
                                if (fn.length > 1) {
                                    args = [pseudo, pseudo, "", argument];
                                    return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ?
                                        markFunction(function(seed, matches) {
                                            var idx,
                                                matched = fn(seed, argument),
                                                i = matched.length;
                                            while (i--) {
                                                idx = indexOf(seed, matched[i]);
                                                seed[idx] = !(matches[idx] = matched[i]);
                                            }
                                        }) :
                                        function(elem) {
                                            return fn(elem, 0, args);
                                        };
                                }

                                return fn;
                            }
                        },

                        pseudos: {
                            // Potentially complex pseudos
                            "not": markFunction(function(selector) {
                                // Trim the selector passed to compile
                                // to avoid treating leading and trailing
                                // spaces as combinators
                                var input = [],
                                    results = [],
                                    matcher = compile(selector.replace(rtrim, "$1"));

                                return matcher[expando] ?
                                    markFunction(function(seed, matches, context, xml) {
                                        var elem,
                                            unmatched = matcher(seed, null, xml, []),
                                            i = seed.length;

                                        // Match elements unmatched by `matcher`
                                        while (i--) {
                                            if ((elem = unmatched[i])) {
                                                seed[i] = !(matches[i] = elem);
                                            }
                                        }
                                    }) :
                                    function(elem, context, xml) {
                                        input[0] = elem;
                                        matcher(input, null, xml, results);
                                        // Don't keep the element (issue #299)
                                        input[0] = null;
                                        return !results.pop();
                                    };
                            }),

                            "has": markFunction(function(selector) {
                                return function(elem) {
                                    return Sizzle(selector, elem).length > 0;
                                };
                            }),

                            "contains": markFunction(function(text) {
                                text = text.replace(runescape, funescape);
                                return function(elem) {
                                    return (elem.textContent || elem.innerText || getText(elem)).indexOf(text) > -1;
                                };
                            }),

                            // "Whether an element is represented by a :lang() selector
                            // is based solely on the element's language value
                            // being equal to the identifier C,
                            // or beginning with the identifier C immediately followed by "-".
                            // The matching of C against the element's language value is performed case-insensitively.
                            // The identifier C does not have to be a valid language name."
                            // http://www.w3.org/TR/selectors/#lang-pseudo
                            "lang": markFunction(function(lang) {
                                // lang value must be a valid identifier
                                if (!ridentifier.test(lang || "")) {
                                    Sizzle.error("unsupported lang: " + lang);
                                }
                                lang = lang.replace(runescape, funescape).toLowerCase();
                                return function(elem) {
                                    var elemLang;
                                    do {
                                        if ((elemLang = documentIsHTML ?
                                                elem.lang :
                                                elem.getAttribute("xml:lang") || elem.getAttribute("lang"))) {

                                            elemLang = elemLang.toLowerCase();
                                            return elemLang === lang || elemLang.indexOf(lang + "-") === 0;
                                        }
                                    } while ((elem = elem.parentNode) && elem.nodeType === 1);
                                    return false;
                                };
                            }),

                            // Miscellaneous
                            "target": function(elem) {
                                var hash = window.location && window.location.hash;
                                return hash && hash.slice(1) === elem.id;
                            },

                            "root": function(elem) {
                                return elem === docElem;
                            },

                            "focus": function(elem) {
                                return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
                            },

                            // Boolean properties
                            "enabled": createDisabledPseudo(false),
                            "disabled": createDisabledPseudo(true),

                            "checked": function(elem) {
                                // In CSS3, :checked should return both checked and selected elements
                                // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
                                var nodeName = elem.nodeName.toLowerCase();
                                return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
                            },

                            "selected": function(elem) {
                                // Accessing this property makes selected-by-default
                                // options in Safari work properly
                                if (elem.parentNode) {
                                    elem.parentNode.selectedIndex;
                                }

                                return elem.selected === true;
                            },

                            // Contents
                            "empty": function(elem) {
                                // http://www.w3.org/TR/selectors/#empty-pseudo
                                // :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
                                //   but not by others (comment: 8; processing instruction: 7; etc.)
                                // nodeType < 6 works because attributes (2) do not appear as children
                                for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
                                    if (elem.nodeType < 6) {
                                        return false;
                                    }
                                }
                                return true;
                            },

                            "parent": function(elem) {
                                return !Expr.pseudos["empty"](elem);
                            },

                            // Element/input types
                            "header": function(elem) {
                                return rheader.test(elem.nodeName);
                            },

                            "input": function(elem) {
                                return rinputs.test(elem.nodeName);
                            },

                            "button": function(elem) {
                                var name = elem.nodeName.toLowerCase();
                                return name === "input" && elem.type === "button" || name === "button";
                            },

                            "text": function(elem) {
                                var attr;
                                return elem.nodeName.toLowerCase() === "input" &&
                                    elem.type === "text" &&

                                    // Support: IE<8
                                    // New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
                                    ((attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text");
                            },

                            // Position-in-collection
                            "first": createPositionalPseudo(function() {
                                return [0];
                            }),

                            "last": createPositionalPseudo(function(matchIndexes, length) {
                                return [length - 1];
                            }),

                            "eq": createPositionalPseudo(function(matchIndexes, length, argument) {
                                return [argument < 0 ? argument + length : argument];
                            }),

                            "even": createPositionalPseudo(function(matchIndexes, length) {
                                var i = 0;
                                for (; i < length; i += 2) {
                                    matchIndexes.push(i);
                                }
                                return matchIndexes;
                            }),

                            "odd": createPositionalPseudo(function(matchIndexes, length) {
                                var i = 1;
                                for (; i < length; i += 2) {
                                    matchIndexes.push(i);
                                }
                                return matchIndexes;
                            }),

                            "lt": createPositionalPseudo(function(matchIndexes, length, argument) {
                                var i = argument < 0 ? argument + length : argument;
                                for (; --i >= 0;) {
                                    matchIndexes.push(i);
                                }
                                return matchIndexes;
                            }),

                            "gt": createPositionalPseudo(function(matchIndexes, length, argument) {
                                var i = argument < 0 ? argument + length : argument;
                                for (; ++i < length;) {
                                    matchIndexes.push(i);
                                }
                                return matchIndexes;
                            })
                        }
                    };

                    Expr.pseudos["nth"] = Expr.pseudos["eq"];

                    // Add button/input type pseudos
                    for (i in {
                            radio: true,
                            checkbox: true,
                            file: true,
                            password: true,
                            image: true
                        }) {
                        Expr.pseudos[i] = createInputPseudo(i);
                    }
                    for (i in {
                            submit: true,
                            reset: true
                        }) {
                        Expr.pseudos[i] = createButtonPseudo(i);
                    }

                    // Easy API for creating new setFilters
                    function setFilters() {}
                    setFilters.prototype = Expr.filters = Expr.pseudos;
                    Expr.setFilters = new setFilters();

                    tokenize = Sizzle.tokenize = function(selector, parseOnly) {
                        var matched, match, tokens, type,
                            soFar, groups, preFilters,
                            cached = tokenCache[selector + " "];

                        if (cached) {
                            return parseOnly ? 0 : cached.slice(0);
                        }

                        soFar = selector;
                        groups = [];
                        preFilters = Expr.preFilter;

                        while (soFar) {

                            // Comma and first run
                            if (!matched || (match = rcomma.exec(soFar))) {
                                if (match) {
                                    // Don't consume trailing commas as valid
                                    soFar = soFar.slice(match[0].length) || soFar;
                                }
                                groups.push((tokens = []));
                            }

                            matched = false;

                            // Combinators
                            if ((match = rcombinators.exec(soFar))) {
                                matched = match.shift();
                                tokens.push({
                                    value: matched,
                                    // Cast descendant combinators to space
                                    type: match[0].replace(rtrim, " ")
                                });
                                soFar = soFar.slice(matched.length);
                            }

                            // Filters
                            for (type in Expr.filter) {
                                if ((match = matchExpr[type].exec(soFar)) && (!preFilters[type] ||
                                        (match = preFilters[type](match)))) {
                                    matched = match.shift();
                                    tokens.push({
                                        value: matched,
                                        type: type,
                                        matches: match
                                    });
                                    soFar = soFar.slice(matched.length);
                                }
                            }

                            if (!matched) {
                                break;
                            }
                        }

                        // Return the length of the invalid excess
                        // if we're just parsing
                        // Otherwise, throw an error or return tokens
                        return parseOnly ?
                            soFar.length :
                            soFar ?
                            Sizzle.error(selector) :
                            // Cache the tokens
                            tokenCache(selector, groups).slice(0);
                    };

                    function toSelector(tokens) {
                        var i = 0,
                            len = tokens.length,
                            selector = "";
                        for (; i < len; i++) {
                            selector += tokens[i].value;
                        }
                        return selector;
                    }

                    function addCombinator(matcher, combinator, base) {
                        var dir = combinator.dir,
                            skip = combinator.next,
                            key = skip || dir,
                            checkNonElements = base && key === "parentNode",
                            doneName = done++;

                        return combinator.first ?
                            // Check against closest ancestor/preceding element
                            function(elem, context, xml) {
                                while ((elem = elem[dir])) {
                                    if (elem.nodeType === 1 || checkNonElements) {
                                        return matcher(elem, context, xml);
                                    }
                                }
                                return false;
                            } :

                            // Check against all ancestor/preceding elements
                            function(elem, context, xml) {
                                var oldCache, uniqueCache, outerCache,
                                    newCache = [dirruns, doneName];

                                // We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
                                if (xml) {
                                    while ((elem = elem[dir])) {
                                        if (elem.nodeType === 1 || checkNonElements) {
                                            if (matcher(elem, context, xml)) {
                                                return true;
                                            }
                                        }
                                    }
                                } else {
                                    while ((elem = elem[dir])) {
                                        if (elem.nodeType === 1 || checkNonElements) {
                                            outerCache = elem[expando] || (elem[expando] = {});

                                            // Support: IE <9 only
                                            // Defend against cloned attroperties (jQuery gh-1709)
                                            uniqueCache = outerCache[elem.uniqueID] || (outerCache[elem.uniqueID] = {});

                                            if (skip && skip === elem.nodeName.toLowerCase()) {
                                                elem = elem[dir] || elem;
                                            } else if ((oldCache = uniqueCache[key]) &&
                                                oldCache[0] === dirruns && oldCache[1] === doneName) {

                                                // Assign to newCache so results back-propagate to previous elements
                                                return (newCache[2] = oldCache[2]);
                                            } else {
                                                // Reuse newcache so results back-propagate to previous elements
                                                uniqueCache[key] = newCache;

                                                // A match means we're done; a fail means we have to keep checking
                                                if ((newCache[2] = matcher(elem, context, xml))) {
                                                    return true;
                                                }
                                            }
                                        }
                                    }
                                }
                                return false;
                            };
                    }

                    function elementMatcher(matchers) {
                        return matchers.length > 1 ?
                            function(elem, context, xml) {
                                var i = matchers.length;
                                while (i--) {
                                    if (!matchers[i](elem, context, xml)) {
                                        return false;
                                    }
                                }
                                return true;
                            } :
                            matchers[0];
                    }

                    function multipleContexts(selector, contexts, results) {
                        var i = 0,
                            len = contexts.length;
                        for (; i < len; i++) {
                            Sizzle(selector, contexts[i], results);
                        }
                        return results;
                    }

                    function condense(unmatched, map, filter, context, xml) {
                        var elem,
                            newUnmatched = [],
                            i = 0,
                            len = unmatched.length,
                            mapped = map != null;

                        for (; i < len; i++) {
                            if ((elem = unmatched[i])) {
                                if (!filter || filter(elem, context, xml)) {
                                    newUnmatched.push(elem);
                                    if (mapped) {
                                        map.push(i);
                                    }
                                }
                            }
                        }

                        return newUnmatched;
                    }

                    function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
                        if (postFilter && !postFilter[expando]) {
                            postFilter = setMatcher(postFilter);
                        }
                        if (postFinder && !postFinder[expando]) {
                            postFinder = setMatcher(postFinder, postSelector);
                        }
                        return markFunction(function(seed, results, context, xml) {
                            var temp, i, elem,
                                preMap = [],
                                postMap = [],
                                preexisting = results.length,

                                // Get initial elements from seed or context
                                elems = seed || multipleContexts(selector || "*", context.nodeType ? [context] : context, []),

                                // Prefilter to get matcher input, preserving a map for seed-results synchronization
                                matcherIn = preFilter && (seed || !selector) ?
                                condense(elems, preMap, preFilter, context, xml) :
                                elems,

                                matcherOut = matcher ?
                                // If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
                                postFinder || (seed ? preFilter : preexisting || postFilter) ?

                                // ...intermediate processing is necessary
                                [] :

                                // ...otherwise use results directly
                                results :
                                matcherIn;

                            // Find primary matches
                            if (matcher) {
                                matcher(matcherIn, matcherOut, context, xml);
                            }

                            // Apply postFilter
                            if (postFilter) {
                                temp = condense(matcherOut, postMap);
                                postFilter(temp, [], context, xml);

                                // Un-match failing elements by moving them back to matcherIn
                                i = temp.length;
                                while (i--) {
                                    if ((elem = temp[i])) {
                                        matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem);
                                    }
                                }
                            }

                            if (seed) {
                                if (postFinder || preFilter) {
                                    if (postFinder) {
                                        // Get the final matcherOut by condensing this intermediate into postFinder contexts
                                        temp = [];
                                        i = matcherOut.length;
                                        while (i--) {
                                            if ((elem = matcherOut[i])) {
                                                // Restore matcherIn since elem is not yet a final match
                                                temp.push((matcherIn[i] = elem));
                                            }
                                        }
                                        postFinder(null, (matcherOut = []), temp, xml);
                                    }

                                    // Move matched elements from seed to results to keep them synchronized
                                    i = matcherOut.length;
                                    while (i--) {
                                        if ((elem = matcherOut[i]) &&
                                            (temp = postFinder ? indexOf(seed, elem) : preMap[i]) > -1) {

                                            seed[temp] = !(results[temp] = elem);
                                        }
                                    }
                                }

                                // Add elements to results, through postFinder if defined
                            } else {
                                matcherOut = condense(
                                    matcherOut === results ?
                                    matcherOut.splice(preexisting, matcherOut.length) :
                                    matcherOut
                                );
                                if (postFinder) {
                                    postFinder(null, results, matcherOut, xml);
                                } else {
                                    push.apply(results, matcherOut);
                                }
                            }
                        });
                    }

                    function matcherFromTokens(tokens) {
                        var checkContext, matcher, j,
                            len = tokens.length,
                            leadingRelative = Expr.relative[tokens[0].type],
                            implicitRelative = leadingRelative || Expr.relative[" "],
                            i = leadingRelative ? 1 : 0,

                            // The foundational matcher ensures that elements are reachable from top-level context(s)
                            matchContext = addCombinator(function(elem) {
                                return elem === checkContext;
                            }, implicitRelative, true),
                            matchAnyContext = addCombinator(function(elem) {
                                return indexOf(checkContext, elem) > -1;
                            }, implicitRelative, true),
                            matchers = [function(elem, context, xml) {
                                var ret = (!leadingRelative && (xml || context !== outermostContext)) || (
                                    (checkContext = context).nodeType ?
                                    matchContext(elem, context, xml) :
                                    matchAnyContext(elem, context, xml));
                                // Avoid hanging onto element (issue #299)
                                checkContext = null;
                                return ret;
                            }];

                        for (; i < len; i++) {
                            if ((matcher = Expr.relative[tokens[i].type])) {
                                matchers = [addCombinator(elementMatcher(matchers), matcher)];
                            } else {
                                matcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches);

                                // Return special upon seeing a positional matcher
                                if (matcher[expando]) {
                                    // Find the next relative operator (if any) for proper handling
                                    j = ++i;
                                    for (; j < len; j++) {
                                        if (Expr.relative[tokens[j].type]) {
                                            break;
                                        }
                                    }
                                    return setMatcher(
                                        i > 1 && elementMatcher(matchers),
                                        i > 1 && toSelector(
                                            // If the preceding token was a descendant combinator, insert an implicit any-element `*`
                                            tokens.slice(0, i - 1).concat({
                                                value: tokens[i - 2].type === " " ? "*" : ""
                                            })
                                        ).replace(rtrim, "$1"),
                                        matcher,
                                        i < j && matcherFromTokens(tokens.slice(i, j)),
                                        j < len && matcherFromTokens((tokens = tokens.slice(j))),
                                        j < len && toSelector(tokens)
                                    );
                                }
                                matchers.push(matcher);
                            }
                        }

                        return elementMatcher(matchers);
                    }

                    function matcherFromGroupMatchers(elementMatchers, setMatchers) {
                        var bySet = setMatchers.length > 0,
                            byElement = elementMatchers.length > 0,
                            superMatcher = function(seed, context, xml, results, outermost) {
                                var elem, j, matcher,
                                    matchedCount = 0,
                                    i = "0",
                                    unmatched = seed && [],
                                    setMatched = [],
                                    contextBackup = outermostContext,
                                    // We must always have either seed elements or outermost context
                                    elems = seed || byElement && Expr.find["TAG"]("*", outermost),
                                    // Use integer dirruns iff this is the outermost matcher
                                    dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
                                    len = elems.length;

                                if (outermost) {
                                    outermostContext = context === document || context || outermost;
                                }

                                // Add elements passing elementMatchers directly to results
                                // Support: IE<9, Safari
                                // Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
                                for (; i !== len && (elem = elems[i]) != null; i++) {
                                    if (byElement && elem) {
                                        j = 0;
                                        if (!context && elem.ownerDocument !== document) {
                                            setDocument(elem);
                                            xml = !documentIsHTML;
                                        }
                                        while ((matcher = elementMatchers[j++])) {
                                            if (matcher(elem, context || document, xml)) {
                                                results.push(elem);
                                                break;
                                            }
                                        }
                                        if (outermost) {
                                            dirruns = dirrunsUnique;
                                        }
                                    }

                                    // Track unmatched elements for set filters
                                    if (bySet) {
                                        // They will have gone through all possible matchers
                                        if ((elem = !matcher && elem)) {
                                            matchedCount--;
                                        }

                                        // Lengthen the array for every element, matched or not
                                        if (seed) {
                                            unmatched.push(elem);
                                        }
                                    }
                                }

                                // `i` is now the count of elements visited above, and adding it to `matchedCount`
                                // makes the latter nonnegative.
                                matchedCount += i;

                                // Apply set filters to unmatched elements
                                // NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
                                // equals `i`), unless we didn't visit _any_ elements in the above loop because we have
                                // no element matchers and no seed.
                                // Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
                                // case, which will result in a "00" `matchedCount` that differs from `i` but is also
                                // numerically zero.
                                if (bySet && i !== matchedCount) {
                                    j = 0;
                                    while ((matcher = setMatchers[j++])) {
                                        matcher(unmatched, setMatched, context, xml);
                                    }

                                    if (seed) {
                                        // Reintegrate element matches to eliminate the need for sorting
                                        if (matchedCount > 0) {
                                            while (i--) {
                                                if (!(unmatched[i] || setMatched[i])) {
                                                    setMatched[i] = pop.call(results);
                                                }
                                            }
                                        }

                                        // Discard index placeholder values to get only actual matches
                                        setMatched = condense(setMatched);
                                    }

                                    // Add matches to results
                                    push.apply(results, setMatched);

                                    // Seedless set matches succeeding multiple successful matchers stipulate sorting
                                    if (outermost && !seed && setMatched.length > 0 &&
                                        (matchedCount + setMatchers.length) > 1) {

                                        Sizzle.uniqueSort(results);
                                    }
                                }

                                // Override manipulation of globals by nested matchers
                                if (outermost) {
                                    dirruns = dirrunsUnique;
                                    outermostContext = contextBackup;
                                }

                                return unmatched;
                            };

                        return bySet ?
                            markFunction(superMatcher) :
                            superMatcher;
                    }

                    compile = Sizzle.compile = function(selector, match /* Internal Use Only */ ) {
                        var i,
                            setMatchers = [],
                            elementMatchers = [],
                            cached = compilerCache[selector + " "];

                        if (!cached) {
                            // Generate a function of recursive functions that can be used to check each element
                            if (!match) {
                                match = tokenize(selector);
                            }
                            i = match.length;
                            while (i--) {
                                cached = matcherFromTokens(match[i]);
                                if (cached[expando]) {
                                    setMatchers.push(cached);
                                } else {
                                    elementMatchers.push(cached);
                                }
                            }

                            // Cache the compiled function
                            cached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers));

                            // Save selector and tokenization
                            cached.selector = selector;
                        }
                        return cached;
                    };

                    /**
                     * A low-level selection function that works with Sizzle's compiled
                     *  selector functions
                     * @param {String|Function} selector A selector or a pre-compiled
                     *  selector function built with Sizzle.compile
                     * @param {Element} context
                     * @param {Array} [results]
                     * @param {Array} [seed] A set of elements to match against
                     */
                    select = Sizzle.select = function(selector, context, results, seed) {
                        var i, tokens, token, type, find,
                            compiled = typeof selector === "function" && selector,
                            match = !seed && tokenize((selector = compiled.selector || selector));

                        results = results || [];

                        // Try to minimize operations if there is only one selector in the list and no seed
                        // (the latter of which guarantees us context)
                        if (match.length === 1) {

                            // Reduce context if the leading compound selector is an ID
                            tokens = match[0] = match[0].slice(0);
                            if (tokens.length > 2 && (token = tokens[0]).type === "ID" &&
                                context.nodeType === 9 && documentIsHTML && Expr.relative[tokens[1].type]) {

                                context = (Expr.find["ID"](token.matches[0].replace(runescape, funescape), context) || [])[0];
                                if (!context) {
                                    return results;

                                    // Precompiled matchers will still verify ancestry, so step up a level
                                } else if (compiled) {
                                    context = context.parentNode;
                                }

                                selector = selector.slice(tokens.shift().value.length);
                            }

                            // Fetch a seed set for right-to-left matching
                            i = matchExpr["needsContext"].test(selector) ? 0 : tokens.length;
                            while (i--) {
                                token = tokens[i];

                                // Abort if we hit a combinator
                                if (Expr.relative[(type = token.type)]) {
                                    break;
                                }
                                if ((find = Expr.find[type])) {
                                    // Search, expanding context for leading sibling combinators
                                    if ((seed = find(
                                            token.matches[0].replace(runescape, funescape),
                                            rsibling.test(tokens[0].type) && testContext(context.parentNode) || context
                                        ))) {

                                        // If seed is empty or no tokens remain, we can return early
                                        tokens.splice(i, 1);
                                        selector = seed.length && toSelector(tokens);
                                        if (!selector) {
                                            push.apply(results, seed);
                                            return results;
                                        }

                                        break;
                                    }
                                }
                            }
                        }

                        // Compile and execute a filtering function if one is not provided
                        // Provide `match` to avoid retokenization if we modified the selector above
                        (compiled || compile(selector, match))(
                            seed,
                            context, !documentIsHTML,
                            results, !context || rsibling.test(selector) && testContext(context.parentNode) || context
                        );
                        return results;
                    };

                    // One-time assignments

                    // Sort stability
                    support.sortStable = expando.split("").sort(sortOrder).join("") === expando;

                    // Support: Chrome 14-35+
                    // Always assume duplicates if they aren't passed to the comparison function
                    support.detectDuplicates = !!hasDuplicate;

                    // Initialize against the default document
                    setDocument();

                    // Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
                    // Detached nodes confoundingly follow *each other*
                    support.sortDetached = assert(function(el) {
                        // Should return 1, but returns 4 (following)
                        return el.compareDocumentPosition(document.createElement("fieldset")) & 1;
                    });

                    // Support: IE<8
                    // Prevent attribute/property "interpolation"
                    // https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
                    if (!assert(function(el) {
                            el.innerHTML = "<a href='#'></a>";
                            return el.firstChild.getAttribute("href") === "#";
                        })) {
                        addHandle("type|href|height|width", function(elem, name, isXML) {
                            if (!isXML) {
                                return elem.getAttribute(name, name.toLowerCase() === "type" ? 1 : 2);
                            }
                        });
                    }

                    // Support: IE<9
                    // Use defaultValue in place of getAttribute("value")
                    if (!support.attributes || !assert(function(el) {
                            el.innerHTML = "<input/>";
                            el.firstChild.setAttribute("value", "");
                            return el.firstChild.getAttribute("value") === "";
                        })) {
                        addHandle("value", function(elem, name, isXML) {
                            if (!isXML && elem.nodeName.toLowerCase() === "input") {
                                return elem.defaultValue;
                            }
                        });
                    }

                    // Support: IE<9
                    // Use getAttributeNode to fetch booleans when getAttribute lies
                    if (!assert(function(el) {
                            return el.getAttribute("disabled") == null;
                        })) {
                        addHandle(booleans, function(elem, name, isXML) {
                            var val;
                            if (!isXML) {
                                return elem[name] === true ? name.toLowerCase() :
                                    (val = elem.getAttributeNode(name)) && val.specified ?
                                    val.value :
                                    null;
                            }
                        });
                    }

                    return Sizzle;

                })(window);



            jQuery.find = Sizzle;
            jQuery.expr = Sizzle.selectors;

            // Deprecated
            jQuery.expr[":"] = jQuery.expr.pseudos;
            jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
            jQuery.text = Sizzle.getText;
            jQuery.isXMLDoc = Sizzle.isXML;
            jQuery.contains = Sizzle.contains;
            jQuery.escapeSelector = Sizzle.escape;




            var dir = function(elem, dir, until) {
                var matched = [],
                    truncate = until !== undefined;

                while ((elem = elem[dir]) && elem.nodeType !== 9) {
                    if (elem.nodeType === 1) {
                        if (truncate && jQuery(elem).is(until)) {
                            break;
                        }
                        matched.push(elem);
                    }
                }
                return matched;
            };


            var siblings = function(n, elem) {
                var matched = [];

                for (; n; n = n.nextSibling) {
                    if (n.nodeType === 1 && n !== elem) {
                        matched.push(n);
                    }
                }

                return matched;
            };


            var rneedsContext = jQuery.expr.match.needsContext;



            function nodeName(elem, name) {

                return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();

            };
            var rsingleTag = (/^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i);



            var risSimple = /^.[^:#\[\.,]*$/;

            // Implement the identical functionality for filter and not
            function winnow(elements, qualifier, not) {
                if (jQuery.isFunction(qualifier)) {
                    return jQuery.grep(elements, function(elem, i) {
                        return !!qualifier.call(elem, i, elem) !== not;
                    });
                }

                // Single element
                if (qualifier.nodeType) {
                    return jQuery.grep(elements, function(elem) {
                        return (elem === qualifier) !== not;
                    });
                }

                // Arraylike of elements (jQuery, arguments, Array)
                if (typeof qualifier !== "string") {
                    return jQuery.grep(elements, function(elem) {
                        return (indexOf.call(qualifier, elem) > -1) !== not;
                    });
                }

                // Simple selector that can be filtered directly, removing non-Elements
                if (risSimple.test(qualifier)) {
                    return jQuery.filter(qualifier, elements, not);
                }

                // Complex selector, compare the two sets, removing non-Elements
                qualifier = jQuery.filter(qualifier, elements);
                return jQuery.grep(elements, function(elem) {
                    return (indexOf.call(qualifier, elem) > -1) !== not && elem.nodeType === 1;
                });
            }

            jQuery.filter = function(expr, elems, not) {
                var elem = elems[0];

                if (not) {
                    expr = ":not(" + expr + ")";
                }

                if (elems.length === 1 && elem.nodeType === 1) {
                    return jQuery.find.matchesSelector(elem, expr) ? [elem] : [];
                }

                return jQuery.find.matches(expr, jQuery.grep(elems, function(elem) {
                    return elem.nodeType === 1;
                }));
            };

            jQuery.fn.extend({
                find: function(selector) {
                    var i, ret,
                        len = this.length,
                        self = this;

                    if (typeof selector !== "string") {
                        return this.pushStack(jQuery(selector).filter(function() {
                            for (i = 0; i < len; i++) {
                                if (jQuery.contains(self[i], this)) {
                                    return true;
                                }
                            }
                        }));
                    }

                    ret = this.pushStack([]);

                    for (i = 0; i < len; i++) {
                        jQuery.find(selector, self[i], ret);
                    }

                    return len > 1 ? jQuery.uniqueSort(ret) : ret;
                },
                filter: function(selector) {
                    return this.pushStack(winnow(this, selector || [], false));
                },
                not: function(selector) {
                    return this.pushStack(winnow(this, selector || [], true));
                },
                is: function(selector) {
                    return !!winnow(
                        this,

                        // If this is a positional/relative selector, check membership in the returned set
                        // so $("p:first").is("p:last") won't return true for a doc with two "p".
                        typeof selector === "string" && rneedsContext.test(selector) ?
                        jQuery(selector) :
                        selector || [],
                        false
                    ).length;
                }
            });


            // Initialize a jQuery object


            // A central reference to the root jQuery(document)
            var rootjQuery,

                // A simple way to check for HTML strings
                // Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
                // Strict HTML recognition (#11290: must start with <)
                // Shortcut simple #id case for speed
                rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,

                init = jQuery.fn.init = function(selector, context, root) {
                    var match, elem;

                    // HANDLE: $(""), $(null), $(undefined), $(false)
                    if (!selector) {
                        return this;
                    }

                    // Method init() accepts an alternate rootjQuery
                    // so migrate can support jQuery.sub (gh-2101)
                    root = root || rootjQuery;

                    // Handle HTML strings
                    if (typeof selector === "string") {
                        if (selector[0] === "<" &&
                            selector[selector.length - 1] === ">" &&
                            selector.length >= 3) {

                            // Assume that strings that start and end with <> are HTML and skip the regex check
                            match = [null, selector, null];

                        } else {
                            match = rquickExpr.exec(selector);
                        }

                        // Match html or make sure no context is specified for #id
                        if (match && (match[1] || !context)) {

                            // HANDLE: $(html) -> $(array)
                            if (match[1]) {
                                context = context instanceof jQuery ? context[0] : context;

                                // Option to run scripts is true for back-compat
                                // Intentionally let the error be thrown if parseHTML is not present
                                jQuery.merge(this, jQuery.parseHTML(
                                    match[1],
                                    context && context.nodeType ? context.ownerDocument || context : document,
                                    true
                                ));

                                // HANDLE: $(html, props)
                                if (rsingleTag.test(match[1]) && jQuery.isPlainObject(context)) {
                                    for (match in context) {

                                        // Properties of context are called as methods if possible
                                        if (jQuery.isFunction(this[match])) {
                                            this[match](context[match]);

                                            // ...and otherwise set as attributes
                                        } else {
                                            this.attr(match, context[match]);
                                        }
                                    }
                                }

                                return this;

                                // HANDLE: $(#id)
                            } else {
                                elem = document.getElementById(match[2]);

                                if (elem) {

                                    // Inject the element directly into the jQuery object
                                    this[0] = elem;
                                    this.length = 1;
                                }
                                return this;
                            }

                            // HANDLE: $(expr, $(...))
                        } else if (!context || context.jquery) {
                            return (context || root).find(selector);

                            // HANDLE: $(expr, context)
                            // (which is just equivalent to: $(context).find(expr)
                        } else {
                            return this.constructor(context).find(selector);
                        }

                        // HANDLE: $(DOMElement)
                    } else if (selector.nodeType) {
                        this[0] = selector;
                        this.length = 1;
                        return this;

                        // HANDLE: $(function)
                        // Shortcut for document ready
                    } else if (jQuery.isFunction(selector)) {
                        return root.ready !== undefined ?
                            root.ready(selector) :

                            // Execute immediately if ready is not present
                            selector(jQuery);
                    }

                    return jQuery.makeArray(selector, this);
                };

            // Give the init function the jQuery prototype for later instantiation
            init.prototype = jQuery.fn;

            // Initialize central reference
            rootjQuery = jQuery(document);


            var rparentsprev = /^(?:parents|prev(?:Until|All))/,

                // Methods guaranteed to produce a unique set when starting from a unique set
                guaranteedUnique = {
                    children: true,
                    contents: true,
                    next: true,
                    prev: true
                };

            jQuery.fn.extend({
                has: function(target) {
                    var targets = jQuery(target, this),
                        l = targets.length;

                    return this.filter(function() {
                        var i = 0;
                        for (; i < l; i++) {
                            if (jQuery.contains(this, targets[i])) {
                                return true;
                            }
                        }
                    });
                },

                closest: function(selectors, context) {
                    var cur,
                        i = 0,
                        l = this.length,
                        matched = [],
                        targets = typeof selectors !== "string" && jQuery(selectors);

                    // Positional selectors never match, since there's no _selection_ context
                    if (!rneedsContext.test(selectors)) {
                        for (; i < l; i++) {
                            for (cur = this[i]; cur && cur !== context; cur = cur.parentNode) {

                                // Always skip document fragments
                                if (cur.nodeType < 11 && (targets ?
                                        targets.index(cur) > -1 :

                                        // Don't pass non-elements to Sizzle
                                        cur.nodeType === 1 &&
                                        jQuery.find.matchesSelector(cur, selectors))) {

                                    matched.push(cur);
                                    break;
                                }
                            }
                        }
                    }

                    return this.pushStack(matched.length > 1 ? jQuery.uniqueSort(matched) : matched);
                },

                // Determine the position of an element within the set
                index: function(elem) {

                    // No argument, return index in parent
                    if (!elem) {
                        return (this[0] && this[0].parentNode) ? this.first().prevAll().length : -1;
                    }

                    // Index in selector
                    if (typeof elem === "string") {
                        return indexOf.call(jQuery(elem), this[0]);
                    }

                    // Locate the position of the desired element
                    return indexOf.call(this,

                        // If it receives a jQuery object, the first element is used
                        elem.jquery ? elem[0] : elem
                    );
                },

                add: function(selector, context) {
                    return this.pushStack(
                        jQuery.uniqueSort(
                            jQuery.merge(this.get(), jQuery(selector, context))
                        )
                    );
                },

                addBack: function(selector) {
                    return this.add(selector == null ?
                        this.prevObject : this.prevObject.filter(selector)
                    );
                }
            });

            function sibling(cur, dir) {
                while ((cur = cur[dir]) && cur.nodeType !== 1) {}
                return cur;
            }

            jQuery.each({
                parent: function(elem) {
                    var parent = elem.parentNode;
                    return parent && parent.nodeType !== 11 ? parent : null;
                },
                parents: function(elem) {
                    return dir(elem, "parentNode");
                },
                parentsUntil: function(elem, i, until) {
                    return dir(elem, "parentNode", until);
                },
                next: function(elem) {
                    return sibling(elem, "nextSibling");
                },
                prev: function(elem) {
                    return sibling(elem, "previousSibling");
                },
                nextAll: function(elem) {
                    return dir(elem, "nextSibling");
                },
                prevAll: function(elem) {
                    return dir(elem, "previousSibling");
                },
                nextUntil: function(elem, i, until) {
                    return dir(elem, "nextSibling", until);
                },
                prevUntil: function(elem, i, until) {
                    return dir(elem, "previousSibling", until);
                },
                siblings: function(elem) {
                    return siblings((elem.parentNode || {}).firstChild, elem);
                },
                children: function(elem) {
                    return siblings(elem.firstChild);
                },
                contents: function(elem) {
                    if (nodeName(elem, "iframe")) {
                        return elem.contentDocument;
                    }

                    // Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only
                    // Treat the template element as a regular one in browsers that
                    // don't support it.
                    if (nodeName(elem, "template")) {
                        elem = elem.content || elem;
                    }

                    return jQuery.merge([], elem.childNodes);
                }
            }, function(name, fn) {
                jQuery.fn[name] = function(until, selector) {
                    var matched = jQuery.map(this, fn, until);

                    if (name.slice(-5) !== "Until") {
                        selector = until;
                    }

                    if (selector && typeof selector === "string") {
                        matched = jQuery.filter(selector, matched);
                    }

                    if (this.length > 1) {

                        // Remove duplicates
                        if (!guaranteedUnique[name]) {
                            jQuery.uniqueSort(matched);
                        }

                        // Reverse order for parents* and prev-derivatives
                        if (rparentsprev.test(name)) {
                            matched.reverse();
                        }
                    }

                    return this.pushStack(matched);
                };
            });
            var rnothtmlwhite = (/[^\x20\t\r\n\f]+/g);



            // Convert String-formatted options into Object-formatted ones
            function createOptions(options) {
                var object = {};
                jQuery.each(options.match(rnothtmlwhite) || [], function(_, flag) {
                    object[flag] = true;
                });
                return object;
            }

            /*
             * Create a callback list using the following parameters:
             *
             *	options: an optional list of space-separated options that will change how
             *			the callback list behaves or a more traditional option object
             *
             * By default a callback list will act like an event callback list and can be
             * "fired" multiple times.
             *
             * Possible options:
             *
             *	once:			will ensure the callback list can only be fired once (like a Deferred)
             *
             *	memory:			will keep track of previous values and will call any callback added
             *					after the list has been fired right away with the latest "memorized"
             *					values (like a Deferred)
             *
             *	unique:			will ensure a callback can only be added once (no duplicate in the list)
             *
             *	stopOnFalse:	interrupt callings when a callback returns false
             *
             */
            jQuery.Callbacks = function(options) {

                // Convert options from String-formatted to Object-formatted if needed
                // (we check in cache first)
                options = typeof options === "string" ?
                    createOptions(options) :
                    jQuery.extend({}, options);

                var // Flag to know if list is currently firing
                    firing,

                    // Last fire value for non-forgettable lists
                    memory,

                    // Flag to know if list was already fired
                    fired,

                    // Flag to prevent firing
                    locked,

                    // Actual callback list
                    list = [],

                    // Queue of execution data for repeatable lists
                    queue = [],

                    // Index of currently firing callback (modified by add/remove as needed)
                    firingIndex = -1,

                    // Fire callbacks
                    fire = function() {

                        // Enforce single-firing
                        locked = locked || options.once;

                        // Execute callbacks for all pending executions,
                        // respecting firingIndex overrides and runtime changes
                        fired = firing = true;
                        for (; queue.length; firingIndex = -1) {
                            memory = queue.shift();
                            while (++firingIndex < list.length) {

                                // Run callback and check for early termination
                                if (list[firingIndex].apply(memory[0], memory[1]) === false &&
                                    options.stopOnFalse) {

                                    // Jump to end and forget the data so .add doesn't re-fire
                                    firingIndex = list.length;
                                    memory = false;
                                }
                            }
                        }

                        // Forget the data if we're done with it
                        if (!options.memory) {
                            memory = false;
                        }

                        firing = false;

                        // Clean up if we're done firing for good
                        if (locked) {

                            // Keep an empty list if we have data for future add calls
                            if (memory) {
                                list = [];

                                // Otherwise, this object is spent
                            } else {
                                list = "";
                            }
                        }
                    },

                    // Actual Callbacks object
                    self = {

                        // Add a callback or a collection of callbacks to the list
                        add: function() {
                            if (list) {

                                // If we have memory from a past run, we should fire after adding
                                if (memory && !firing) {
                                    firingIndex = list.length - 1;
                                    queue.push(memory);
                                }

                                (function add(args) {
                                    jQuery.each(args, function(_, arg) {
                                        if (jQuery.isFunction(arg)) {
                                            if (!options.unique || !self.has(arg)) {
                                                list.push(arg);
                                            }
                                        } else if (arg && arg.length && jQuery.type(arg) !== "string") {

                                            // Inspect recursively
                                            add(arg);
                                        }
                                    });
                                })(arguments);

                                if (memory && !firing) {
                                    fire();
                                }
                            }
                            return this;
                        },

                        // Remove a callback from the list
                        remove: function() {
                            jQuery.each(arguments, function(_, arg) {
                                var index;
                                while ((index = jQuery.inArray(arg, list, index)) > -1) {
                                    list.splice(index, 1);

                                    // Handle firing indexes
                                    if (index <= firingIndex) {
                                        firingIndex--;
                                    }
                                }
                            });
                            return this;
                        },

                        // Check if a given callback is in the list.
                        // If no argument is given, return whether or not list has callbacks attached.
                        has: function(fn) {
                            return fn ?
                                jQuery.inArray(fn, list) > -1 :
                                list.length > 0;
                        },

                        // Remove all callbacks from the list
                        empty: function() {
                            if (list) {
                                list = [];
                            }
                            return this;
                        },

                        // Disable .fire and .add
                        // Abort any current/pending executions
                        // Clear all callbacks and values
                        disable: function() {
                            locked = queue = [];
                            list = memory = "";
                            return this;
                        },
                        disabled: function() {
                            return !list;
                        },

                        // Disable .fire
                        // Also disable .add unless we have memory (since it would have no effect)
                        // Abort any pending executions
                        lock: function() {
                            locked = queue = [];
                            if (!memory && !firing) {
                                list = memory = "";
                            }
                            return this;
                        },
                        locked: function() {
                            return !!locked;
                        },

                        // Call all callbacks with the given context and arguments
                        fireWith: function(context, args) {
                            if (!locked) {
                                args = args || [];
                                args = [context, args.slice ? args.slice() : args];
                                queue.push(args);
                                if (!firing) {
                                    fire();
                                }
                            }
                            return this;
                        },

                        // Call all the callbacks with the given arguments
                        fire: function() {
                            self.fireWith(this, arguments);
                            return this;
                        },

                        // To know if the callbacks have already been called at least once
                        fired: function() {
                            return !!fired;
                        }
                    };

                return self;
            };


            function Identity(v) {
                return v;
            }

            function Thrower(ex) {
                throw ex;
            }

            function adoptValue(value, resolve, reject, noValue) {
                var method;

                try {

                    // Check for promise aspect first to privilege synchronous behavior
                    if (value && jQuery.isFunction((method = value.promise))) {
                        method.call(value).done(resolve).fail(reject);

                        // Other thenables
                    } else if (value && jQuery.isFunction((method = value.then))) {
                        method.call(value, resolve, reject);

                        // Other non-thenables
                    } else {

                        // Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:
                        // * false: [ value ].slice( 0 ) => resolve( value )
                        // * true: [ value ].slice( 1 ) => resolve()
                        resolve.apply(undefined, [value].slice(noValue));
                    }

                    // For Promises/A+, convert exceptions into rejections
                    // Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in
                    // Deferred#then to conditionally suppress rejection.
                } catch (value) {

                    // Support: Android 4.0 only
                    // Strict mode functions invoked without .call/.apply get global-object context
                    reject.apply(undefined, [value]);
                }
            }

            jQuery.extend({

                Deferred: function(func) {
                    var tuples = [

                            // action, add listener, callbacks,
                            // ... .then handlers, argument index, [final state]
                            ["notify", "progress", jQuery.Callbacks("memory"),
                                jQuery.Callbacks("memory"), 2
                            ],
                            ["resolve", "done", jQuery.Callbacks("once memory"),
                                jQuery.Callbacks("once memory"), 0, "resolved"
                            ],
                            ["reject", "fail", jQuery.Callbacks("once memory"),
                                jQuery.Callbacks("once memory"), 1, "rejected"
                            ]
                        ],
                        state = "pending",
                        promise = {
                            state: function() {
                                return state;
                            },
                            always: function() {
                                deferred.done(arguments).fail(arguments);
                                return this;
                            },
                            "catch": function(fn) {
                                return promise.then(null, fn);
                            },

                            // Keep pipe for back-compat
                            pipe: function( /* fnDone, fnFail, fnProgress */ ) {
                                var fns = arguments;

                                return jQuery.Deferred(function(newDefer) {
                                    jQuery.each(tuples, function(i, tuple) {

                                        // Map tuples (progress, done, fail) to arguments (done, fail, progress)
                                        var fn = jQuery.isFunction(fns[tuple[4]]) && fns[tuple[4]];

                                        // deferred.progress(function() { bind to newDefer or newDefer.notify })
                                        // deferred.done(function() { bind to newDefer or newDefer.resolve })
                                        // deferred.fail(function() { bind to newDefer or newDefer.reject })
                                        deferred[tuple[1]](function() {
                                            var returned = fn && fn.apply(this, arguments);
                                            if (returned && jQuery.isFunction(returned.promise)) {
                                                returned.promise()
                                                    .progress(newDefer.notify)
                                                    .done(newDefer.resolve)
                                                    .fail(newDefer.reject);
                                            } else {
                                                newDefer[tuple[0] + "With"](
                                                    this,
                                                    fn ? [returned] : arguments
                                                );
                                            }
                                        });
                                    });
                                    fns = null;
                                }).promise();
                            },
                            then: function(onFulfilled, onRejected, onProgress) {
                                var maxDepth = 0;

                                function resolve(depth, deferred, handler, special) {
                                    return function() {
                                        var that = this,
                                            args = arguments,
                                            mightThrow = function() {
                                                var returned, then;

                                                // Support: Promises/A+ section 2.3.3.3.3
                                                // https://promisesaplus.com/#point-59
                                                // Ignore double-resolution attempts
                                                if (depth < maxDepth) {
                                                    return;
                                                }

                                                returned = handler.apply(that, args);

                                                // Support: Promises/A+ section 2.3.1
                                                // https://promisesaplus.com/#point-48
                                                if (returned === deferred.promise()) {
                                                    throw new TypeError("Thenable self-resolution");
                                                }

                                                // Support: Promises/A+ sections 2.3.3.1, 3.5
                                                // https://promisesaplus.com/#point-54
                                                // https://promisesaplus.com/#point-75
                                                // Retrieve `then` only once
                                                then = returned &&

                                                    // Support: Promises/A+ section 2.3.4
                                                    // https://promisesaplus.com/#point-64
                                                    // Only check objects and functions for thenability
                                                    (typeof returned === "object" ||
                                                        typeof returned === "function") &&
                                                    returned.then;

                                                // Handle a returned thenable
                                                if (jQuery.isFunction(then)) {

                                                    // Special processors (notify) just wait for resolution
                                                    if (special) {
                                                        then.call(
                                                            returned,
                                                            resolve(maxDepth, deferred, Identity, special),
                                                            resolve(maxDepth, deferred, Thrower, special)
                                                        );

                                                        // Normal processors (resolve) also hook into progress
                                                    } else {

                                                        // ...and disregard older resolution values
                                                        maxDepth++;

                                                        then.call(
                                                            returned,
                                                            resolve(maxDepth, deferred, Identity, special),
                                                            resolve(maxDepth, deferred, Thrower, special),
                                                            resolve(maxDepth, deferred, Identity,
                                                                deferred.notifyWith)
                                                        );
                                                    }

                                                    // Handle all other returned values
                                                } else {

                                                    // Only substitute handlers pass on context
                                                    // and multiple values (non-spec behavior)
                                                    if (handler !== Identity) {
                                                        that = undefined;
                                                        args = [returned];
                                                    }

                                                    // Process the value(s)
                                                    // Default process is resolve
                                                    (special || deferred.resolveWith)(that, args);
                                                }
                                            },

                                            // Only normal processors (resolve) catch and reject exceptions
                                            process = special ?
                                            mightThrow :
                                            function() {
                                                try {
                                                    mightThrow();
                                                } catch (e) {

                                                    if (jQuery.Deferred.exceptionHook) {
                                                        jQuery.Deferred.exceptionHook(e,
                                                            process.stackTrace);
                                                    }

                                                    // Support: Promises/A+ section 2.3.3.3.4.1
                                                    // https://promisesaplus.com/#point-61
                                                    // Ignore post-resolution exceptions
                                                    if (depth + 1 >= maxDepth) {

                                                        // Only substitute handlers pass on context
                                                        // and multiple values (non-spec behavior)
                                                        if (handler !== Thrower) {
                                                            that = undefined;
                                                            args = [e];
                                                        }

                                                        deferred.rejectWith(that, args);
                                                    }
                                                }
                                            };

                                        // Support: Promises/A+ section 2.3.3.3.1
                                        // https://promisesaplus.com/#point-57
                                        // Re-resolve promises immediately to dodge false rejection from
                                        // subsequent errors
                                        if (depth) {
                                            process();
                                        } else {

                                            // Call an optional hook to record the stack, in case of exception
                                            // since it's otherwise lost when execution goes async
                                            if (jQuery.Deferred.getStackHook) {
                                                process.stackTrace = jQuery.Deferred.getStackHook();
                                            }
                                            window.setTimeout(process);
                                        }
                                    };
                                }

                                return jQuery.Deferred(function(newDefer) {

                                    // progress_handlers.add( ... )
                                    tuples[0][3].add(
                                        resolve(
                                            0,
                                            newDefer,
                                            jQuery.isFunction(onProgress) ?
                                            onProgress :
                                            Identity,
                                            newDefer.notifyWith
                                        )
                                    );

                                    // fulfilled_handlers.add( ... )
                                    tuples[1][3].add(
                                        resolve(
                                            0,
                                            newDefer,
                                            jQuery.isFunction(onFulfilled) ?
                                            onFulfilled :
                                            Identity
                                        )
                                    );

                                    // rejected_handlers.add( ... )
                                    tuples[2][3].add(
                                        resolve(
                                            0,
                                            newDefer,
                                            jQuery.isFunction(onRejected) ?
                                            onRejected :
                                            Thrower
                                        )
                                    );
                                }).promise();
                            },

                            // Get a promise for this deferred
                            // If obj is provided, the promise aspect is added to the object
                            promise: function(obj) {
                                return obj != null ? jQuery.extend(obj, promise) : promise;
                            }
                        },
                        deferred = {};

                    // Add list-specific methods
                    jQuery.each(tuples, function(i, tuple) {
                        var list = tuple[2],
                            stateString = tuple[5];

                        // promise.progress = list.add
                        // promise.done = list.add
                        // promise.fail = list.add
                        promise[tuple[1]] = list.add;

                        // Handle state
                        if (stateString) {
                            list.add(
                                function() {

                                    // state = "resolved" (i.e., fulfilled)
                                    // state = "rejected"
                                    state = stateString;
                                },

                                // rejected_callbacks.disable
                                // fulfilled_callbacks.disable
                                tuples[3 - i][2].disable,

                                // progress_callbacks.lock
                                tuples[0][2].lock
                            );
                        }

                        // progress_handlers.fire
                        // fulfilled_handlers.fire
                        // rejected_handlers.fire
                        list.add(tuple[3].fire);

                        // deferred.notify = function() { deferred.notifyWith(...) }
                        // deferred.resolve = function() { deferred.resolveWith(...) }
                        // deferred.reject = function() { deferred.rejectWith(...) }
                        deferred[tuple[0]] = function() {
                            deferred[tuple[0] + "With"](this === deferred ? undefined : this, arguments);
                            return this;
                        };

                        // deferred.notifyWith = list.fireWith
                        // deferred.resolveWith = list.fireWith
                        // deferred.rejectWith = list.fireWith
                        deferred[tuple[0] + "With"] = list.fireWith;
                    });

                    // Make the deferred a promise
                    promise.promise(deferred);

                    // Call given func if any
                    if (func) {
                        func.call(deferred, deferred);
                    }

                    // All done!
                    return deferred;
                },

                // Deferred helper
                when: function(singleValue) {
                    var

                    // count of uncompleted subordinates
                        remaining = arguments.length,

                        // count of unprocessed arguments
                        i = remaining,

                        // subordinate fulfillment data
                        resolveContexts = Array(i),
                        resolveValues = slice.call(arguments),

                        // the master Deferred
                        master = jQuery.Deferred(),

                        // subordinate callback factory
                        updateFunc = function(i) {
                            return function(value) {
                                resolveContexts[i] = this;
                                resolveValues[i] = arguments.length > 1 ? slice.call(arguments) : value;
                                if (!(--remaining)) {
                                    master.resolveWith(resolveContexts, resolveValues);
                                }
                            };
                        };

                    // Single- and empty arguments are adopted like Promise.resolve
                    if (remaining <= 1) {
                        adoptValue(singleValue, master.done(updateFunc(i)).resolve, master.reject, !remaining);

                        // Use .then() to unwrap secondary thenables (cf. gh-3000)
                        if (master.state() === "pending" ||
                            jQuery.isFunction(resolveValues[i] && resolveValues[i].then)) {

                            return master.then();
                        }
                    }

                    // Multiple arguments are aggregated like Promise.all array elements
                    while (i--) {
                        adoptValue(resolveValues[i], updateFunc(i), master.reject);
                    }

                    return master.promise();
                }
            });


            // These usually indicate a programmer mistake during development,
            // warn about them ASAP rather than swallowing them by default.
            var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;

            jQuery.Deferred.exceptionHook = function(error, stack) {

                // Support: IE 8 - 9 only
                // Console exists when dev tools are open, which can happen at any time
                if (window.console && window.console.warn && error && rerrorNames.test(error.name)) {
                    window.console.warn("jQuery.Deferred exception: " + error.message, error.stack, stack);
                }
            };




            jQuery.readyException = function(error) {
                window.setTimeout(function() {
                    throw error;
                });
            };




            // The deferred used on DOM ready
            var readyList = jQuery.Deferred();

            jQuery.fn.ready = function(fn) {

                readyList
                    .then(fn)

                // Wrap jQuery.readyException in a function so that the lookup
                // happens at the time of error handling instead of callback
                // registration.
                .catch(function(error) {
                    jQuery.readyException(error);
                });

                return this;
            };

            jQuery.extend({

                // Is the DOM ready to be used? Set to true once it occurs.
                isReady: false,

                // A counter to track how many items to wait for before
                // the ready event fires. See #6781
                readyWait: 1,

                // Handle when the DOM is ready
                ready: function(wait) {

                    // Abort if there are pending holds or we're already ready
                    if (wait === true ? --jQuery.readyWait : jQuery.isReady) {
                        return;
                    }

                    // Remember that the DOM is ready
                    jQuery.isReady = true;

                    // If a normal DOM Ready event fired, decrement, and wait if need be
                    if (wait !== true && --jQuery.readyWait > 0) {
                        return;
                    }

                    // If there are functions bound, to execute
                    readyList.resolveWith(document, [jQuery]);
                }
            });

            jQuery.ready.then = readyList.then;

            // The ready event handler and self cleanup method
            function completed() {
                document.removeEventListener("DOMContentLoaded", completed);
                window.removeEventListener("load", completed);
                jQuery.ready();
            }

            // Catch cases where $(document).ready() is called
            // after the browser event has already occurred.
            // Support: IE <=9 - 10 only
            // Older IE sometimes signals "interactive" too soon
            if (document.readyState === "complete" ||
                (document.readyState !== "loading" && !document.documentElement.doScroll)) {

                // Handle it asynchronously to allow scripts the opportunity to delay ready
                window.setTimeout(jQuery.ready);

            } else {

                // Use the handy event callback
                document.addEventListener("DOMContentLoaded", completed);

                // A fallback to window.onload, that will always work
                window.addEventListener("load", completed);
            }




            // Multifunctional method to get and set values of a collection
            // The value/s can optionally be executed if it's a function
            var access = function(elems, fn, key, value, chainable, emptyGet, raw) {
                var i = 0,
                    len = elems.length,
                    bulk = key == null;

                // Sets many values
                if (jQuery.type(key) === "object") {
                    chainable = true;
                    for (i in key) {
                        access(elems, fn, i, key[i], true, emptyGet, raw);
                    }

                    // Sets one value
                } else if (value !== undefined) {
                    chainable = true;

                    if (!jQuery.isFunction(value)) {
                        raw = true;
                    }

                    if (bulk) {

                        // Bulk operations run against the entire set
                        if (raw) {
                            fn.call(elems, value);
                            fn = null;

                            // ...except when executing function values
                        } else {
                            bulk = fn;
                            fn = function(elem, key, value) {
                                return bulk.call(jQuery(elem), value);
                            };
                        }
                    }

                    if (fn) {
                        for (; i < len; i++) {
                            fn(
                                elems[i], key, raw ?
                                value :
                                value.call(elems[i], i, fn(elems[i], key))
                            );
                        }
                    }
                }

                if (chainable) {
                    return elems;
                }

                // Gets
                if (bulk) {
                    return fn.call(elems);
                }

                return len ? fn(elems[0], key) : emptyGet;
            };
            var acceptData = function(owner) {

                // Accepts only:
                //  - Node
                //    - Node.ELEMENT_NODE
                //    - Node.DOCUMENT_NODE
                //  - Object
                //    - Any
                return owner.nodeType === 1 || owner.nodeType === 9 || !(+owner.nodeType);
            };




            function Data() {
                this.expando = jQuery.expando + Data.uid++;
            }

            Data.uid = 1;

            Data.prototype = {

                cache: function(owner) {

                    // Check if the owner object already has a cache
                    var value = owner[this.expando];

                    // If not, create one
                    if (!value) {
                        value = {};

                        // We can accept data for non-element nodes in modern browsers,
                        // but we should not, see #8335.
                        // Always return an empty object.
                        if (acceptData(owner)) {

                            // If it is a node unlikely to be stringify-ed or looped over
                            // use plain assignment
                            if (owner.nodeType) {
                                owner[this.expando] = value;

                                // Otherwise secure it in a non-enumerable property
                                // configurable must be true to allow the property to be
                                // deleted when data is removed
                            } else {
                                Object.defineProperty(owner, this.expando, {
                                    value: value,
                                    configurable: true
                                });
                            }
                        }
                    }

                    return value;
                },
                set: function(owner, data, value) {
                    var prop,
                        cache = this.cache(owner);

                    // Handle: [ owner, key, value ] args
                    // Always use camelCase key (gh-2257)
                    if (typeof data === "string") {
                        cache[jQuery.camelCase(data)] = value;

                        // Handle: [ owner, { properties } ] args
                    } else {

                        // Copy the properties one-by-one to the cache object
                        for (prop in data) {
                            cache[jQuery.camelCase(prop)] = data[prop];
                        }
                    }
                    return cache;
                },
                get: function(owner, key) {
                    return key === undefined ?
                        this.cache(owner) :

                        // Always use camelCase key (gh-2257)
                        owner[this.expando] && owner[this.expando][jQuery.camelCase(key)];
                },
                access: function(owner, key, value) {

                    // In cases where either:
                    //
                    //   1. No key was specified
                    //   2. A string key was specified, but no value provided
                    //
                    // Take the "read" path and allow the get method to determine
                    // which value to return, respectively either:
                    //
                    //   1. The entire cache object
                    //   2. The data stored at the key
                    //
                    if (key === undefined ||
                        ((key && typeof key === "string") && value === undefined)) {

                        return this.get(owner, key);
                    }

                    // When the key is not a string, or both a key and value
                    // are specified, set or extend (existing objects) with either:
                    //
                    //   1. An object of properties
                    //   2. A key and value
                    //
                    this.set(owner, key, value);

                    // Since the "set" path can have two possible entry points
                    // return the expected data based on which path was taken[*]
                    return value !== undefined ? value : key;
                },
                remove: function(owner, key) {
                    var i,
                        cache = owner[this.expando];

                    if (cache === undefined) {
                        return;
                    }

                    if (key !== undefined) {

                        // Support array or space separated string of keys
                        if (Array.isArray(key)) {

                            // If key is an array of keys...
                            // We always set camelCase keys, so remove that.
                            key = key.map(jQuery.camelCase);
                        } else {
                            key = jQuery.camelCase(key);

                            // If a key with the spaces exists, use it.
                            // Otherwise, create an array by matching non-whitespace
                            key = key in cache ? [key] :
                                (key.match(rnothtmlwhite) || []);
                        }

                        i = key.length;

                        while (i--) {
                            delete cache[key[i]];
                        }
                    }

                    // Remove the expando if there's no more data
                    if (key === undefined || jQuery.isEmptyObject(cache)) {

                        // Support: Chrome <=35 - 45
                        // Webkit & Blink performance suffers when deleting properties
                        // from DOM nodes, so set to undefined instead
                        // https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)
                        if (owner.nodeType) {
                            owner[this.expando] = undefined;
                        } else {
                            delete owner[this.expando];
                        }
                    }
                },
                hasData: function(owner) {
                    var cache = owner[this.expando];
                    return cache !== undefined && !jQuery.isEmptyObject(cache);
                }
            };
            var dataPriv = new Data();

            var dataUser = new Data();



            //	Implementation Summary
            //
            //	1. Enforce API surface and semantic compatibility with 1.9.x branch
            //	2. Improve the module's maintainability by reducing the storage
            //		paths to a single mechanism.
            //	3. Use the same single mechanism to support "private" and "user" data.
            //	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
            //	5. Avoid exposing implementation details on user objects (eg. expando properties)
            //	6. Provide a clear path for implementation upgrade to WeakMap in 2014

            var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
                rmultiDash = /[A-Z]/g;

            function getData(data) {
                if (data === "true") {
                    return true;
                }

                if (data === "false") {
                    return false;
                }

                if (data === "null") {
                    return null;
                }

                // Only convert to a number if it doesn't change the string
                if (data === +data + "") {
                    return +data;
                }

                if (rbrace.test(data)) {
                    return JSON.parse(data);
                }

                return data;
            }

            function dataAttr(elem, key, data) {
                var name;

                // If nothing was found internally, try to fetch any
                // data from the HTML5 data-* attribute
                if (data === undefined && elem.nodeType === 1) {
                    name = "data-" + key.replace(rmultiDash, "-$&").toLowerCase();
                    data = elem.getAttribute(name);

                    if (typeof data === "string") {
                        try {
                            data = getData(data);
                        } catch (e) {}

                        // Make sure we set the data so it isn't changed later
                        dataUser.set(elem, key, data);
                    } else {
                        data = undefined;
                    }
                }
                return data;
            }

            jQuery.extend({
                hasData: function(elem) {
                    return dataUser.hasData(elem) || dataPriv.hasData(elem);
                },

                data: function(elem, name, data) {
                    return dataUser.access(elem, name, data);
                },

                removeData: function(elem, name) {
                    dataUser.remove(elem, name);
                },

                // TODO: Now that all calls to _data and _removeData have been replaced
                // with direct calls to dataPriv methods, these can be deprecated.
                _data: function(elem, name, data) {
                    return dataPriv.access(elem, name, data);
                },

                _removeData: function(elem, name) {
                    dataPriv.remove(elem, name);
                }
            });

            jQuery.fn.extend({
                data: function(key, value) {
                    var i, name, data,
                        elem = this[0],
                        attrs = elem && elem.attributes;

                    // Gets all values
                    if (key === undefined) {
                        if (this.length) {
                            data = dataUser.get(elem);

                            if (elem.nodeType === 1 && !dataPriv.get(elem, "hasDataAttrs")) {
                                i = attrs.length;
                                while (i--) {

                                    // Support: IE 11 only
                                    // The attrs elements can be null (#14894)
                                    if (attrs[i]) {
                                        name = attrs[i].name;
                                        if (name.indexOf("data-") === 0) {
                                            name = jQuery.camelCase(name.slice(5));
                                            dataAttr(elem, name, data[name]);
                                        }
                                    }
                                }
                                dataPriv.set(elem, "hasDataAttrs", true);
                            }
                        }

                        return data;
                    }

                    // Sets multiple values
                    if (typeof key === "object") {
                        return this.each(function() {
                            dataUser.set(this, key);
                        });
                    }

                    return access(this, function(value) {
                        var data;

                        // The calling jQuery object (element matches) is not empty
                        // (and therefore has an element appears at this[ 0 ]) and the
                        // `value` parameter was not undefined. An empty jQuery object
                        // will result in `undefined` for elem = this[ 0 ] which will
                        // throw an exception if an attempt to read a data cache is made.
                        if (elem && value === undefined) {

                            // Attempt to get data from the cache
                            // The key will always be camelCased in Data
                            data = dataUser.get(elem, key);
                            if (data !== undefined) {
                                return data;
                            }

                            // Attempt to "discover" the data in
                            // HTML5 custom data-* attrs
                            data = dataAttr(elem, key);
                            if (data !== undefined) {
                                return data;
                            }

                            // We tried really hard, but the data doesn't exist.
                            return;
                        }

                        // Set the data...
                        this.each(function() {

                            // We always store the camelCased key
                            dataUser.set(this, key, value);
                        });
                    }, null, value, arguments.length > 1, null, true);
                },

                removeData: function(key) {
                    return this.each(function() {
                        dataUser.remove(this, key);
                    });
                }
            });


            jQuery.extend({
                queue: function(elem, type, data) {
                    var queue;

                    if (elem) {
                        type = (type || "fx") + "queue";
                        queue = dataPriv.get(elem, type);

                        // Speed up dequeue by getting out quickly if this is just a lookup
                        if (data) {
                            if (!queue || Array.isArray(data)) {
                                queue = dataPriv.access(elem, type, jQuery.makeArray(data));
                            } else {
                                queue.push(data);
                            }
                        }
                        return queue || [];
                    }
                },

                dequeue: function(elem, type) {
                    type = type || "fx";

                    var queue = jQuery.queue(elem, type),
                        startLength = queue.length,
                        fn = queue.shift(),
                        hooks = jQuery._queueHooks(elem, type),
                        next = function() {
                            jQuery.dequeue(elem, type);
                        };

                    // If the fx queue is dequeued, always remove the progress sentinel
                    if (fn === "inprogress") {
                        fn = queue.shift();
                        startLength--;
                    }

                    if (fn) {

                        // Add a progress sentinel to prevent the fx queue from being
                        // automatically dequeued
                        if (type === "fx") {
                            queue.unshift("inprogress");
                        }

                        // Clear up the last queue stop function
                        delete hooks.stop;
                        fn.call(elem, next, hooks);
                    }

                    if (!startLength && hooks) {
                        hooks.empty.fire();
                    }
                },

                // Not public - generate a queueHooks object, or return the current one
                _queueHooks: function(elem, type) {
                    var key = type + "queueHooks";
                    return dataPriv.get(elem, key) || dataPriv.access(elem, key, {
                        empty: jQuery.Callbacks("once memory").add(function() {
                            dataPriv.remove(elem, [type + "queue", key]);
                        })
                    });
                }
            });

            jQuery.fn.extend({
                queue: function(type, data) {
                    var setter = 2;

                    if (typeof type !== "string") {
                        data = type;
                        type = "fx";
                        setter--;
                    }

                    if (arguments.length < setter) {
                        return jQuery.queue(this[0], type);
                    }

                    return data === undefined ?
                        this :
                        this.each(function() {
                            var queue = jQuery.queue(this, type, data);

                            // Ensure a hooks for this queue
                            jQuery._queueHooks(this, type);

                            if (type === "fx" && queue[0] !== "inprogress") {
                                jQuery.dequeue(this, type);
                            }
                        });
                },
                dequeue: function(type) {
                    return this.each(function() {
                        jQuery.dequeue(this, type);
                    });
                },
                clearQueue: function(type) {
                    return this.queue(type || "fx", []);
                },

                // Get a promise resolved when queues of a certain type
                // are emptied (fx is the type by default)
                promise: function(type, obj) {
                    var tmp,
                        count = 1,
                        defer = jQuery.Deferred(),
                        elements = this,
                        i = this.length,
                        resolve = function() {
                            if (!(--count)) {
                                defer.resolveWith(elements, [elements]);
                            }
                        };

                    if (typeof type !== "string") {
                        obj = type;
                        type = undefined;
                    }
                    type = type || "fx";

                    while (i--) {
                        tmp = dataPriv.get(elements[i], type + "queueHooks");
                        if (tmp && tmp.empty) {
                            count++;
                            tmp.empty.add(resolve);
                        }
                    }
                    resolve();
                    return defer.promise(obj);
                }
            });
            var pnum = (/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/).source;

            var rcssNum = new RegExp("^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i");


            var cssExpand = ["Top", "Right", "Bottom", "Left"];

            var isHiddenWithinTree = function(elem, el) {

                // isHiddenWithinTree might be called from jQuery#filter function;
                // in that case, element will be second argument
                elem = el || elem;

                // Inline style trumps all
                return elem.style.display === "none" ||
                    elem.style.display === "" &&

                    // Otherwise, check computed style
                    // Support: Firefox <=43 - 45
                    // Disconnected elements can have computed display: none, so first confirm that elem is
                    // in the document.
                    jQuery.contains(elem.ownerDocument, elem) &&

                    jQuery.css(elem, "display") === "none";
            };

            var swap = function(elem, options, callback, args) {
                var ret, name,
                    old = {};

                // Remember the old values, and insert the new ones
                for (name in options) {
                    old[name] = elem.style[name];
                    elem.style[name] = options[name];
                }

                ret = callback.apply(elem, args || []);

                // Revert the old values
                for (name in options) {
                    elem.style[name] = old[name];
                }

                return ret;
            };




            function adjustCSS(elem, prop, valueParts, tween) {
                var adjusted,
                    scale = 1,
                    maxIterations = 20,
                    currentValue = tween ?
                    function() {
                        return tween.cur();
                    } :
                    function() {
                        return jQuery.css(elem, prop, "");
                    },
                    initial = currentValue(),
                    unit = valueParts && valueParts[3] || (jQuery.cssNumber[prop] ? "" : "px"),

                    // Starting value computation is required for potential unit mismatches
                    initialInUnit = (jQuery.cssNumber[prop] || unit !== "px" && +initial) &&
                    rcssNum.exec(jQuery.css(elem, prop));

                if (initialInUnit && initialInUnit[3] !== unit) {

                    // Trust units reported by jQuery.css
                    unit = unit || initialInUnit[3];

                    // Make sure we update the tween properties later on
                    valueParts = valueParts || [];

                    // Iteratively approximate from a nonzero starting point
                    initialInUnit = +initial || 1;

                    do {

                        // If previous iteration zeroed out, double until we get *something*.
                        // Use string for doubling so we don't accidentally see scale as unchanged below
                        scale = scale || ".5";

                        // Adjust and apply
                        initialInUnit = initialInUnit / scale;
                        jQuery.style(elem, prop, initialInUnit + unit);

                        // Update scale, tolerating zero or NaN from tween.cur()
                        // Break the loop if scale is unchanged or perfect, or if we've just had enough.
                    } while (
                        scale !== (scale = currentValue() / initial) && scale !== 1 && --maxIterations
                    );
                }

                if (valueParts) {
                    initialInUnit = +initialInUnit || +initial || 0;

                    // Apply relative offset (+=/-=) if specified
                    adjusted = valueParts[1] ?
                        initialInUnit + (valueParts[1] + 1) * valueParts[2] :
                        +valueParts[2];
                    if (tween) {
                        tween.unit = unit;
                        tween.start = initialInUnit;
                        tween.end = adjusted;
                    }
                }
                return adjusted;
            }


            var defaultDisplayMap = {};

            function getDefaultDisplay(elem) {
                var temp,
                    doc = elem.ownerDocument,
                    nodeName = elem.nodeName,
                    display = defaultDisplayMap[nodeName];

                if (display) {
                    return display;
                }

                temp = doc.body.appendChild(doc.createElement(nodeName));
                display = jQuery.css(temp, "display");

                temp.parentNode.removeChild(temp);

                if (display === "none") {
                    display = "block";
                }
                defaultDisplayMap[nodeName] = display;

                return display;
            }

            function showHide(elements, show) {
                var display, elem,
                    values = [],
                    index = 0,
                    length = elements.length;

                // Determine new display value for elements that need to change
                for (; index < length; index++) {
                    elem = elements[index];
                    if (!elem.style) {
                        continue;
                    }

                    display = elem.style.display;
                    if (show) {

                        // Since we force visibility upon cascade-hidden elements, an immediate (and slow)
                        // check is required in this first loop unless we have a nonempty display value (either
                        // inline or about-to-be-restored)
                        if (display === "none") {
                            values[index] = dataPriv.get(elem, "display") || null;
                            if (!values[index]) {
                                elem.style.display = "";
                            }
                        }
                        if (elem.style.display === "" && isHiddenWithinTree(elem)) {
                            values[index] = getDefaultDisplay(elem);
                        }
                    } else {
                        if (display !== "none") {
                            values[index] = "none";

                            // Remember what we're overwriting
                            dataPriv.set(elem, "display", display);
                        }
                    }
                }

                // Set the display of the elements in a second loop to avoid constant reflow
                for (index = 0; index < length; index++) {
                    if (values[index] != null) {
                        elements[index].style.display = values[index];
                    }
                }

                return elements;
            }

            jQuery.fn.extend({
                show: function() {
                    return showHide(this, true);
                },
                hide: function() {
                    return showHide(this);
                },
                toggle: function(state) {
                    if (typeof state === "boolean") {
                        return state ? this.show() : this.hide();
                    }

                    return this.each(function() {
                        if (isHiddenWithinTree(this)) {
                            jQuery(this).show();
                        } else {
                            jQuery(this).hide();
                        }
                    });
                }
            });
            var rcheckableType = (/^(?:checkbox|radio)$/i);

            var rtagName = (/<([a-z][^\/\0>\x20\t\r\n\f]+)/i);

            var rscriptType = (/^$|\/(?:java|ecma)script/i);



            // We have to close these tags to support XHTML (#13200)
            var wrapMap = {

                // Support: IE <=9 only
                option: [1, "<select multiple='multiple'>", "</select>"],

                // XHTML parsers do not magically insert elements in the
                // same way that tag soup parsers do. So we cannot shorten
                // this by omitting <tbody> or other required elements.
                thead: [1, "<table>", "</table>"],
                col: [2, "<table><colgroup>", "</colgroup></table>"],
                tr: [2, "<table><tbody>", "</tbody></table>"],
                td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],

                _default: [0, "", ""]
            };

            // Support: IE <=9 only
            wrapMap.optgroup = wrapMap.option;

            wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
            wrapMap.th = wrapMap.td;


            function getAll(context, tag) {

                // Support: IE <=9 - 11 only
                // Use typeof to avoid zero-argument method invocation on host objects (#15151)
                var ret;

                if (typeof context.getElementsByTagName !== "undefined") {
                    ret = context.getElementsByTagName(tag || "*");

                } else if (typeof context.querySelectorAll !== "undefined") {
                    ret = context.querySelectorAll(tag || "*");

                } else {
                    ret = [];
                }

                if (tag === undefined || tag && nodeName(context, tag)) {
                    return jQuery.merge([context], ret);
                }

                return ret;
            }


            // Mark scripts as having already been evaluated
            function setGlobalEval(elems, refElements) {
                var i = 0,
                    l = elems.length;

                for (; i < l; i++) {
                    dataPriv.set(
                        elems[i],
                        "globalEval", !refElements || dataPriv.get(refElements[i], "globalEval")
                    );
                }
            }


            var rhtml = /<|&#?\w+;/;

            function buildFragment(elems, context, scripts, selection, ignored) {
                var elem, tmp, tag, wrap, contains, j,
                    fragment = context.createDocumentFragment(),
                    nodes = [],
                    i = 0,
                    l = elems.length;

                for (; i < l; i++) {
                    elem = elems[i];

                    if (elem || elem === 0) {

                        // Add nodes directly
                        if (jQuery.type(elem) === "object") {

                            // Support: Android <=4.0 only, PhantomJS 1 only
                            // push.apply(_, arraylike) throws on ancient WebKit
                            jQuery.merge(nodes, elem.nodeType ? [elem] : elem);

                            // Convert non-html into a text node
                        } else if (!rhtml.test(elem)) {
                            nodes.push(context.createTextNode(elem));

                            // Convert html into DOM nodes
                        } else {
                            tmp = tmp || fragment.appendChild(context.createElement("div"));

                            // Deserialize a standard representation
                            tag = (rtagName.exec(elem) || ["", ""])[1].toLowerCase();
                            wrap = wrapMap[tag] || wrapMap._default;
                            tmp.innerHTML = wrap[1] + jQuery.htmlPrefilter(elem) + wrap[2];

                            // Descend through wrappers to the right content
                            j = wrap[0];
                            while (j--) {
                                tmp = tmp.lastChild;
                            }

                            // Support: Android <=4.0 only, PhantomJS 1 only
                            // push.apply(_, arraylike) throws on ancient WebKit
                            jQuery.merge(nodes, tmp.childNodes);

                            // Remember the top-level container
                            tmp = fragment.firstChild;

                            // Ensure the created nodes are orphaned (#12392)
                            tmp.textContent = "";
                        }
                    }
                }

                // Remove wrapper from fragment
                fragment.textContent = "";

                i = 0;
                while ((elem = nodes[i++])) {

                    // Skip elements already in the context collection (trac-4087)
                    if (selection && jQuery.inArray(elem, selection) > -1) {
                        if (ignored) {
                            ignored.push(elem);
                        }
                        continue;
                    }

                    contains = jQuery.contains(elem.ownerDocument, elem);

                    // Append to fragment
                    tmp = getAll(fragment.appendChild(elem), "script");

                    // Preserve script evaluation history
                    if (contains) {
                        setGlobalEval(tmp);
                    }

                    // Capture executables
                    if (scripts) {
                        j = 0;
                        while ((elem = tmp[j++])) {
                            if (rscriptType.test(elem.type || "")) {
                                scripts.push(elem);
                            }
                        }
                    }
                }

                return fragment;
            }


            (function() {
                var fragment = document.createDocumentFragment(),
                    div = fragment.appendChild(document.createElement("div")),
                    input = document.createElement("input");

                // Support: Android 4.0 - 4.3 only
                // Check state lost if the name is set (#11217)
                // Support: Windows Web Apps (WWA)
                // `name` and `type` must use .setAttribute for WWA (#14901)
                input.setAttribute("type", "radio");
                input.setAttribute("checked", "checked");
                input.setAttribute("name", "t");

                div.appendChild(input);

                // Support: Android <=4.1 only
                // Older WebKit doesn't clone checked state correctly in fragments
                support.checkClone = div.cloneNode(true).cloneNode(true).lastChild.checked;

                // Support: IE <=11 only
                // Make sure textarea (and checkbox) defaultValue is properly cloned
                div.innerHTML = "<textarea>x</textarea>";
                support.noCloneChecked = !!div.cloneNode(true).lastChild.defaultValue;
            })();
            var documentElement = document.documentElement;



            var
                rkeyEvent = /^key/,
                rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
                rtypenamespace = /^([^.]*)(?:\.(.+)|)/;

            function returnTrue() {
                return true;
            }

            function returnFalse() {
                return false;
            }

            // Support: IE <=9 only
            // See #13393 for more info
            function safeActiveElement() {
                try {
                    return document.activeElement;
                } catch (err) {}
            }

            function on(elem, types, selector, data, fn, one) {
                var origFn, type;

                // Types can be a map of types/handlers
                if (typeof types === "object") {

                    // ( types-Object, selector, data )
                    if (typeof selector !== "string") {

                        // ( types-Object, data )
                        data = data || selector;
                        selector = undefined;
                    }
                    for (type in types) {
                        on(elem, type, selector, data, types[type], one);
                    }
                    return elem;
                }

                if (data == null && fn == null) {

                    // ( types, fn )
                    fn = selector;
                    data = selector = undefined;
                } else if (fn == null) {
                    if (typeof selector === "string") {

                        // ( types, selector, fn )
                        fn = data;
                        data = undefined;
                    } else {

                        // ( types, data, fn )
                        fn = data;
                        data = selector;
                        selector = undefined;
                    }
                }
                if (fn === false) {
                    fn = returnFalse;
                } else if (!fn) {
                    return elem;
                }

                if (one === 1) {
                    origFn = fn;
                    fn = function(event) {

                        // Can use an empty set, since event contains the info
                        jQuery().off(event);
                        return origFn.apply(this, arguments);
                    };

                    // Use same guid so caller can remove using origFn
                    fn.guid = origFn.guid || (origFn.guid = jQuery.guid++);
                }
                return elem.each(function() {
                    jQuery.event.add(this, types, fn, data, selector);
                });
            }

            /*
             * Helper functions for managing events -- not part of the public interface.
             * Props to Dean Edwards' addEvent library for many of the ideas.
             */
            jQuery.event = {

                global: {},

                add: function(elem, types, handler, data, selector) {

                    var handleObjIn, eventHandle, tmp,
                        events, t, handleObj,
                        special, handlers, type, namespaces, origType,
                        elemData = dataPriv.get(elem);

                    // Don't attach events to noData or text/comment nodes (but allow plain objects)
                    if (!elemData) {
                        return;
                    }

                    // Caller can pass in an object of custom data in lieu of the handler
                    if (handler.handler) {
                        handleObjIn = handler;
                        handler = handleObjIn.handler;
                        selector = handleObjIn.selector;
                    }

                    // Ensure that invalid selectors throw exceptions at attach time
                    // Evaluate against documentElement in case elem is a non-element node (e.g., document)
                    if (selector) {
                        jQuery.find.matchesSelector(documentElement, selector);
                    }

                    // Make sure that the handler has a unique ID, used to find/remove it later
                    if (!handler.guid) {
                        handler.guid = jQuery.guid++;
                    }

                    // Init the element's event structure and main handler, if this is the first
                    if (!(events = elemData.events)) {
                        events = elemData.events = {};
                    }
                    if (!(eventHandle = elemData.handle)) {
                        eventHandle = elemData.handle = function(e) {

                            // Discard the second event of a jQuery.event.trigger() and
                            // when an event is called after a page has unloaded
                            return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ?
                                jQuery.event.dispatch.apply(elem, arguments) : undefined;
                        };
                    }

                    // Handle multiple events separated by a space
                    types = (types || "").match(rnothtmlwhite) || [""];
                    t = types.length;
                    while (t--) {
                        tmp = rtypenamespace.exec(types[t]) || [];
                        type = origType = tmp[1];
                        namespaces = (tmp[2] || "").split(".").sort();

                        // There *must* be a type, no attaching namespace-only handlers
                        if (!type) {
                            continue;
                        }

                        // If event changes its type, use the special event handlers for the changed type
                        special = jQuery.event.special[type] || {};

                        // If selector defined, determine special event api type, otherwise given type
                        type = (selector ? special.delegateType : special.bindType) || type;

                        // Update special based on newly reset type
                        special = jQuery.event.special[type] || {};

                        // handleObj is passed to all event handlers
                        handleObj = jQuery.extend({
                            type: type,
                            origType: origType,
                            data: data,
                            handler: handler,
                            guid: handler.guid,
                            selector: selector,
                            needsContext: selector && jQuery.expr.match.needsContext.test(selector),
                            namespace: namespaces.join(".")
                        }, handleObjIn);

                        // Init the event handler queue if we're the first
                        if (!(handlers = events[type])) {
                            handlers = events[type] = [];
                            handlers.delegateCount = 0;

                            // Only use addEventListener if the special events handler returns false
                            if (!special.setup ||
                                special.setup.call(elem, data, namespaces, eventHandle) === false) {

                                if (elem.addEventListener) {
                                    elem.addEventListener(type, eventHandle);
                                }
                            }
                        }

                        if (special.add) {
                            special.add.call(elem, handleObj);

                            if (!handleObj.handler.guid) {
                                handleObj.handler.guid = handler.guid;
                            }
                        }

                        // Add to the element's handler list, delegates in front
                        if (selector) {
                            handlers.splice(handlers.delegateCount++, 0, handleObj);
                        } else {
                            handlers.push(handleObj);
                        }

                        // Keep track of which events have ever been used, for event optimization
                        jQuery.event.global[type] = true;
                    }

                },

                // Detach an event or set of events from an element
                remove: function(elem, types, handler, selector, mappedTypes) {

                    var j, origCount, tmp,
                        events, t, handleObj,
                        special, handlers, type, namespaces, origType,
                        elemData = dataPriv.hasData(elem) && dataPriv.get(elem);

                    if (!elemData || !(events = elemData.events)) {
                        return;
                    }

                    // Once for each type.namespace in types; type may be omitted
                    types = (types || "").match(rnothtmlwhite) || [""];
                    t = types.length;
                    while (t--) {
                        tmp = rtypenamespace.exec(types[t]) || [];
                        type = origType = tmp[1];
                        namespaces = (tmp[2] || "").split(".").sort();

                        // Unbind all events (on this namespace, if provided) for the element
                        if (!type) {
                            for (type in events) {
                                jQuery.event.remove(elem, type + types[t], handler, selector, true);
                            }
                            continue;
                        }

                        special = jQuery.event.special[type] || {};
                        type = (selector ? special.delegateType : special.bindType) || type;
                        handlers = events[type] || [];
                        tmp = tmp[2] &&
                            new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)");

                        // Remove matching events
                        origCount = j = handlers.length;
                        while (j--) {
                            handleObj = handlers[j];

                            if ((mappedTypes || origType === handleObj.origType) &&
                                (!handler || handler.guid === handleObj.guid) &&
                                (!tmp || tmp.test(handleObj.namespace)) &&
                                (!selector || selector === handleObj.selector ||
                                    selector === "**" && handleObj.selector)) {
                                handlers.splice(j, 1);

                                if (handleObj.selector) {
                                    handlers.delegateCount--;
                                }
                                if (special.remove) {
                                    special.remove.call(elem, handleObj);
                                }
                            }
                        }

                        // Remove generic event handler if we removed something and no more handlers exist
                        // (avoids potential for endless recursion during removal of special event handlers)
                        if (origCount && !handlers.length) {
                            if (!special.teardown ||
                                special.teardown.call(elem, namespaces, elemData.handle) === false) {

                                jQuery.removeEvent(elem, type, elemData.handle);
                            }

                            delete events[type];
                        }
                    }

                    // Remove data and the expando if it's no longer used
                    if (jQuery.isEmptyObject(events)) {
                        dataPriv.remove(elem, "handle events");
                    }
                },

                dispatch: function(nativeEvent) {

                    // Make a writable jQuery.Event from the native event object
                    var event = jQuery.event.fix(nativeEvent);

                    var i, j, ret, matched, handleObj, handlerQueue,
                        args = new Array(arguments.length),
                        handlers = (dataPriv.get(this, "events") || {})[event.type] || [],
                        special = jQuery.event.special[event.type] || {};

                    // Use the fix-ed jQuery.Event rather than the (read-only) native event
                    args[0] = event;

                    for (i = 1; i < arguments.length; i++) {
                        args[i] = arguments[i];
                    }

                    event.delegateTarget = this;

                    // Call the preDispatch hook for the mapped type, and let it bail if desired
                    if (special.preDispatch && special.preDispatch.call(this, event) === false) {
                        return;
                    }

                    // Determine handlers
                    handlerQueue = jQuery.event.handlers.call(this, event, handlers);

                    // Run delegates first; they may want to stop propagation beneath us
                    i = 0;
                    while ((matched = handlerQueue[i++]) && !event.isPropagationStopped()) {
                        event.currentTarget = matched.elem;

                        j = 0;
                        while ((handleObj = matched.handlers[j++]) &&
                            !event.isImmediatePropagationStopped()) {

                            // Triggered event must either 1) have no namespace, or 2) have namespace(s)
                            // a subset or equal to those in the bound event (both can have no namespace).
                            if (!event.rnamespace || event.rnamespace.test(handleObj.namespace)) {

                                event.handleObj = handleObj;
                                event.data = handleObj.data;

                                ret = ((jQuery.event.special[handleObj.origType] || {}).handle ||
                                    handleObj.handler).apply(matched.elem, args);

                                if (ret !== undefined) {
                                    if ((event.result = ret) === false) {
                                        event.preventDefault();
                                        event.stopPropagation();
                                    }
                                }
                            }
                        }
                    }

                    // Call the postDispatch hook for the mapped type
                    if (special.postDispatch) {
                        special.postDispatch.call(this, event);
                    }

                    return event.result;
                },

                handlers: function(event, handlers) {
                    var i, handleObj, sel, matchedHandlers, matchedSelectors,
                        handlerQueue = [],
                        delegateCount = handlers.delegateCount,
                        cur = event.target;

                    // Find delegate handlers
                    if (delegateCount &&

                        // Support: IE <=9
                        // Black-hole SVG <use> instance trees (trac-13180)
                        cur.nodeType &&

                        // Support: Firefox <=42
                        // Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
                        // https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
                        // Support: IE 11 only
                        // ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
                        !(event.type === "click" && event.button >= 1)) {

                        for (; cur !== this; cur = cur.parentNode || this) {

                            // Don't check non-elements (#13208)
                            // Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
                            if (cur.nodeType === 1 && !(event.type === "click" && cur.disabled === true)) {
                                matchedHandlers = [];
                                matchedSelectors = {};
                                for (i = 0; i < delegateCount; i++) {
                                    handleObj = handlers[i];

                                    // Don't conflict with Object.prototype properties (#13203)
                                    sel = handleObj.selector + " ";

                                    if (matchedSelectors[sel] === undefined) {
                                        matchedSelectors[sel] = handleObj.needsContext ?
                                            jQuery(sel, this).index(cur) > -1 :
                                            jQuery.find(sel, this, null, [cur]).length;
                                    }
                                    if (matchedSelectors[sel]) {
                                        matchedHandlers.push(handleObj);
                                    }
                                }
                                if (matchedHandlers.length) {
                                    handlerQueue.push({
                                        elem: cur,
                                        handlers: matchedHandlers
                                    });
                                }
                            }
                        }
                    }

                    // Add the remaining (directly-bound) handlers
                    cur = this;
                    if (delegateCount < handlers.length) {
                        handlerQueue.push({
                            elem: cur,
                            handlers: handlers.slice(delegateCount)
                        });
                    }

                    return handlerQueue;
                },

                addProp: function(name, hook) {
                    Object.defineProperty(jQuery.Event.prototype, name, {
                        enumerable: true,
                        configurable: true,

                        get: jQuery.isFunction(hook) ?
                            function() {
                                if (this.originalEvent) {
                                    return hook(this.originalEvent);
                                }
                            } : function() {
                                if (this.originalEvent) {
                                    return this.originalEvent[name];
                                }
                            },

                        set: function(value) {
                            Object.defineProperty(this, name, {
                                enumerable: true,
                                configurable: true,
                                writable: true,
                                value: value
                            });
                        }
                    });
                },

                fix: function(originalEvent) {
                    return originalEvent[jQuery.expando] ?
                        originalEvent :
                        new jQuery.Event(originalEvent);
                },

                special: {
                    load: {

                        // Prevent triggered image.load events from bubbling to window.load
                        noBubble: true
                    },
                    focus: {

                        // Fire native event if possible so blur/focus sequence is correct
                        trigger: function() {
                            if (this !== safeActiveElement() && this.focus) {
                                this.focus();
                                return false;
                            }
                        },
                        delegateType: "focusin"
                    },
                    blur: {
                        trigger: function() {
                            if (this === safeActiveElement() && this.blur) {
                                this.blur();
                                return false;
                            }
                        },
                        delegateType: "focusout"
                    },
                    click: {

                        // For checkbox, fire native event so checked state will be right
                        trigger: function() {
                            if (this.type === "checkbox" && this.click && nodeName(this, "input")) {
                                this.click();
                                return false;
                            }
                        },

                        // For cross-browser consistency, don't fire native .click() on links
                        _default: function(event) {
                            return nodeName(event.target, "a");
                        }
                    },

                    beforeunload: {
                        postDispatch: function(event) {

                            // Support: Firefox 20+
                            // Firefox doesn't alert if the returnValue field is not set.
                            if (event.result !== undefined && event.originalEvent) {
                                event.originalEvent.returnValue = event.result;
                            }
                        }
                    }
                }
            };

            jQuery.removeEvent = function(elem, type, handle) {

                // This "if" is needed for plain objects
                if (elem.removeEventListener) {
                    elem.removeEventListener(type, handle);
                }
            };

            jQuery.Event = function(src, props) {

                // Allow instantiation without the 'new' keyword
                if (!(this instanceof jQuery.Event)) {
                    return new jQuery.Event(src, props);
                }

                // Event object
                if (src && src.type) {
                    this.originalEvent = src;
                    this.type = src.type;

                    // Events bubbling up the document may have been marked as prevented
                    // by a handler lower down the tree; reflect the correct value.
                    this.isDefaultPrevented = src.defaultPrevented ||
                        src.defaultPrevented === undefined &&

                        // Support: Android <=2.3 only
                        src.returnValue === false ?
                        returnTrue :
                        returnFalse;

                    // Create target properties
                    // Support: Safari <=6 - 7 only
                    // Target should not be a text node (#504, #13143)
                    this.target = (src.target && src.target.nodeType === 3) ?
                        src.target.parentNode :
                        src.target;

                    this.currentTarget = src.currentTarget;
                    this.relatedTarget = src.relatedTarget;

                    // Event type
                } else {
                    this.type = src;
                }

                // Put explicitly provided properties onto the event object
                if (props) {
                    jQuery.extend(this, props);
                }

                // Create a timestamp if incoming event doesn't have one
                this.timeStamp = src && src.timeStamp || jQuery.now();

                // Mark it as fixed
                this[jQuery.expando] = true;
            };

            // jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
            // https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
            jQuery.Event.prototype = {
                constructor: jQuery.Event,
                isDefaultPrevented: returnFalse,
                isPropagationStopped: returnFalse,
                isImmediatePropagationStopped: returnFalse,
                isSimulated: false,

                preventDefault: function() {
                    var e = this.originalEvent;

                    this.isDefaultPrevented = returnTrue;

                    if (e && !this.isSimulated) {
                        e.preventDefault();
                    }
                },
                stopPropagation: function() {
                    var e = this.originalEvent;

                    this.isPropagationStopped = returnTrue;

                    if (e && !this.isSimulated) {
                        e.stopPropagation();
                    }
                },
                stopImmediatePropagation: function() {
                    var e = this.originalEvent;

                    this.isImmediatePropagationStopped = returnTrue;

                    if (e && !this.isSimulated) {
                        e.stopImmediatePropagation();
                    }

                    this.stopPropagation();
                }
            };

            // Includes all common event props including KeyEvent and MouseEvent specific props
            jQuery.each({
                altKey: true,
                bubbles: true,
                cancelable: true,
                changedTouches: true,
                ctrlKey: true,
                detail: true,
                eventPhase: true,
                metaKey: true,
                pageX: true,
                pageY: true,
                shiftKey: true,
                view: true,
                "char": true,
                charCode: true,
                key: true,
                keyCode: true,
                button: true,
                buttons: true,
                clientX: true,
                clientY: true,
                offsetX: true,
                offsetY: true,
                pointerId: true,
                pointerType: true,
                screenX: true,
                screenY: true,
                targetTouches: true,
                toElement: true,
                touches: true,

                which: function(event) {
                    var button = event.button;

                    // Add which for key events
                    if (event.which == null && rkeyEvent.test(event.type)) {
                        return event.charCode != null ? event.charCode : event.keyCode;
                    }

                    // Add which for click: 1 === left; 2 === middle; 3 === right
                    if (!event.which && button !== undefined && rmouseEvent.test(event.type)) {
                        if (button & 1) {
                            return 1;
                        }

                        if (button & 2) {
                            return 3;
                        }

                        if (button & 4) {
                            return 2;
                        }

                        return 0;
                    }

                    return event.which;
                }
            }, jQuery.event.addProp);

            // Create mouseenter/leave events using mouseover/out and event-time checks
            // so that event delegation works in jQuery.
            // Do the same for pointerenter/pointerleave and pointerover/pointerout
            //
            // Support: Safari 7 only
            // Safari sends mouseenter too often; see:
            // https://bugs.chromium.org/p/chromium/issues/detail?id=470258
            // for the description of the bug (it existed in older Chrome versions as well).
            jQuery.each({
                mouseenter: "mouseover",
                mouseleave: "mouseout",
                pointerenter: "pointerover",
                pointerleave: "pointerout"
            }, function(orig, fix) {
                jQuery.event.special[orig] = {
                    delegateType: fix,
                    bindType: fix,

                    handle: function(event) {
                        var ret,
                            target = this,
                            related = event.relatedTarget,
                            handleObj = event.handleObj;

                        // For mouseenter/leave call the handler if related is outside the target.
                        // NB: No relatedTarget if the mouse left/entered the browser window
                        if (!related || (related !== target && !jQuery.contains(target, related))) {
                            event.type = handleObj.origType;
                            ret = handleObj.handler.apply(this, arguments);
                            event.type = fix;
                        }
                        return ret;
                    }
                };
            });

            jQuery.fn.extend({

                on: function(types, selector, data, fn) {
                    return on(this, types, selector, data, fn);
                },
                one: function(types, selector, data, fn) {
                    return on(this, types, selector, data, fn, 1);
                },
                off: function(types, selector, fn) {
                    var handleObj, type;
                    if (types && types.preventDefault && types.handleObj) {

                        // ( event )  dispatched jQuery.Event
                        handleObj = types.handleObj;
                        jQuery(types.delegateTarget).off(
                            handleObj.namespace ?
                            handleObj.origType + "." + handleObj.namespace :
                            handleObj.origType,
                            handleObj.selector,
                            handleObj.handler
                        );
                        return this;
                    }
                    if (typeof types === "object") {

                        // ( types-object [, selector] )
                        for (type in types) {
                            this.off(type, selector, types[type]);
                        }
                        return this;
                    }
                    if (selector === false || typeof selector === "function") {

                        // ( types [, fn] )
                        fn = selector;
                        selector = undefined;
                    }
                    if (fn === false) {
                        fn = returnFalse;
                    }
                    return this.each(function() {
                        jQuery.event.remove(this, types, fn, selector);
                    });
                }
            });


            var

            /* eslint-disable max-len */

            // See https://github.com/eslint/eslint/issues/3229
                rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0>\x20\t\r\n\f]*)[^>]*)\/>/gi,

                /* eslint-enable */

                // Support: IE <=10 - 11, Edge 12 - 13
                // In IE/Edge using regex groups here causes severe slowdowns.
                // See https://connect.microsoft.com/IE/feedback/details/1736512/
                rnoInnerhtml = /<script|<style|<link/i,

                // checked="checked" or checked
                rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
                rscriptTypeMasked = /^true\/(.*)/,
                rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;

            // Prefer a tbody over its parent table for containing new rows
            function manipulationTarget(elem, content) {
                if (nodeName(elem, "table") &&
                    nodeName(content.nodeType !== 11 ? content : content.firstChild, "tr")) {

                    return jQuery(">tbody", elem)[0] || elem;
                }

                return elem;
            }

            // Replace/restore the type attribute of script elements for safe DOM manipulation
            function disableScript(elem) {
                elem.type = (elem.getAttribute("type") !== null) + "/" + elem.type;
                return elem;
            }

            function restoreScript(elem) {
                var match = rscriptTypeMasked.exec(elem.type);

                if (match) {
                    elem.type = match[1];
                } else {
                    elem.removeAttribute("type");
                }

                return elem;
            }

            function cloneCopyEvent(src, dest) {
                var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;

                if (dest.nodeType !== 1) {
                    return;
                }

                // 1. Copy private data: events, handlers, etc.
                if (dataPriv.hasData(src)) {
                    pdataOld = dataPriv.access(src);
                    pdataCur = dataPriv.set(dest, pdataOld);
                    events = pdataOld.events;

                    if (events) {
                        delete pdataCur.handle;
                        pdataCur.events = {};

                        for (type in events) {
                            for (i = 0, l = events[type].length; i < l; i++) {
                                jQuery.event.add(dest, type, events[type][i]);
                            }
                        }
                    }
                }

                // 2. Copy user data
                if (dataUser.hasData(src)) {
                    udataOld = dataUser.access(src);
                    udataCur = jQuery.extend({}, udataOld);

                    dataUser.set(dest, udataCur);
                }
            }

            // Fix IE bugs, see support tests
            function fixInput(src, dest) {
                var nodeName = dest.nodeName.toLowerCase();

                // Fails to persist the checked state of a cloned checkbox or radio button.
                if (nodeName === "input" && rcheckableType.test(src.type)) {
                    dest.checked = src.checked;

                    // Fails to return the selected option to the default selected state when cloning options
                } else if (nodeName === "input" || nodeName === "textarea") {
                    dest.defaultValue = src.defaultValue;
                }
            }

            function domManip(collection, args, callback, ignored) {

                // Flatten any nested arrays
                args = concat.apply([], args);

                var fragment, first, scripts, hasScripts, node, doc,
                    i = 0,
                    l = collection.length,
                    iNoClone = l - 1,
                    value = args[0],
                    isFunction = jQuery.isFunction(value);

                // We can't cloneNode fragments that contain checked, in WebKit
                if (isFunction ||
                    (l > 1 && typeof value === "string" &&
                        !support.checkClone && rchecked.test(value))) {
                    return collection.each(function(index) {
                        var self = collection.eq(index);
                        if (isFunction) {
                            args[0] = value.call(this, index, self.html());
                        }
                        domManip(self, args, callback, ignored);
                    });
                }

                if (l) {
                    fragment = buildFragment(args, collection[0].ownerDocument, false, collection, ignored);
                    first = fragment.firstChild;

                    if (fragment.childNodes.length === 1) {
                        fragment = first;
                    }

                    // Require either new content or an interest in ignored elements to invoke the callback
                    if (first || ignored) {
                        scripts = jQuery.map(getAll(fragment, "script"), disableScript);
                        hasScripts = scripts.length;

                        // Use the original fragment for the last item
                        // instead of the first because it can end up
                        // being emptied incorrectly in certain situations (#8070).
                        for (; i < l; i++) {
                            node = fragment;

                            if (i !== iNoClone) {
                                node = jQuery.clone(node, true, true);

                                // Keep references to cloned scripts for later restoration
                                if (hasScripts) {

                                    // Support: Android <=4.0 only, PhantomJS 1 only
                                    // push.apply(_, arraylike) throws on ancient WebKit
                                    jQuery.merge(scripts, getAll(node, "script"));
                                }
                            }

                            callback.call(collection[i], node, i);
                        }

                        if (hasScripts) {
                            doc = scripts[scripts.length - 1].ownerDocument;

                            // Reenable scripts
                            jQuery.map(scripts, restoreScript);

                            // Evaluate executable scripts on first document insertion
                            for (i = 0; i < hasScripts; i++) {
                                node = scripts[i];
                                if (rscriptType.test(node.type || "") &&
                                    !dataPriv.access(node, "globalEval") &&
                                    jQuery.contains(doc, node)) {

                                    if (node.src) {

                                        // Optional AJAX dependency, but won't run scripts if not present
                                        if (jQuery._evalUrl) {
                                            jQuery._evalUrl(node.src);
                                        }
                                    } else {
                                        DOMEval(node.textContent.replace(rcleanScript, ""), doc);
                                    }
                                }
                            }
                        }
                    }
                }

                return collection;
            }

            function remove(elem, selector, keepData) {
                var node,
                    nodes = selector ? jQuery.filter(selector, elem) : elem,
                    i = 0;

                for (;
                    (node = nodes[i]) != null; i++) {
                    if (!keepData && node.nodeType === 1) {
                        jQuery.cleanData(getAll(node));
                    }

                    if (node.parentNode) {
                        if (keepData && jQuery.contains(node.ownerDocument, node)) {
                            setGlobalEval(getAll(node, "script"));
                        }
                        node.parentNode.removeChild(node);
                    }
                }

                return elem;
            }

            jQuery.extend({
                htmlPrefilter: function(html) {
                    return html.replace(rxhtmlTag, "<$1></$2>");
                },

                clone: function(elem, dataAndEvents, deepDataAndEvents) {
                    var i, l, srcElements, destElements,
                        clone = elem.cloneNode(true),
                        inPage = jQuery.contains(elem.ownerDocument, elem);

                    // Fix IE cloning issues
                    if (!support.noCloneChecked && (elem.nodeType === 1 || elem.nodeType === 11) &&
                        !jQuery.isXMLDoc(elem)) {

                        // We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2
                        destElements = getAll(clone);
                        srcElements = getAll(elem);

                        for (i = 0, l = srcElements.length; i < l; i++) {
                            fixInput(srcElements[i], destElements[i]);
                        }
                    }

                    // Copy the events from the original to the clone
                    if (dataAndEvents) {
                        if (deepDataAndEvents) {
                            srcElements = srcElements || getAll(elem);
                            destElements = destElements || getAll(clone);

                            for (i = 0, l = srcElements.length; i < l; i++) {
                                cloneCopyEvent(srcElements[i], destElements[i]);
                            }
                        } else {
                            cloneCopyEvent(elem, clone);
                        }
                    }

                    // Preserve script evaluation history
                    destElements = getAll(clone, "script");
                    if (destElements.length > 0) {
                        setGlobalEval(destElements, !inPage && getAll(elem, "script"));
                    }

                    // Return the cloned set
                    return clone;
                },

                cleanData: function(elems) {
                    var data, elem, type,
                        special = jQuery.event.special,
                        i = 0;

                    for (;
                        (elem = elems[i]) !== undefined; i++) {
                        if (acceptData(elem)) {
                            if ((data = elem[dataPriv.expando])) {
                                if (data.events) {
                                    for (type in data.events) {
                                        if (special[type]) {
                                            jQuery.event.remove(elem, type);

                                            // This is a shortcut to avoid jQuery.event.remove's overhead
                                        } else {
                                            jQuery.removeEvent(elem, type, data.handle);
                                        }
                                    }
                                }

                                // Support: Chrome <=35 - 45+
                                // Assign undefined instead of using delete, see Data#remove
                                elem[dataPriv.expando] = undefined;
                            }
                            if (elem[dataUser.expando]) {

                                // Support: Chrome <=35 - 45+
                                // Assign undefined instead of using delete, see Data#remove
                                elem[dataUser.expando] = undefined;
                            }
                        }
                    }
                }
            });

            jQuery.fn.extend({
                detach: function(selector) {
                    return remove(this, selector, true);
                },

                remove: function(selector) {
                    return remove(this, selector);
                },

                text: function(value) {
                    return access(this, function(value) {
                        return value === undefined ?
                            jQuery.text(this) :
                            this.empty().each(function() {
                                if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                                    this.textContent = value;
                                }
                            });
                    }, null, value, arguments.length);
                },

                append: function() {
                    return domManip(this, arguments, function(elem) {
                        if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                            var target = manipulationTarget(this, elem);
                            target.appendChild(elem);
                        }
                    });
                },

                prepend: function() {
                    return domManip(this, arguments, function(elem) {
                        if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                            var target = manipulationTarget(this, elem);
                            target.insertBefore(elem, target.firstChild);
                        }
                    });
                },

                before: function() {
                    return domManip(this, arguments, function(elem) {
                        if (this.parentNode) {
                            this.parentNode.insertBefore(elem, this);
                        }
                    });
                },

                after: function() {
                    return domManip(this, arguments, function(elem) {
                        if (this.parentNode) {
                            this.parentNode.insertBefore(elem, this.nextSibling);
                        }
                    });
                },

                empty: function() {
                    var elem,
                        i = 0;

                    for (;
                        (elem = this[i]) != null; i++) {
                        if (elem.nodeType === 1) {

                            // Prevent memory leaks
                            jQuery.cleanData(getAll(elem, false));

                            // Remove any remaining nodes
                            elem.textContent = "";
                        }
                    }

                    return this;
                },

                clone: function(dataAndEvents, deepDataAndEvents) {
                    dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
                    deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

                    return this.map(function() {
                        return jQuery.clone(this, dataAndEvents, deepDataAndEvents);
                    });
                },

                html: function(value) {
                    return access(this, function(value) {
                        var elem = this[0] || {},
                            i = 0,
                            l = this.length;

                        if (value === undefined && elem.nodeType === 1) {
                            return elem.innerHTML;
                        }

                        // See if we can take a shortcut and just use innerHTML
                        if (typeof value === "string" && !rnoInnerhtml.test(value) &&
                            !wrapMap[(rtagName.exec(value) || ["", ""])[1].toLowerCase()]) {

                            value = jQuery.htmlPrefilter(value);

                            try {
                                for (; i < l; i++) {
                                    elem = this[i] || {};

                                    // Remove element nodes and prevent memory leaks
                                    if (elem.nodeType === 1) {
                                        jQuery.cleanData(getAll(elem, false));
                                        elem.innerHTML = value;
                                    }
                                }

                                elem = 0;

                                // If using innerHTML throws an exception, use the fallback method
                            } catch (e) {}
                        }

                        if (elem) {
                            this.empty().append(value);
                        }
                    }, null, value, arguments.length);
                },

                replaceWith: function() {
                    var ignored = [];

                    // Make the changes, replacing each non-ignored context element with the new content
                    return domManip(this, arguments, function(elem) {
                        var parent = this.parentNode;

                        if (jQuery.inArray(this, ignored) < 0) {
                            jQuery.cleanData(getAll(this));
                            if (parent) {
                                parent.replaceChild(elem, this);
                            }
                        }

                        // Force callback invocation
                    }, ignored);
                }
            });

            jQuery.each({
                appendTo: "append",
                prependTo: "prepend",
                insertBefore: "before",
                insertAfter: "after",
                replaceAll: "replaceWith"
            }, function(name, original) {
                jQuery.fn[name] = function(selector) {
                    var elems,
                        ret = [],
                        insert = jQuery(selector),
                        last = insert.length - 1,
                        i = 0;

                    for (; i <= last; i++) {
                        elems = i === last ? this : this.clone(true);
                        jQuery(insert[i])[original](elems);

                        // Support: Android <=4.0 only, PhantomJS 1 only
                        // .get() because push.apply(_, arraylike) throws on ancient WebKit
                        push.apply(ret, elems.get());
                    }

                    return this.pushStack(ret);
                };
            });
            var rmargin = (/^margin/);

            var rnumnonpx = new RegExp("^(" + pnum + ")(?!px)[a-z%]+$", "i");

            var getStyles = function(elem) {

                // Support: IE <=11 only, Firefox <=30 (#15098, #14150)
                // IE throws on elements created in popups
                // FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
                var view = elem.ownerDocument.defaultView;

                if (!view || !view.opener) {
                    view = window;
                }

                return view.getComputedStyle(elem);
            };



            (function() {

                // Executing both pixelPosition & boxSizingReliable tests require only one layout
                // so they're executed at the same time to save the second computation.
                function computeStyleTests() {

                    // This is a singleton, we need to execute it only once
                    if (!div) {
                        return;
                    }

                    div.style.cssText =
                        "box-sizing:border-box;" +
                        "position:relative;display:block;" +
                        "margin:auto;border:1px;padding:1px;" +
                        "top:1%;width:50%";
                    div.innerHTML = "";
                    documentElement.appendChild(container);

                    var divStyle = window.getComputedStyle(div);
                    pixelPositionVal = divStyle.top !== "1%";

                    // Support: Android 4.0 - 4.3 only, Firefox <=3 - 44
                    reliableMarginLeftVal = divStyle.marginLeft === "2px";
                    boxSizingReliableVal = divStyle.width === "4px";

                    // Support: Android 4.0 - 4.3 only
                    // Some styles come back with percentage values, even though they shouldn't
                    div.style.marginRight = "50%";
                    pixelMarginRightVal = divStyle.marginRight === "4px";

                    documentElement.removeChild(container);

                    // Nullify the div so it wouldn't be stored in the memory and
                    // it will also be a sign that checks already performed
                    div = null;
                }

                var pixelPositionVal, boxSizingReliableVal, pixelMarginRightVal, reliableMarginLeftVal,
                    container = document.createElement("div"),
                    div = document.createElement("div");

                // Finish early in limited (non-browser) environments
                if (!div.style) {
                    return;
                }

                // Support: IE <=9 - 11 only
                // Style of cloned element affects source element cloned (#8908)
                div.style.backgroundClip = "content-box";
                div.cloneNode(true).style.backgroundClip = "";
                support.clearCloneStyle = div.style.backgroundClip === "content-box";

                container.style.cssText = "border:0;width:8px;height:0;top:0;left:-9999px;" +
                    "padding:0;margin-top:1px;position:absolute";
                container.appendChild(div);

                jQuery.extend(support, {
                    pixelPosition: function() {
                        computeStyleTests();
                        return pixelPositionVal;
                    },
                    boxSizingReliable: function() {
                        computeStyleTests();
                        return boxSizingReliableVal;
                    },
                    pixelMarginRight: function() {
                        computeStyleTests();
                        return pixelMarginRightVal;
                    },
                    reliableMarginLeft: function() {
                        computeStyleTests();
                        return reliableMarginLeftVal;
                    }
                });
            })();


            function curCSS(elem, name, computed) {
                var width, minWidth, maxWidth, ret,

                    // Support: Firefox 51+
                    // Retrieving style before computed somehow
                    // fixes an issue with getting wrong values
                    // on detached elements
                    style = elem.style;

                computed = computed || getStyles(elem);

                // getPropertyValue is needed for:
                //   .css('filter') (IE 9 only, #12537)
                //   .css('--customProperty) (#3144)
                if (computed) {
                    ret = computed.getPropertyValue(name) || computed[name];

                    if (ret === "" && !jQuery.contains(elem.ownerDocument, elem)) {
                        ret = jQuery.style(elem, name);
                    }

                    // A tribute to the "awesome hack by Dean Edwards"
                    // Android Browser returns percentage for some values,
                    // but width seems to be reliably pixels.
                    // This is against the CSSOM draft spec:
                    // https://drafts.csswg.org/cssom/#resolved-values
                    if (!support.pixelMarginRight() && rnumnonpx.test(ret) && rmargin.test(name)) {

                        // Remember the original values
                        width = style.width;
                        minWidth = style.minWidth;
                        maxWidth = style.maxWidth;

                        // Put in the new values to get a computed value out
                        style.minWidth = style.maxWidth = style.width = ret;
                        ret = computed.width;

                        // Revert the changed values
                        style.width = width;
                        style.minWidth = minWidth;
                        style.maxWidth = maxWidth;
                    }
                }

                return ret !== undefined ?

                    // Support: IE <=9 - 11 only
                    // IE returns zIndex value as an integer.
                    ret + "" :
                    ret;
            }


            function addGetHookIf(conditionFn, hookFn) {

                // Define the hook, we'll check on the first run if it's really needed.
                return {
                    get: function() {
                        if (conditionFn()) {

                            // Hook not needed (or it's not possible to use it due
                            // to missing dependency), remove it.
                            delete this.get;
                            return;
                        }

                        // Hook needed; redefine it so that the support test is not executed again.
                        return (this.get = hookFn).apply(this, arguments);
                    }
                };
            }


            var

            // Swappable if display is none or starts with table
            // except "table", "table-cell", or "table-caption"
            // See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
                rdisplayswap = /^(none|table(?!-c[ea]).+)/,
                rcustomProp = /^--/,
                cssShow = {
                    position: "absolute",
                    visibility: "hidden",
                    display: "block"
                },
                cssNormalTransform = {
                    letterSpacing: "0",
                    fontWeight: "400"
                },

                cssPrefixes = ["Webkit", "Moz", "ms"],
                emptyStyle = document.createElement("div").style;

            // Return a css property mapped to a potentially vendor prefixed property
            function vendorPropName(name) {

                // Shortcut for names that are not vendor prefixed
                if (name in emptyStyle) {
                    return name;
                }

                // Check for vendor prefixed names
                var capName = name[0].toUpperCase() + name.slice(1),
                    i = cssPrefixes.length;

                while (i--) {
                    name = cssPrefixes[i] + capName;
                    if (name in emptyStyle) {
                        return name;
                    }
                }
            }

            // Return a property mapped along what jQuery.cssProps suggests or to
            // a vendor prefixed property.
            function finalPropName(name) {
                var ret = jQuery.cssProps[name];
                if (!ret) {
                    ret = jQuery.cssProps[name] = vendorPropName(name) || name;
                }
                return ret;
            }

            function setPositiveNumber(elem, value, subtract) {

                // Any relative (+/-) values have already been
                // normalized at this point
                var matches = rcssNum.exec(value);
                return matches ?

                    // Guard against undefined "subtract", e.g., when used as in cssHooks
                    Math.max(0, matches[2] - (subtract || 0)) + (matches[3] || "px") :
                    value;
            }

            function augmentWidthOrHeight(elem, name, extra, isBorderBox, styles) {
                var i,
                    val = 0;

                // If we already have the right measurement, avoid augmentation
                if (extra === (isBorderBox ? "border" : "content")) {
                    i = 4;

                    // Otherwise initialize for horizontal or vertical properties
                } else {
                    i = name === "width" ? 1 : 0;
                }

                for (; i < 4; i += 2) {

                    // Both box models exclude margin, so add it if we want it
                    if (extra === "margin") {
                        val += jQuery.css(elem, extra + cssExpand[i], true, styles);
                    }

                    if (isBorderBox) {

                        // border-box includes padding, so remove it if we want content
                        if (extra === "content") {
                            val -= jQuery.css(elem, "padding" + cssExpand[i], true, styles);
                        }

                        // At this point, extra isn't border nor margin, so remove border
                        if (extra !== "margin") {
                            val -= jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
                        }
                    } else {

                        // At this point, extra isn't content, so add padding
                        val += jQuery.css(elem, "padding" + cssExpand[i], true, styles);

                        // At this point, extra isn't content nor padding, so add border
                        if (extra !== "padding") {
                            val += jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
                        }
                    }
                }

                return val;
            }

            function getWidthOrHeight(elem, name, extra) {

                // Start with computed style
                var valueIsBorderBox,
                    styles = getStyles(elem),
                    val = curCSS(elem, name, styles),
                    isBorderBox = jQuery.css(elem, "boxSizing", false, styles) === "border-box";

                // Computed unit is not pixels. Stop here and return.
                if (rnumnonpx.test(val)) {
                    return val;
                }

                // Check for style in case a browser which returns unreliable values
                // for getComputedStyle silently falls back to the reliable elem.style
                valueIsBorderBox = isBorderBox &&
                    (support.boxSizingReliable() || val === elem.style[name]);

                // Fall back to offsetWidth/Height when value is "auto"
                // This happens for inline elements with no explicit setting (gh-3571)
                if (val === "auto") {
                    val = elem["offset" + name[0].toUpperCase() + name.slice(1)];
                }

                // Normalize "", auto, and prepare for extra
                val = parseFloat(val) || 0;

                // Use the active box-sizing model to add/subtract irrelevant styles
                return (val +
                    augmentWidthOrHeight(
                        elem,
                        name,
                        extra || (isBorderBox ? "border" : "content"),
                        valueIsBorderBox,
                        styles
                    )
                ) + "px";
            }

            jQuery.extend({

                // Add in style property hooks for overriding the default
                // behavior of getting and setting a style property
                cssHooks: {
                    opacity: {
                        get: function(elem, computed) {
                            if (computed) {

                                // We should always get a number back from opacity
                                var ret = curCSS(elem, "opacity");
                                return ret === "" ? "1" : ret;
                            }
                        }
                    }
                },

                // Don't automatically add "px" to these possibly-unitless properties
                cssNumber: {
                    "animationIterationCount": true,
                    "columnCount": true,
                    "fillOpacity": true,
                    "flexGrow": true,
                    "flexShrink": true,
                    "fontWeight": true,
                    "lineHeight": true,
                    "opacity": true,
                    "order": true,
                    "orphans": true,
                    "widows": true,
                    "zIndex": true,
                    "zoom": true
                },

                // Add in properties whose names you wish to fix before
                // setting or getting the value
                cssProps: {
                    "float": "cssFloat"
                },

                // Get and set the style property on a DOM Node
                style: function(elem, name, value, extra) {

                    // Don't set styles on text and comment nodes
                    if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {
                        return;
                    }

                    // Make sure that we're working with the right name
                    var ret, type, hooks,
                        origName = jQuery.camelCase(name),
                        isCustomProp = rcustomProp.test(name),
                        style = elem.style;

                    // Make sure that we're working with the right name. We don't
                    // want to query the value if it is a CSS custom property
                    // since they are user-defined.
                    if (!isCustomProp) {
                        name = finalPropName(origName);
                    }

                    // Gets hook for the prefixed version, then unprefixed version
                    hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];

                    // Check if we're setting a value
                    if (value !== undefined) {
                        type = typeof value;

                        // Convert "+=" or "-=" to relative numbers (#7345)
                        if (type === "string" && (ret = rcssNum.exec(value)) && ret[1]) {
                            value = adjustCSS(elem, name, ret);

                            // Fixes bug #9237
                            type = "number";
                        }

                        // Make sure that null and NaN values aren't set (#7116)
                        if (value == null || value !== value) {
                            return;
                        }

                        // If a number was passed in, add the unit (except for certain CSS properties)
                        if (type === "number") {
                            value += ret && ret[3] || (jQuery.cssNumber[origName] ? "" : "px");
                        }

                        // background-* props affect original clone's values
                        if (!support.clearCloneStyle && value === "" && name.indexOf("background") === 0) {
                            style[name] = "inherit";
                        }

                        // If a hook was provided, use that value, otherwise just set the specified value
                        if (!hooks || !("set" in hooks) ||
                            (value = hooks.set(elem, value, extra)) !== undefined) {

                            if (isCustomProp) {
                                style.setProperty(name, value);
                            } else {
                                style[name] = value;
                            }
                        }

                    } else {

                        // If a hook was provided get the non-computed value from there
                        if (hooks && "get" in hooks &&
                            (ret = hooks.get(elem, false, extra)) !== undefined) {

                            return ret;
                        }

                        // Otherwise just get the value from the style object
                        return style[name];
                    }
                },

                css: function(elem, name, extra, styles) {
                    var val, num, hooks,
                        origName = jQuery.camelCase(name),
                        isCustomProp = rcustomProp.test(name);

                    // Make sure that we're working with the right name. We don't
                    // want to modify the value if it is a CSS custom property
                    // since they are user-defined.
                    if (!isCustomProp) {
                        name = finalPropName(origName);
                    }

                    // Try prefixed name followed by the unprefixed name
                    hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];

                    // If a hook was provided get the computed value from there
                    if (hooks && "get" in hooks) {
                        val = hooks.get(elem, true, extra);
                    }

                    // Otherwise, if a way to get the computed value exists, use that
                    if (val === undefined) {
                        val = curCSS(elem, name, styles);
                    }

                    // Convert "normal" to computed value
                    if (val === "normal" && name in cssNormalTransform) {
                        val = cssNormalTransform[name];
                    }

                    // Make numeric if forced or a qualifier was provided and val looks numeric
                    if (extra === "" || extra) {
                        num = parseFloat(val);
                        return extra === true || isFinite(num) ? num || 0 : val;
                    }

                    return val;
                }
            });

            jQuery.each(["height", "width"], function(i, name) {
                jQuery.cssHooks[name] = {
                    get: function(elem, computed, extra) {
                        if (computed) {

                            // Certain elements can have dimension info if we invisibly show them
                            // but it must have a current display style that would benefit
                            return rdisplayswap.test(jQuery.css(elem, "display")) &&

                                // Support: Safari 8+
                                // Table columns in Safari have non-zero offsetWidth & zero
                                // getBoundingClientRect().width unless display is changed.
                                // Support: IE <=11 only
                                // Running getBoundingClientRect on a disconnected node
                                // in IE throws an error.
                                (!elem.getClientRects().length || !elem.getBoundingClientRect().width) ?
                                swap(elem, cssShow, function() {
                                    return getWidthOrHeight(elem, name, extra);
                                }) :
                                getWidthOrHeight(elem, name, extra);
                        }
                    },

                    set: function(elem, value, extra) {
                        var matches,
                            styles = extra && getStyles(elem),
                            subtract = extra && augmentWidthOrHeight(
                                elem,
                                name,
                                extra,
                                jQuery.css(elem, "boxSizing", false, styles) === "border-box",
                                styles
                            );

                        // Convert to pixels if value adjustment is needed
                        if (subtract && (matches = rcssNum.exec(value)) &&
                            (matches[3] || "px") !== "px") {

                            elem.style[name] = value;
                            value = jQuery.css(elem, name);
                        }

                        return setPositiveNumber(elem, value, subtract);
                    }
                };
            });

            jQuery.cssHooks.marginLeft = addGetHookIf(support.reliableMarginLeft,
                function(elem, computed) {
                    if (computed) {
                        return (parseFloat(curCSS(elem, "marginLeft")) ||
                            elem.getBoundingClientRect().left -
                            swap(elem, {
                                marginLeft: 0
                            }, function() {
                                return elem.getBoundingClientRect().left;
                            })
                        ) + "px";
                    }
                }
            );

            // These hooks are used by animate to expand properties
            jQuery.each({
                margin: "",
                padding: "",
                border: "Width"
            }, function(prefix, suffix) {
                jQuery.cssHooks[prefix + suffix] = {
                    expand: function(value) {
                        var i = 0,
                            expanded = {},

                            // Assumes a single number if not a string
                            parts = typeof value === "string" ? value.split(" ") : [value];

                        for (; i < 4; i++) {
                            expanded[prefix + cssExpand[i] + suffix] =
                                parts[i] || parts[i - 2] || parts[0];
                        }

                        return expanded;
                    }
                };

                if (!rmargin.test(prefix)) {
                    jQuery.cssHooks[prefix + suffix].set = setPositiveNumber;
                }
            });

            jQuery.fn.extend({
                css: function(name, value) {
                    return access(this, function(elem, name, value) {
                        var styles, len,
                            map = {},
                            i = 0;

                        if (Array.isArray(name)) {
                            styles = getStyles(elem);
                            len = name.length;

                            for (; i < len; i++) {
                                map[name[i]] = jQuery.css(elem, name[i], false, styles);
                            }

                            return map;
                        }

                        return value !== undefined ?
                            jQuery.style(elem, name, value) :
                            jQuery.css(elem, name);
                    }, name, value, arguments.length > 1);
                }
            });


            function Tween(elem, options, prop, end, easing) {
                return new Tween.prototype.init(elem, options, prop, end, easing);
            }
            jQuery.Tween = Tween;

            Tween.prototype = {
                constructor: Tween,
                init: function(elem, options, prop, end, easing, unit) {
                    this.elem = elem;
                    this.prop = prop;
                    this.easing = easing || jQuery.easing._default;
                    this.options = options;
                    this.start = this.now = this.cur();
                    this.end = end;
                    this.unit = unit || (jQuery.cssNumber[prop] ? "" : "px");
                },
                cur: function() {
                    var hooks = Tween.propHooks[this.prop];

                    return hooks && hooks.get ?
                        hooks.get(this) :
                        Tween.propHooks._default.get(this);
                },
                run: function(percent) {
                    var eased,
                        hooks = Tween.propHooks[this.prop];

                    if (this.options.duration) {
                        this.pos = eased = jQuery.easing[this.easing](
                            percent, this.options.duration * percent, 0, 1, this.options.duration
                        );
                    } else {
                        this.pos = eased = percent;
                    }
                    this.now = (this.end - this.start) * eased + this.start;

                    if (this.options.step) {
                        this.options.step.call(this.elem, this.now, this);
                    }

                    if (hooks && hooks.set) {
                        hooks.set(this);
                    } else {
                        Tween.propHooks._default.set(this);
                    }
                    return this;
                }
            };

            Tween.prototype.init.prototype = Tween.prototype;

            Tween.propHooks = {
                _default: {
                    get: function(tween) {
                        var result;

                        // Use a property on the element directly when it is not a DOM element,
                        // or when there is no matching style property that exists.
                        if (tween.elem.nodeType !== 1 ||
                            tween.elem[tween.prop] != null && tween.elem.style[tween.prop] == null) {
                            return tween.elem[tween.prop];
                        }

                        // Passing an empty string as a 3rd parameter to .css will automatically
                        // attempt a parseFloat and fallback to a string if the parse fails.
                        // Simple values such as "10px" are parsed to Float;
                        // complex values such as "rotate(1rad)" are returned as-is.
                        result = jQuery.css(tween.elem, tween.prop, "");

                        // Empty strings, null, undefined and "auto" are converted to 0.
                        return !result || result === "auto" ? 0 : result;
                    },
                    set: function(tween) {

                        // Use step hook for back compat.
                        // Use cssHook if its there.
                        // Use .style if available and use plain properties where available.
                        if (jQuery.fx.step[tween.prop]) {
                            jQuery.fx.step[tween.prop](tween);
                        } else if (tween.elem.nodeType === 1 &&
                            (tween.elem.style[jQuery.cssProps[tween.prop]] != null ||
                                jQuery.cssHooks[tween.prop])) {
                            jQuery.style(tween.elem, tween.prop, tween.now + tween.unit);
                        } else {
                            tween.elem[tween.prop] = tween.now;
                        }
                    }
                }
            };

            // Support: IE <=9 only
            // Panic based approach to setting things on disconnected nodes
            Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
                set: function(tween) {
                    if (tween.elem.nodeType && tween.elem.parentNode) {
                        tween.elem[tween.prop] = tween.now;
                    }
                }
            };

            jQuery.easing = {
                linear: function(p) {
                    return p;
                },
                swing: function(p) {
                    return 0.5 - Math.cos(p * Math.PI) / 2;
                },
                _default: "swing"
            };

            jQuery.fx = Tween.prototype.init;

            // Back compat <1.8 extension point
            jQuery.fx.step = {};




            var
                fxNow, inProgress,
                rfxtypes = /^(?:toggle|show|hide)$/,
                rrun = /queueHooks$/;

            function schedule() {
                if (inProgress) {
                    if (document.hidden === false && window.requestAnimationFrame) {
                        window.requestAnimationFrame(schedule);
                    } else {
                        window.setTimeout(schedule, jQuery.fx.interval);
                    }

                    jQuery.fx.tick();
                }
            }

            // Animations created synchronously will run synchronously
            function createFxNow() {
                window.setTimeout(function() {
                    fxNow = undefined;
                });
                return (fxNow = jQuery.now());
            }

            // Generate parameters to create a standard animation
            function genFx(type, includeWidth) {
                var which,
                    i = 0,
                    attrs = {
                        height: type
                    };

                // If we include width, step value is 1 to do all cssExpand values,
                // otherwise step value is 2 to skip over Left and Right
                includeWidth = includeWidth ? 1 : 0;
                for (; i < 4; i += 2 - includeWidth) {
                    which = cssExpand[i];
                    attrs["margin" + which] = attrs["padding" + which] = type;
                }

                if (includeWidth) {
                    attrs.opacity = attrs.width = type;
                }

                return attrs;
            }

            function createTween(value, prop, animation) {
                var tween,
                    collection = (Animation.tweeners[prop] || []).concat(Animation.tweeners["*"]),
                    index = 0,
                    length = collection.length;
                for (; index < length; index++) {
                    if ((tween = collection[index].call(animation, prop, value))) {

                        // We're done with this property
                        return tween;
                    }
                }
            }

            function defaultPrefilter(elem, props, opts) {
                var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display,
                    isBox = "width" in props || "height" in props,
                    anim = this,
                    orig = {},
                    style = elem.style,
                    hidden = elem.nodeType && isHiddenWithinTree(elem),
                    dataShow = dataPriv.get(elem, "fxshow");

                // Queue-skipping animations hijack the fx hooks
                if (!opts.queue) {
                    hooks = jQuery._queueHooks(elem, "fx");
                    if (hooks.unqueued == null) {
                        hooks.unqueued = 0;
                        oldfire = hooks.empty.fire;
                        hooks.empty.fire = function() {
                            if (!hooks.unqueued) {
                                oldfire();
                            }
                        };
                    }
                    hooks.unqueued++;

                    anim.always(function() {

                        // Ensure the complete handler is called before this completes
                        anim.always(function() {
                            hooks.unqueued--;
                            if (!jQuery.queue(elem, "fx").length) {
                                hooks.empty.fire();
                            }
                        });
                    });
                }

                // Detect show/hide animations
                for (prop in props) {
                    value = props[prop];
                    if (rfxtypes.test(value)) {
                        delete props[prop];
                        toggle = toggle || value === "toggle";
                        if (value === (hidden ? "hide" : "show")) {

                            // Pretend to be hidden if this is a "show" and
                            // there is still data from a stopped show/hide
                            if (value === "show" && dataShow && dataShow[prop] !== undefined) {
                                hidden = true;

                                // Ignore all other no-op show/hide data
                            } else {
                                continue;
                            }
                        }
                        orig[prop] = dataShow && dataShow[prop] || jQuery.style(elem, prop);
                    }
                }

                // Bail out if this is a no-op like .hide().hide()
                propTween = !jQuery.isEmptyObject(props);
                if (!propTween && jQuery.isEmptyObject(orig)) {
                    return;
                }

                // Restrict "overflow" and "display" styles during box animations
                if (isBox && elem.nodeType === 1) {

                    // Support: IE <=9 - 11, Edge 12 - 13
                    // Record all 3 overflow attributes because IE does not infer the shorthand
                    // from identically-valued overflowX and overflowY
                    opts.overflow = [style.overflow, style.overflowX, style.overflowY];

                    // Identify a display type, preferring old show/hide data over the CSS cascade
                    restoreDisplay = dataShow && dataShow.display;
                    if (restoreDisplay == null) {
                        restoreDisplay = dataPriv.get(elem, "display");
                    }
                    display = jQuery.css(elem, "display");
                    if (display === "none") {
                        if (restoreDisplay) {
                            display = restoreDisplay;
                        } else {

                            // Get nonempty value(s) by temporarily forcing visibility
                            showHide([elem], true);
                            restoreDisplay = elem.style.display || restoreDisplay;
                            display = jQuery.css(elem, "display");
                            showHide([elem]);
                        }
                    }

                    // Animate inline elements as inline-block
                    if (display === "inline" || display === "inline-block" && restoreDisplay != null) {
                        if (jQuery.css(elem, "float") === "none") {

                            // Restore the original display value at the end of pure show/hide animations
                            if (!propTween) {
                                anim.done(function() {
                                    style.display = restoreDisplay;
                                });
                                if (restoreDisplay == null) {
                                    display = style.display;
                                    restoreDisplay = display === "none" ? "" : display;
                                }
                            }
                            style.display = "inline-block";
                        }
                    }
                }

                if (opts.overflow) {
                    style.overflow = "hidden";
                    anim.always(function() {
                        style.overflow = opts.overflow[0];
                        style.overflowX = opts.overflow[1];
                        style.overflowY = opts.overflow[2];
                    });
                }

                // Implement show/hide animations
                propTween = false;
                for (prop in orig) {

                    // General show/hide setup for this element animation
                    if (!propTween) {
                        if (dataShow) {
                            if ("hidden" in dataShow) {
                                hidden = dataShow.hidden;
                            }
                        } else {
                            dataShow = dataPriv.access(elem, "fxshow", {
                                display: restoreDisplay
                            });
                        }

                        // Store hidden/visible for toggle so `.stop().toggle()` "reverses"
                        if (toggle) {
                            dataShow.hidden = !hidden;
                        }

                        // Show elements before animating them
                        if (hidden) {
                            showHide([elem], true);
                        }

                        /* eslint-disable no-loop-func */

                        anim.done(function() {

                            /* eslint-enable no-loop-func */

                            // The final step of a "hide" animation is actually hiding the element
                            if (!hidden) {
                                showHide([elem]);
                            }
                            dataPriv.remove(elem, "fxshow");
                            for (prop in orig) {
                                jQuery.style(elem, prop, orig[prop]);
                            }
                        });
                    }

                    // Per-property setup
                    propTween = createTween(hidden ? dataShow[prop] : 0, prop, anim);
                    if (!(prop in dataShow)) {
                        dataShow[prop] = propTween.start;
                        if (hidden) {
                            propTween.end = propTween.start;
                            propTween.start = 0;
                        }
                    }
                }
            }

            function propFilter(props, specialEasing) {
                var index, name, easing, value, hooks;

                // camelCase, specialEasing and expand cssHook pass
                for (index in props) {
                    name = jQuery.camelCase(index);
                    easing = specialEasing[name];
                    value = props[index];
                    if (Array.isArray(value)) {
                        easing = value[1];
                        value = props[index] = value[0];
                    }

                    if (index !== name) {
                        props[name] = value;
                        delete props[index];
                    }

                    hooks = jQuery.cssHooks[name];
                    if (hooks && "expand" in hooks) {
                        value = hooks.expand(value);
                        delete props[name];

                        // Not quite $.extend, this won't overwrite existing keys.
                        // Reusing 'index' because we have the correct "name"
                        for (index in value) {
                            if (!(index in props)) {
                                props[index] = value[index];
                                specialEasing[index] = easing;
                            }
                        }
                    } else {
                        specialEasing[name] = easing;
                    }
                }
            }

            function Animation(elem, properties, options) {
                var result,
                    stopped,
                    index = 0,
                    length = Animation.prefilters.length,
                    deferred = jQuery.Deferred().always(function() {

                        // Don't match elem in the :animated selector
                        delete tick.elem;
                    }),
                    tick = function() {
                        if (stopped) {
                            return false;
                        }
                        var currentTime = fxNow || createFxNow(),
                            remaining = Math.max(0, animation.startTime + animation.duration - currentTime),

                            // Support: Android 2.3 only
                            // Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
                            temp = remaining / animation.duration || 0,
                            percent = 1 - temp,
                            index = 0,
                            length = animation.tweens.length;

                        for (; index < length; index++) {
                            animation.tweens[index].run(percent);
                        }

                        deferred.notifyWith(elem, [animation, percent, remaining]);

                        // If there's more to do, yield
                        if (percent < 1 && length) {
                            return remaining;
                        }

                        // If this was an empty animation, synthesize a final progress notification
                        if (!length) {
                            deferred.notifyWith(elem, [animation, 1, 0]);
                        }

                        // Resolve the animation and report its conclusion
                        deferred.resolveWith(elem, [animation]);
                        return false;
                    },
                    animation = deferred.promise({
                        elem: elem,
                        props: jQuery.extend({}, properties),
                        opts: jQuery.extend(true, {
                            specialEasing: {},
                            easing: jQuery.easing._default
                        }, options),
                        originalProperties: properties,
                        originalOptions: options,
                        startTime: fxNow || createFxNow(),
                        duration: options.duration,
                        tweens: [],
                        createTween: function(prop, end) {
                            var tween = jQuery.Tween(elem, animation.opts, prop, end,
                                animation.opts.specialEasing[prop] || animation.opts.easing);
                            animation.tweens.push(tween);
                            return tween;
                        },
                        stop: function(gotoEnd) {
                            var index = 0,

                                // If we are going to the end, we want to run all the tweens
                                // otherwise we skip this part
                                length = gotoEnd ? animation.tweens.length : 0;
                            if (stopped) {
                                return this;
                            }
                            stopped = true;
                            for (; index < length; index++) {
                                animation.tweens[index].run(1);
                            }

                            // Resolve when we played the last frame; otherwise, reject
                            if (gotoEnd) {
                                deferred.notifyWith(elem, [animation, 1, 0]);
                                deferred.resolveWith(elem, [animation, gotoEnd]);
                            } else {
                                deferred.rejectWith(elem, [animation, gotoEnd]);
                            }
                            return this;
                        }
                    }),
                    props = animation.props;

                propFilter(props, animation.opts.specialEasing);

                for (; index < length; index++) {
                    result = Animation.prefilters[index].call(animation, elem, props, animation.opts);
                    if (result) {
                        if (jQuery.isFunction(result.stop)) {
                            jQuery._queueHooks(animation.elem, animation.opts.queue).stop =
                                jQuery.proxy(result.stop, result);
                        }
                        return result;
                    }
                }

                jQuery.map(props, createTween, animation);

                if (jQuery.isFunction(animation.opts.start)) {
                    animation.opts.start.call(elem, animation);
                }

                // Attach callbacks from options
                animation
                    .progress(animation.opts.progress)
                    .done(animation.opts.done, animation.opts.complete)
                    .fail(animation.opts.fail)
                    .always(animation.opts.always);

                jQuery.fx.timer(
                    jQuery.extend(tick, {
                        elem: elem,
                        anim: animation,
                        queue: animation.opts.queue
                    })
                );

                return animation;
            }

            jQuery.Animation = jQuery.extend(Animation, {

                tweeners: {
                    "*": [function(prop, value) {
                        var tween = this.createTween(prop, value);
                        adjustCSS(tween.elem, prop, rcssNum.exec(value), tween);
                        return tween;
                    }]
                },

                tweener: function(props, callback) {
                    if (jQuery.isFunction(props)) {
                        callback = props;
                        props = ["*"];
                    } else {
                        props = props.match(rnothtmlwhite);
                    }

                    var prop,
                        index = 0,
                        length = props.length;

                    for (; index < length; index++) {
                        prop = props[index];
                        Animation.tweeners[prop] = Animation.tweeners[prop] || [];
                        Animation.tweeners[prop].unshift(callback);
                    }
                },

                prefilters: [defaultPrefilter],

                prefilter: function(callback, prepend) {
                    if (prepend) {
                        Animation.prefilters.unshift(callback);
                    } else {
                        Animation.prefilters.push(callback);
                    }
                }
            });

            jQuery.speed = function(speed, easing, fn) {
                var opt = speed && typeof speed === "object" ? jQuery.extend({}, speed) : {
                    complete: fn || !fn && easing ||
                        jQuery.isFunction(speed) && speed,
                    duration: speed,
                    easing: fn && easing || easing && !jQuery.isFunction(easing) && easing
                };

                // Go to the end state if fx are off
                if (jQuery.fx.off) {
                    opt.duration = 0;

                } else {
                    if (typeof opt.duration !== "number") {
                        if (opt.duration in jQuery.fx.speeds) {
                            opt.duration = jQuery.fx.speeds[opt.duration];

                        } else {
                            opt.duration = jQuery.fx.speeds._default;
                        }
                    }
                }

                // Normalize opt.queue - true/undefined/null -> "fx"
                if (opt.queue == null || opt.queue === true) {
                    opt.queue = "fx";
                }

                // Queueing
                opt.old = opt.complete;

                opt.complete = function() {
                    if (jQuery.isFunction(opt.old)) {
                        opt.old.call(this);
                    }

                    if (opt.queue) {
                        jQuery.dequeue(this, opt.queue);
                    }
                };

                return opt;
            };

            jQuery.fn.extend({
                fadeTo: function(speed, to, easing, callback) {

                    // Show any hidden elements after setting opacity to 0
                    return this.filter(isHiddenWithinTree).css("opacity", 0).show()

                    // Animate to the value specified
                    .end().animate({
                        opacity: to
                    }, speed, easing, callback);
                },
                animate: function(prop, speed, easing, callback) {
                    var empty = jQuery.isEmptyObject(prop),
                        optall = jQuery.speed(speed, easing, callback),
                        doAnimation = function() {

                            // Operate on a copy of prop so per-property easing won't be lost
                            var anim = Animation(this, jQuery.extend({}, prop), optall);

                            // Empty animations, or finishing resolves immediately
                            if (empty || dataPriv.get(this, "finish")) {
                                anim.stop(true);
                            }
                        };
                    doAnimation.finish = doAnimation;

                    return empty || optall.queue === false ?
                        this.each(doAnimation) :
                        this.queue(optall.queue, doAnimation);
                },
                stop: function(type, clearQueue, gotoEnd) {
                    var stopQueue = function(hooks) {
                        var stop = hooks.stop;
                        delete hooks.stop;
                        stop(gotoEnd);
                    };

                    if (typeof type !== "string") {
                        gotoEnd = clearQueue;
                        clearQueue = type;
                        type = undefined;
                    }
                    if (clearQueue && type !== false) {
                        this.queue(type || "fx", []);
                    }

                    return this.each(function() {
                        var dequeue = true,
                            index = type != null && type + "queueHooks",
                            timers = jQuery.timers,
                            data = dataPriv.get(this);

                        if (index) {
                            if (data[index] && data[index].stop) {
                                stopQueue(data[index]);
                            }
                        } else {
                            for (index in data) {
                                if (data[index] && data[index].stop && rrun.test(index)) {
                                    stopQueue(data[index]);
                                }
                            }
                        }

                        for (index = timers.length; index--;) {
                            if (timers[index].elem === this &&
                                (type == null || timers[index].queue === type)) {

                                timers[index].anim.stop(gotoEnd);
                                dequeue = false;
                                timers.splice(index, 1);
                            }
                        }

                        // Start the next in the queue if the last step wasn't forced.
                        // Timers currently will call their complete callbacks, which
                        // will dequeue but only if they were gotoEnd.
                        if (dequeue || !gotoEnd) {
                            jQuery.dequeue(this, type);
                        }
                    });
                },
                finish: function(type) {
                    if (type !== false) {
                        type = type || "fx";
                    }
                    return this.each(function() {
                        var index,
                            data = dataPriv.get(this),
                            queue = data[type + "queue"],
                            hooks = data[type + "queueHooks"],
                            timers = jQuery.timers,
                            length = queue ? queue.length : 0;

                        // Enable finishing flag on private data
                        data.finish = true;

                        // Empty the queue first
                        jQuery.queue(this, type, []);

                        if (hooks && hooks.stop) {
                            hooks.stop.call(this, true);
                        }

                        // Look for any active animations, and finish them
                        for (index = timers.length; index--;) {
                            if (timers[index].elem === this && timers[index].queue === type) {
                                timers[index].anim.stop(true);
                                timers.splice(index, 1);
                            }
                        }

                        // Look for any animations in the old queue and finish them
                        for (index = 0; index < length; index++) {
                            if (queue[index] && queue[index].finish) {
                                queue[index].finish.call(this);
                            }
                        }

                        // Turn off finishing flag
                        delete data.finish;
                    });
                }
            });

            jQuery.each(["toggle", "show", "hide"], function(i, name) {
                var cssFn = jQuery.fn[name];
                jQuery.fn[name] = function(speed, easing, callback) {
                    return speed == null || typeof speed === "boolean" ?
                        cssFn.apply(this, arguments) :
                        this.animate(genFx(name, true), speed, easing, callback);
                };
            });

            // Generate shortcuts for custom animations
            jQuery.each({
                slideDown: genFx("show"),
                slideUp: genFx("hide"),
                slideToggle: genFx("toggle"),
                fadeIn: {
                    opacity: "show"
                },
                fadeOut: {
                    opacity: "hide"
                },
                fadeToggle: {
                    opacity: "toggle"
                }
            }, function(name, props) {
                jQuery.fn[name] = function(speed, easing, callback) {
                    return this.animate(props, speed, easing, callback);
                };
            });

            jQuery.timers = [];
            jQuery.fx.tick = function() {
                var timer,
                    i = 0,
                    timers = jQuery.timers;

                fxNow = jQuery.now();

                for (; i < timers.length; i++) {
                    timer = timers[i];

                    // Run the timer and safely remove it when done (allowing for external removal)
                    if (!timer() && timers[i] === timer) {
                        timers.splice(i--, 1);
                    }
                }

                if (!timers.length) {
                    jQuery.fx.stop();
                }
                fxNow = undefined;
            };

            jQuery.fx.timer = function(timer) {
                jQuery.timers.push(timer);
                jQuery.fx.start();
            };

            jQuery.fx.interval = 13;
            jQuery.fx.start = function() {
                if (inProgress) {
                    return;
                }

                inProgress = true;
                schedule();
            };

            jQuery.fx.stop = function() {
                inProgress = null;
            };

            jQuery.fx.speeds = {
                slow: 600,
                fast: 200,

                // Default speed
                _default: 400
            };


            // Based off of the plugin by Clint Helfers, with permission.
            // https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/
            jQuery.fn.delay = function(time, type) {
                time = jQuery.fx ? jQuery.fx.speeds[time] || time : time;
                type = type || "fx";

                return this.queue(type, function(next, hooks) {
                    var timeout = window.setTimeout(next, time);
                    hooks.stop = function() {
                        window.clearTimeout(timeout);
                    };
                });
            };


            (function() {
                var input = document.createElement("input"),
                    select = document.createElement("select"),
                    opt = select.appendChild(document.createElement("option"));

                input.type = "checkbox";

                // Support: Android <=4.3 only
                // Default value for a checkbox should be "on"
                support.checkOn = input.value !== "";

                // Support: IE <=11 only
                // Must access selectedIndex to make default options select
                support.optSelected = opt.selected;

                // Support: IE <=11 only
                // An input loses its value after becoming a radio
                input = document.createElement("input");
                input.value = "t";
                input.type = "radio";
                support.radioValue = input.value === "t";
            })();


            var boolHook,
                attrHandle = jQuery.expr.attrHandle;

            jQuery.fn.extend({
                attr: function(name, value) {
                    return access(this, jQuery.attr, name, value, arguments.length > 1);
                },

                removeAttr: function(name) {
                    return this.each(function() {
                        jQuery.removeAttr(this, name);
                    });
                }
            });

            jQuery.extend({
                attr: function(elem, name, value) {
                    var ret, hooks,
                        nType = elem.nodeType;

                    // Don't get/set attributes on text, comment and attribute nodes
                    if (nType === 3 || nType === 8 || nType === 2) {
                        return;
                    }

                    // Fallback to prop when attributes are not supported
                    if (typeof elem.getAttribute === "undefined") {
                        return jQuery.prop(elem, name, value);
                    }

                    // Attribute hooks are determined by the lowercase version
                    // Grab necessary hook if one is defined
                    if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
                        hooks = jQuery.attrHooks[name.toLowerCase()] ||
                            (jQuery.expr.match.bool.test(name) ? boolHook : undefined);
                    }

                    if (value !== undefined) {
                        if (value === null) {
                            jQuery.removeAttr(elem, name);
                            return;
                        }

                        if (hooks && "set" in hooks &&
                            (ret = hooks.set(elem, value, name)) !== undefined) {
                            return ret;
                        }

                        elem.setAttribute(name, value + "");
                        return value;
                    }

                    if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
                        return ret;
                    }

                    ret = jQuery.find.attr(elem, name);

                    // Non-existent attributes return null, we normalize to undefined
                    return ret == null ? undefined : ret;
                },

                attrHooks: {
                    type: {
                        set: function(elem, value) {
                            if (!support.radioValue && value === "radio" &&
                                nodeName(elem, "input")) {
                                var val = elem.value;
                                elem.setAttribute("type", value);
                                if (val) {
                                    elem.value = val;
                                }
                                return value;
                            }
                        }
                    }
                },

                removeAttr: function(elem, value) {
                    var name,
                        i = 0,

                        // Attribute names can contain non-HTML whitespace characters
                        // https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
                        attrNames = value && value.match(rnothtmlwhite);

                    if (attrNames && elem.nodeType === 1) {
                        while ((name = attrNames[i++])) {
                            elem.removeAttribute(name);
                        }
                    }
                }
            });

            // Hooks for boolean attributes
            boolHook = {
                set: function(elem, value, name) {
                    if (value === false) {

                        // Remove boolean attributes when set to false
                        jQuery.removeAttr(elem, name);
                    } else {
                        elem.setAttribute(name, name);
                    }
                    return name;
                }
            };

            jQuery.each(jQuery.expr.match.bool.source.match(/\w+/g), function(i, name) {
                var getter = attrHandle[name] || jQuery.find.attr;

                attrHandle[name] = function(elem, name, isXML) {
                    var ret, handle,
                        lowercaseName = name.toLowerCase();

                    if (!isXML) {

                        // Avoid an infinite loop by temporarily removing this function from the getter
                        handle = attrHandle[lowercaseName];
                        attrHandle[lowercaseName] = ret;
                        ret = getter(elem, name, isXML) != null ?
                            lowercaseName :
                            null;
                        attrHandle[lowercaseName] = handle;
                    }
                    return ret;
                };
            });




            var rfocusable = /^(?:input|select|textarea|button)$/i,
                rclickable = /^(?:a|area)$/i;

            jQuery.fn.extend({
                prop: function(name, value) {
                    return access(this, jQuery.prop, name, value, arguments.length > 1);
                },

                removeProp: function(name) {
                    return this.each(function() {
                        delete this[jQuery.propFix[name] || name];
                    });
                }
            });

            jQuery.extend({
                prop: function(elem, name, value) {
                    var ret, hooks,
                        nType = elem.nodeType;

                    // Don't get/set properties on text, comment and attribute nodes
                    if (nType === 3 || nType === 8 || nType === 2) {
                        return;
                    }

                    if (nType !== 1 || !jQuery.isXMLDoc(elem)) {

                        // Fix name and attach hooks
                        name = jQuery.propFix[name] || name;
                        hooks = jQuery.propHooks[name];
                    }

                    if (value !== undefined) {
                        if (hooks && "set" in hooks &&
                            (ret = hooks.set(elem, value, name)) !== undefined) {
                            return ret;
                        }

                        return (elem[name] = value);
                    }

                    if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
                        return ret;
                    }

                    return elem[name];
                },

                propHooks: {
                    tabIndex: {
                        get: function(elem) {

                            // Support: IE <=9 - 11 only
                            // elem.tabIndex doesn't always return the
                            // correct value when it hasn't been explicitly set
                            // https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
                            // Use proper attribute retrieval(#12072)
                            var tabindex = jQuery.find.attr(elem, "tabindex");

                            if (tabindex) {
                                return parseInt(tabindex, 10);
                            }

                            if (
                                rfocusable.test(elem.nodeName) ||
                                rclickable.test(elem.nodeName) &&
                                elem.href
                            ) {
                                return 0;
                            }

                            return -1;
                        }
                    }
                },

                propFix: {
                    "for": "htmlFor",
                    "class": "className"
                }
            });

            // Support: IE <=11 only
            // Accessing the selectedIndex property
            // forces the browser to respect setting selected
            // on the option
            // The getter ensures a default option is selected
            // when in an optgroup
            // eslint rule "no-unused-expressions" is disabled for this code
            // since it considers such accessions noop
            if (!support.optSelected) {
                jQuery.propHooks.selected = {
                    get: function(elem) {

                        /* eslint no-unused-expressions: "off" */

                        var parent = elem.parentNode;
                        if (parent && parent.parentNode) {
                            parent.parentNode.selectedIndex;
                        }
                        return null;
                    },
                    set: function(elem) {

                        /* eslint no-unused-expressions: "off" */

                        var parent = elem.parentNode;
                        if (parent) {
                            parent.selectedIndex;

                            if (parent.parentNode) {
                                parent.parentNode.selectedIndex;
                            }
                        }
                    }
                };
            }

            jQuery.each([
                "tabIndex",
                "readOnly",
                "maxLength",
                "cellSpacing",
                "cellPadding",
                "rowSpan",
                "colSpan",
                "useMap",
                "frameBorder",
                "contentEditable"
            ], function() {
                jQuery.propFix[this.toLowerCase()] = this;
            });




            // Strip and collapse whitespace according to HTML spec
            // https://html.spec.whatwg.org/multipage/infrastructure.html#strip-and-collapse-whitespace
            function stripAndCollapse(value) {
                var tokens = value.match(rnothtmlwhite) || [];
                return tokens.join(" ");
            }


            function getClass(elem) {
                return elem.getAttribute && elem.getAttribute("class") || "";
            }

            jQuery.fn.extend({
                addClass: function(value) {
                    var classes, elem, cur, curValue, clazz, j, finalValue,
                        i = 0;

                    if (jQuery.isFunction(value)) {
                        return this.each(function(j) {
                            jQuery(this).addClass(value.call(this, j, getClass(this)));
                        });
                    }

                    if (typeof value === "string" && value) {
                        classes = value.match(rnothtmlwhite) || [];

                        while ((elem = this[i++])) {
                            curValue = getClass(elem);
                            cur = elem.nodeType === 1 && (" " + stripAndCollapse(curValue) + " ");

                            if (cur) {
                                j = 0;
                                while ((clazz = classes[j++])) {
                                    if (cur.indexOf(" " + clazz + " ") < 0) {
                                        cur += clazz + " ";
                                    }
                                }

                                // Only assign if different to avoid unneeded rendering.
                                finalValue = stripAndCollapse(cur);
                                if (curValue !== finalValue) {
                                    elem.setAttribute("class", finalValue);
                                }
                            }
                        }
                    }

                    return this;
                },

                removeClass: function(value) {
                    var classes, elem, cur, curValue, clazz, j, finalValue,
                        i = 0;

                    if (jQuery.isFunction(value)) {
                        return this.each(function(j) {
                            jQuery(this).removeClass(value.call(this, j, getClass(this)));
                        });
                    }

                    if (!arguments.length) {
                        return this.attr("class", "");
                    }

                    if (typeof value === "string" && value) {
                        classes = value.match(rnothtmlwhite) || [];

                        while ((elem = this[i++])) {
                            curValue = getClass(elem);

                            // This expression is here for better compressibility (see addClass)
                            cur = elem.nodeType === 1 && (" " + stripAndCollapse(curValue) + " ");

                            if (cur) {
                                j = 0;
                                while ((clazz = classes[j++])) {

                                    // Remove *all* instances
                                    while (cur.indexOf(" " + clazz + " ") > -1) {
                                        cur = cur.replace(" " + clazz + " ", " ");
                                    }
                                }

                                // Only assign if different to avoid unneeded rendering.
                                finalValue = stripAndCollapse(cur);
                                if (curValue !== finalValue) {
                                    elem.setAttribute("class", finalValue);
                                }
                            }
                        }
                    }

                    return this;
                },

                toggleClass: function(value, stateVal) {
                    var type = typeof value;

                    if (typeof stateVal === "boolean" && type === "string") {
                        return stateVal ? this.addClass(value) : this.removeClass(value);
                    }

                    if (jQuery.isFunction(value)) {
                        return this.each(function(i) {
                            jQuery(this).toggleClass(
                                value.call(this, i, getClass(this), stateVal),
                                stateVal
                            );
                        });
                    }

                    return this.each(function() {
                        var className, i, self, classNames;

                        if (type === "string") {

                            // Toggle individual class names
                            i = 0;
                            self = jQuery(this);
                            classNames = value.match(rnothtmlwhite) || [];

                            while ((className = classNames[i++])) {

                                // Check each className given, space separated list
                                if (self.hasClass(className)) {
                                    self.removeClass(className);
                                } else {
                                    self.addClass(className);
                                }
                            }

                            // Toggle whole class name
                        } else if (value === undefined || type === "boolean") {
                            className = getClass(this);
                            if (className) {

                                // Store className if set
                                dataPriv.set(this, "__className__", className);
                            }

                            // If the element has a class name or if we're passed `false`,
                            // then remove the whole classname (if there was one, the above saved it).
                            // Otherwise bring back whatever was previously saved (if anything),
                            // falling back to the empty string if nothing was stored.
                            if (this.setAttribute) {
                                this.setAttribute("class",
                                    className || value === false ?
                                    "" :
                                    dataPriv.get(this, "__className__") || ""
                                );
                            }
                        }
                    });
                },

                hasClass: function(selector) {
                    var className, elem,
                        i = 0;

                    className = " " + selector + " ";
                    while ((elem = this[i++])) {
                        if (elem.nodeType === 1 &&
                            (" " + stripAndCollapse(getClass(elem)) + " ").indexOf(className) > -1) {
                            return true;
                        }
                    }

                    return false;
                }
            });




            var rreturn = /\r/g;

            jQuery.fn.extend({
                val: function(value) {
                    var hooks, ret, isFunction,
                        elem = this[0];

                    if (!arguments.length) {
                        if (elem) {
                            hooks = jQuery.valHooks[elem.type] ||
                                jQuery.valHooks[elem.nodeName.toLowerCase()];

                            if (hooks &&
                                "get" in hooks &&
                                (ret = hooks.get(elem, "value")) !== undefined
                            ) {
                                return ret;
                            }

                            ret = elem.value;

                            // Handle most common string cases
                            if (typeof ret === "string") {
                                return ret.replace(rreturn, "");
                            }

                            // Handle cases where value is null/undef or number
                            return ret == null ? "" : ret;
                        }

                        return;
                    }

                    isFunction = jQuery.isFunction(value);

                    return this.each(function(i) {
                        var val;

                        if (this.nodeType !== 1) {
                            return;
                        }

                        if (isFunction) {
                            val = value.call(this, i, jQuery(this).val());
                        } else {
                            val = value;
                        }

                        // Treat null/undefined as ""; convert numbers to string
                        if (val == null) {
                            val = "";

                        } else if (typeof val === "number") {
                            val += "";

                        } else if (Array.isArray(val)) {
                            val = jQuery.map(val, function(value) {
                                return value == null ? "" : value + "";
                            });
                        }

                        hooks = jQuery.valHooks[this.type] || jQuery.valHooks[this.nodeName.toLowerCase()];

                        // If set returns undefined, fall back to normal setting
                        if (!hooks || !("set" in hooks) || hooks.set(this, val, "value") === undefined) {
                            this.value = val;
                        }
                    });
                }
            });

            jQuery.extend({
                valHooks: {
                    option: {
                        get: function(elem) {

                            var val = jQuery.find.attr(elem, "value");
                            return val != null ?
                                val :

                                // Support: IE <=10 - 11 only
                                // option.text throws exceptions (#14686, #14858)
                                // Strip and collapse whitespace
                                // https://html.spec.whatwg.org/#strip-and-collapse-whitespace
                                stripAndCollapse(jQuery.text(elem));
                        }
                    },
                    select: {
                        get: function(elem) {
                            var value, option, i,
                                options = elem.options,
                                index = elem.selectedIndex,
                                one = elem.type === "select-one",
                                values = one ? null : [],
                                max = one ? index + 1 : options.length;

                            if (index < 0) {
                                i = max;

                            } else {
                                i = one ? index : 0;
                            }

                            // Loop through all the selected options
                            for (; i < max; i++) {
                                option = options[i];

                                // Support: IE <=9 only
                                // IE8-9 doesn't update selected after form reset (#2551)
                                if ((option.selected || i === index) &&

                                    // Don't return options that are disabled or in a disabled optgroup
                                    !option.disabled &&
                                    (!option.parentNode.disabled ||
                                        !nodeName(option.parentNode, "optgroup"))) {

                                    // Get the specific value for the option
                                    value = jQuery(option).val();

                                    // We don't need an array for one selects
                                    if (one) {
                                        return value;
                                    }

                                    // Multi-Selects return an array
                                    values.push(value);
                                }
                            }

                            return values;
                        },

                        set: function(elem, value) {
                            var optionSet, option,
                                options = elem.options,
                                values = jQuery.makeArray(value),
                                i = options.length;

                            while (i--) {
                                option = options[i];

                                /* eslint-disable no-cond-assign */

                                if (option.selected =
                                    jQuery.inArray(jQuery.valHooks.option.get(option), values) > -1
                                ) {
                                    optionSet = true;
                                }

                                /* eslint-enable no-cond-assign */
                            }

                            // Force browsers to behave consistently when non-matching value is set
                            if (!optionSet) {
                                elem.selectedIndex = -1;
                            }
                            return values;
                        }
                    }
                }
            });

            // Radios and checkboxes getter/setter
            jQuery.each(["radio", "checkbox"], function() {
                jQuery.valHooks[this] = {
                    set: function(elem, value) {
                        if (Array.isArray(value)) {
                            return (elem.checked = jQuery.inArray(jQuery(elem).val(), value) > -1);
                        }
                    }
                };
                if (!support.checkOn) {
                    jQuery.valHooks[this].get = function(elem) {
                        return elem.getAttribute("value") === null ? "on" : elem.value;
                    };
                }
            });




            // Return jQuery for attributes-only inclusion


            var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/;

            jQuery.extend(jQuery.event, {

                trigger: function(event, data, elem, onlyHandlers) {

                    var i, cur, tmp, bubbleType, ontype, handle, special,
                        eventPath = [elem || document],
                        type = hasOwn.call(event, "type") ? event.type : event,
                        namespaces = hasOwn.call(event, "namespace") ? event.namespace.split(".") : [];

                    cur = tmp = elem = elem || document;

                    // Don't do events on text and comment nodes
                    if (elem.nodeType === 3 || elem.nodeType === 8) {
                        return;
                    }

                    // focus/blur morphs to focusin/out; ensure we're not firing them right now
                    if (rfocusMorph.test(type + jQuery.event.triggered)) {
                        return;
                    }

                    if (type.indexOf(".") > -1) {

                        // Namespaced trigger; create a regexp to match event type in handle()
                        namespaces = type.split(".");
                        type = namespaces.shift();
                        namespaces.sort();
                    }
                    ontype = type.indexOf(":") < 0 && "on" + type;

                    // Caller can pass in a jQuery.Event object, Object, or just an event type string
                    event = event[jQuery.expando] ?
                        event :
                        new jQuery.Event(type, typeof event === "object" && event);

                    // Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
                    event.isTrigger = onlyHandlers ? 2 : 3;
                    event.namespace = namespaces.join(".");
                    event.rnamespace = event.namespace ?
                        new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)") :
                        null;

                    // Clean up the event in case it is being reused
                    event.result = undefined;
                    if (!event.target) {
                        event.target = elem;
                    }

                    // Clone any incoming data and prepend the event, creating the handler arg list
                    data = data == null ? [event] :
                        jQuery.makeArray(data, [event]);

                    // Allow special events to draw outside the lines
                    special = jQuery.event.special[type] || {};
                    if (!onlyHandlers && special.trigger && special.trigger.apply(elem, data) === false) {
                        return;
                    }

                    // Determine event propagation path in advance, per W3C events spec (#9951)
                    // Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
                    if (!onlyHandlers && !special.noBubble && !jQuery.isWindow(elem)) {

                        bubbleType = special.delegateType || type;
                        if (!rfocusMorph.test(bubbleType + type)) {
                            cur = cur.parentNode;
                        }
                        for (; cur; cur = cur.parentNode) {
                            eventPath.push(cur);
                            tmp = cur;
                        }

                        // Only add window if we got to document (e.g., not plain obj or detached DOM)
                        if (tmp === (elem.ownerDocument || document)) {
                            eventPath.push(tmp.defaultView || tmp.parentWindow || window);
                        }
                    }

                    // Fire handlers on the event path
                    i = 0;
                    while ((cur = eventPath[i++]) && !event.isPropagationStopped()) {

                        event.type = i > 1 ?
                            bubbleType :
                            special.bindType || type;

                        // jQuery handler
                        handle = (dataPriv.get(cur, "events") || {})[event.type] &&
                            dataPriv.get(cur, "handle");
                        if (handle) {
                            handle.apply(cur, data);
                        }

                        // Native handler
                        handle = ontype && cur[ontype];
                        if (handle && handle.apply && acceptData(cur)) {
                            event.result = handle.apply(cur, data);
                            if (event.result === false) {
                                event.preventDefault();
                            }
                        }
                    }
                    event.type = type;

                    // If nobody prevented the default action, do it now
                    if (!onlyHandlers && !event.isDefaultPrevented()) {

                        if ((!special._default ||
                                special._default.apply(eventPath.pop(), data) === false) &&
                            acceptData(elem)) {

                            // Call a native DOM method on the target with the same name as the event.
                            // Don't do default actions on window, that's where global variables be (#6170)
                            if (ontype && jQuery.isFunction(elem[type]) && !jQuery.isWindow(elem)) {

                                // Don't re-trigger an onFOO event when we call its FOO() method
                                tmp = elem[ontype];

                                if (tmp) {
                                    elem[ontype] = null;
                                }

                                // Prevent re-triggering of the same event, since we already bubbled it above
                                jQuery.event.triggered = type;
                                elem[type]();
                                jQuery.event.triggered = undefined;

                                if (tmp) {
                                    elem[ontype] = tmp;
                                }
                            }
                        }
                    }

                    return event.result;
                },

                // Piggyback on a donor event to simulate a different one
                // Used only for `focus(in | out)` events
                simulate: function(type, elem, event) {
                    var e = jQuery.extend(
                        new jQuery.Event(),
                        event, {
                            type: type,
                            isSimulated: true
                        }
                    );

                    jQuery.event.trigger(e, null, elem);
                }

            });

            jQuery.fn.extend({

                trigger: function(type, data) {
                    return this.each(function() {
                        jQuery.event.trigger(type, data, this);
                    });
                },
                triggerHandler: function(type, data) {
                    var elem = this[0];
                    if (elem) {
                        return jQuery.event.trigger(type, data, elem, true);
                    }
                }
            });


            jQuery.each(("blur focus focusin focusout resize scroll click dblclick " +
                    "mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
                    "change select submit keydown keypress keyup contextmenu").split(" "),
                function(i, name) {

                    // Handle event binding
                    jQuery.fn[name] = function(data, fn) {
                        return arguments.length > 0 ?
                            this.on(name, null, data, fn) :
                            this.trigger(name);
                    };
                });

            jQuery.fn.extend({
                hover: function(fnOver, fnOut) {
                    return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);
                }
            });




            support.focusin = "onfocusin" in window;


            // Support: Firefox <=44
            // Firefox doesn't have focus(in | out) events
            // Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
            //
            // Support: Chrome <=48 - 49, Safari <=9.0 - 9.1
            // focus(in | out) events fire after focus & blur events,
            // which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
            // Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857
            if (!support.focusin) {
                jQuery.each({
                    focus: "focusin",
                    blur: "focusout"
                }, function(orig, fix) {

                    // Attach a single capturing handler on the document while someone wants focusin/focusout
                    var handler = function(event) {
                        jQuery.event.simulate(fix, event.target, jQuery.event.fix(event));
                    };

                    jQuery.event.special[fix] = {
                        setup: function() {
                            var doc = this.ownerDocument || this,
                                attaches = dataPriv.access(doc, fix);

                            if (!attaches) {
                                doc.addEventListener(orig, handler, true);
                            }
                            dataPriv.access(doc, fix, (attaches || 0) + 1);
                        },
                        teardown: function() {
                            var doc = this.ownerDocument || this,
                                attaches = dataPriv.access(doc, fix) - 1;

                            if (!attaches) {
                                doc.removeEventListener(orig, handler, true);
                                dataPriv.remove(doc, fix);

                            } else {
                                dataPriv.access(doc, fix, attaches);
                            }
                        }
                    };
                });
            }
            var location = window.location;

            var nonce = jQuery.now();

            var rquery = (/\?/);



            // Cross-browser xml parsing
            jQuery.parseXML = function(data) {
                var xml;
                if (!data || typeof data !== "string") {
                    return null;
                }

                // Support: IE 9 - 11 only
                // IE throws on parseFromString with invalid input.
                try {
                    xml = (new window.DOMParser()).parseFromString(data, "text/xml");
                } catch (e) {
                    xml = undefined;
                }

                if (!xml || xml.getElementsByTagName("parsererror").length) {
                    jQuery.error("Invalid XML: " + data);
                }
                return xml;
            };


            var
                rbracket = /\[\]$/,
                rCRLF = /\r?\n/g,
                rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
                rsubmittable = /^(?:input|select|textarea|keygen)/i;

            function buildParams(prefix, obj, traditional, add) {
                var name;

                if (Array.isArray(obj)) {

                    // Serialize array item.
                    jQuery.each(obj, function(i, v) {
                        if (traditional || rbracket.test(prefix)) {

                            // Treat each array item as a scalar.
                            add(prefix, v);

                        } else {

                            // Item is non-scalar (array or object), encode its numeric index.
                            buildParams(
                                prefix + "[" + (typeof v === "object" && v != null ? i : "") + "]",
                                v,
                                traditional,
                                add
                            );
                        }
                    });

                } else if (!traditional && jQuery.type(obj) === "object") {

                    // Serialize object item.
                    for (name in obj) {
                        buildParams(prefix + "[" + name + "]", obj[name], traditional, add);
                    }

                } else {

                    // Serialize scalar item.
                    add(prefix, obj);
                }
            }

            // Serialize an array of form elements or a set of
            // key/values into a query string
            jQuery.param = function(a, traditional) {
                var prefix,
                    s = [],
                    add = function(key, valueOrFunction) {

                        // If value is a function, invoke it and use its return value
                        var value = jQuery.isFunction(valueOrFunction) ?
                            valueOrFunction() :
                            valueOrFunction;

                        s[s.length] = encodeURIComponent(key) + "=" +
                            encodeURIComponent(value == null ? "" : value);
                    };

                // If an array was passed in, assume that it is an array of form elements.
                if (Array.isArray(a) || (a.jquery && !jQuery.isPlainObject(a))) {

                    // Serialize the form elements
                    jQuery.each(a, function() {
                        add(this.name, this.value);
                    });

                } else {

                    // If traditional, encode the "old" way (the way 1.3.2 or older
                    // did it), otherwise encode params recursively.
                    for (prefix in a) {
                        buildParams(prefix, a[prefix], traditional, add);
                    }
                }

                // Return the resulting serialization
                return s.join("&");
            };

            jQuery.fn.extend({
                serialize: function() {
                    return jQuery.param(this.serializeArray());
                },
                serializeArray: function() {
                    return this.map(function() {

                            // Can add propHook for "elements" to filter or add form elements
                            var elements = jQuery.prop(this, "elements");
                            return elements ? jQuery.makeArray(elements) : this;
                        })
                        .filter(function() {
                            var type = this.type;

                            // Use .is( ":disabled" ) so that fieldset[disabled] works
                            return this.name && !jQuery(this).is(":disabled") &&
                                rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type) &&
                                (this.checked || !rcheckableType.test(type));
                        })
                        .map(function(i, elem) {
                            var val = jQuery(this).val();

                            if (val == null) {
                                return null;
                            }

                            if (Array.isArray(val)) {
                                return jQuery.map(val, function(val) {
                                    return {
                                        name: elem.name,
                                        value: val.replace(rCRLF, "\r\n")
                                    };
                                });
                            }

                            return {
                                name: elem.name,
                                value: val.replace(rCRLF, "\r\n")
                            };
                        }).get();
                }
            });


            var
                r20 = /%20/g,
                rhash = /#.*$/,
                rantiCache = /([?&])_=[^&]*/,
                rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,

                // #7653, #8125, #8152: local protocol detection
                rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
                rnoContent = /^(?:GET|HEAD)$/,
                rprotocol = /^\/\//,

                /* Prefilters
                 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
                 * 2) These are called:
                 *    - BEFORE asking for a transport
                 *    - AFTER param serialization (s.data is a string if s.processData is true)
                 * 3) key is the dataType
                 * 4) the catchall symbol "*" can be used
                 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
                 */
                prefilters = {},

                /* Transports bindings
                 * 1) key is the dataType
                 * 2) the catchall symbol "*" can be used
                 * 3) selection will start with transport dataType and THEN go to "*" if needed
                 */
                transports = {},

                // Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
                allTypes = "*/".concat("*"),

                // Anchor tag for parsing the document origin
                originAnchor = document.createElement("a");
            originAnchor.href = location.href;

            // Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
            function addToPrefiltersOrTransports(structure) {

                // dataTypeExpression is optional and defaults to "*"
                return function(dataTypeExpression, func) {

                    if (typeof dataTypeExpression !== "string") {
                        func = dataTypeExpression;
                        dataTypeExpression = "*";
                    }

                    var dataType,
                        i = 0,
                        dataTypes = dataTypeExpression.toLowerCase().match(rnothtmlwhite) || [];

                    if (jQuery.isFunction(func)) {

                        // For each dataType in the dataTypeExpression
                        while ((dataType = dataTypes[i++])) {

                            // Prepend if requested
                            if (dataType[0] === "+") {
                                dataType = dataType.slice(1) || "*";
                                (structure[dataType] = structure[dataType] || []).unshift(func);

                                // Otherwise append
                            } else {
                                (structure[dataType] = structure[dataType] || []).push(func);
                            }
                        }
                    }
                };
            }

            // Base inspection function for prefilters and transports
            function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR) {

                var inspected = {},
                    seekingTransport = (structure === transports);

                function inspect(dataType) {
                    var selected;
                    inspected[dataType] = true;
                    jQuery.each(structure[dataType] || [], function(_, prefilterOrFactory) {
                        var dataTypeOrTransport = prefilterOrFactory(options, originalOptions, jqXHR);
                        if (typeof dataTypeOrTransport === "string" &&
                            !seekingTransport && !inspected[dataTypeOrTransport]) {

                            options.dataTypes.unshift(dataTypeOrTransport);
                            inspect(dataTypeOrTransport);
                            return false;
                        } else if (seekingTransport) {
                            return !(selected = dataTypeOrTransport);
                        }
                    });
                    return selected;
                }

                return inspect(options.dataTypes[0]) || !inspected["*"] && inspect("*");
            }

            // A special extend for ajax options
            // that takes "flat" options (not to be deep extended)
            // Fixes #9887
            function ajaxExtend(target, src) {
                var key, deep,
                    flatOptions = jQuery.ajaxSettings.flatOptions || {};

                for (key in src) {
                    if (src[key] !== undefined) {
                        (flatOptions[key] ? target : (deep || (deep = {})))[key] = src[key];
                    }
                }
                if (deep) {
                    jQuery.extend(true, target, deep);
                }

                return target;
            }

            /* Handles responses to an ajax request:
             * - finds the right dataType (mediates between content-type and expected dataType)
             * - returns the corresponding response
             */
            function ajaxHandleResponses(s, jqXHR, responses) {

                var ct, type, finalDataType, firstDataType,
                    contents = s.contents,
                    dataTypes = s.dataTypes;

                // Remove auto dataType and get content-type in the process
                while (dataTypes[0] === "*") {
                    dataTypes.shift();
                    if (ct === undefined) {
                        ct = s.mimeType || jqXHR.getResponseHeader("Content-Type");
                    }
                }

                // Check if we're dealing with a known content-type
                if (ct) {
                    for (type in contents) {
                        if (contents[type] && contents[type].test(ct)) {
                            dataTypes.unshift(type);
                            break;
                        }
                    }
                }

                // Check to see if we have a response for the expected dataType
                if (dataTypes[0] in responses) {
                    finalDataType = dataTypes[0];
                } else {

                    // Try convertible dataTypes
                    for (type in responses) {
                        if (!dataTypes[0] || s.converters[type + " " + dataTypes[0]]) {
                            finalDataType = type;
                            break;
                        }
                        if (!firstDataType) {
                            firstDataType = type;
                        }
                    }

                    // Or just use first one
                    finalDataType = finalDataType || firstDataType;
                }

                // If we found a dataType
                // We add the dataType to the list if needed
                // and return the corresponding response
                if (finalDataType) {
                    if (finalDataType !== dataTypes[0]) {
                        dataTypes.unshift(finalDataType);
                    }
                    return responses[finalDataType];
                }
            }

            /* Chain conversions given the request and the original response
             * Also sets the responseXXX fields on the jqXHR instance
             */
            function ajaxConvert(s, response, jqXHR, isSuccess) {
                var conv2, current, conv, tmp, prev,
                    converters = {},

                    // Work with a copy of dataTypes in case we need to modify it for conversion
                    dataTypes = s.dataTypes.slice();

                // Create converters map with lowercased keys
                if (dataTypes[1]) {
                    for (conv in s.converters) {
                        converters[conv.toLowerCase()] = s.converters[conv];
                    }
                }

                current = dataTypes.shift();

                // Convert to each sequential dataType
                while (current) {

                    if (s.responseFields[current]) {
                        jqXHR[s.responseFields[current]] = response;
                    }

                    // Apply the dataFilter if provided
                    if (!prev && isSuccess && s.dataFilter) {
                        response = s.dataFilter(response, s.dataType);
                    }

                    prev = current;
                    current = dataTypes.shift();

                    if (current) {

                        // There's only work to do if current dataType is non-auto
                        if (current === "*") {

                            current = prev;

                            // Convert response if prev dataType is non-auto and differs from current
                        } else if (prev !== "*" && prev !== current) {

                            // Seek a direct converter
                            conv = converters[prev + " " + current] || converters["* " + current];

                            // If none found, seek a pair
                            if (!conv) {
                                for (conv2 in converters) {

                                    // If conv2 outputs current
                                    tmp = conv2.split(" ");
                                    if (tmp[1] === current) {

                                        // If prev can be converted to accepted input
                                        conv = converters[prev + " " + tmp[0]] ||
                                            converters["* " + tmp[0]];
                                        if (conv) {

                                            // Condense equivalence converters
                                            if (conv === true) {
                                                conv = converters[conv2];

                                                // Otherwise, insert the intermediate dataType
                                            } else if (converters[conv2] !== true) {
                                                current = tmp[0];
                                                dataTypes.unshift(tmp[1]);
                                            }
                                            break;
                                        }
                                    }
                                }
                            }

                            // Apply converter (if not an equivalence)
                            if (conv !== true) {

                                // Unless errors are allowed to bubble, catch and return them
                                if (conv && s.throws) {
                                    response = conv(response);
                                } else {
                                    try {
                                        response = conv(response);
                                    } catch (e) {
                                        return {
                                            state: "parsererror",
                                            error: conv ? e : "No conversion from " + prev + " to " + current
                                        };
                                    }
                                }
                            }
                        }
                    }
                }

                return {
                    state: "success",
                    data: response
                };
            }

            jQuery.extend({

                // Counter for holding the number of active queries
                active: 0,

                // Last-Modified header cache for next request
                lastModified: {},
                etag: {},

                ajaxSettings: {
                    url: location.href,
                    type: "GET",
                    isLocal: rlocalProtocol.test(location.protocol),
                    global: true,
                    processData: true,
                    async: true,
                    contentType: "application/x-www-form-urlencoded; charset=UTF-8",

                    /*
                    timeout: 0,
                    data: null,
                    dataType: null,
                    username: null,
                    password: null,
                    cache: null,
                    throws: false,
                    traditional: false,
                    headers: {},
                    */

                    accepts: {
                        "*": allTypes,
                        text: "text/plain",
                        html: "text/html",
                        xml: "application/xml, text/xml",
                        json: "application/json, text/javascript"
                    },

                    contents: {
                        xml: /\bxml\b/,
                        html: /\bhtml/,
                        json: /\bjson\b/
                    },

                    responseFields: {
                        xml: "responseXML",
                        text: "responseText",
                        json: "responseJSON"
                    },

                    // Data converters
                    // Keys separate source (or catchall "*") and destination types with a single space
                    converters: {

                        // Convert anything to text
                        "* text": String,

                        // Text to html (true = no transformation)
                        "text html": true,

                        // Evaluate text as a json expression
                        "text json": JSON.parse,

                        // Parse text as xml
                        "text xml": jQuery.parseXML
                    },

                    // For options that shouldn't be deep extended:
                    // you can add your own custom options here if
                    // and when you create one that shouldn't be
                    // deep extended (see ajaxExtend)
                    flatOptions: {
                        url: true,
                        context: true
                    }
                },

                // Creates a full fledged settings object into target
                // with both ajaxSettings and settings fields.
                // If target is omitted, writes into ajaxSettings.
                ajaxSetup: function(target, settings) {
                    return settings ?

                        // Building a settings object
                        ajaxExtend(ajaxExtend(target, jQuery.ajaxSettings), settings) :

                        // Extending ajaxSettings
                        ajaxExtend(jQuery.ajaxSettings, target);
                },

                ajaxPrefilter: addToPrefiltersOrTransports(prefilters),
                ajaxTransport: addToPrefiltersOrTransports(transports),

                // Main method
                ajax: function(url, options) {

                    // If url is an object, simulate pre-1.5 signature
                    if (typeof url === "object") {
                        options = url;
                        url = undefined;
                    }

                    // Force options to be an object
                    options = options || {};

                    var transport,

                        // URL without anti-cache param
                        cacheURL,

                        // Response headers
                        responseHeadersString,
                        responseHeaders,

                        // timeout handle
                        timeoutTimer,

                        // Url cleanup var
                        urlAnchor,

                        // Request state (becomes false upon send and true upon completion)
                        completed,

                        // To know if global events are to be dispatched
                        fireGlobals,

                        // Loop variable
                        i,

                        // uncached part of the url
                        uncached,

                        // Create the final options object
                        s = jQuery.ajaxSetup({}, options),

                        // Callbacks context
                        callbackContext = s.context || s,

                        // Context for global events is callbackContext if it is a DOM node or jQuery collection
                        globalEventContext = s.context &&
                        (callbackContext.nodeType || callbackContext.jquery) ?
                        jQuery(callbackContext) :
                        jQuery.event,

                        // Deferreds
                        deferred = jQuery.Deferred(),
                        completeDeferred = jQuery.Callbacks("once memory"),

                        // Status-dependent callbacks
                        statusCode = s.statusCode || {},

                        // Headers (they are sent all at once)
                        requestHeaders = {},
                        requestHeadersNames = {},

                        // Default abort message
                        strAbort = "canceled",

                        // Fake xhr
                        jqXHR = {
                            readyState: 0,

                            // Builds headers hashtable if needed
                            getResponseHeader: function(key) {
                                var match;
                                if (completed) {
                                    if (!responseHeaders) {
                                        responseHeaders = {};
                                        while ((match = rheaders.exec(responseHeadersString))) {
                                            responseHeaders[match[1].toLowerCase()] = match[2];
                                        }
                                    }
                                    match = responseHeaders[key.toLowerCase()];
                                }
                                return match == null ? null : match;
                            },

                            // Raw string
                            getAllResponseHeaders: function() {
                                return completed ? responseHeadersString : null;
                            },

                            // Caches the header
                            setRequestHeader: function(name, value) {
                                if (completed == null) {
                                    name = requestHeadersNames[name.toLowerCase()] =
                                        requestHeadersNames[name.toLowerCase()] || name;
                                    requestHeaders[name] = value;
                                }
                                return this;
                            },

                            // Overrides response content-type header
                            overrideMimeType: function(type) {
                                if (completed == null) {
                                    s.mimeType = type;
                                }
                                return this;
                            },

                            // Status-dependent callbacks
                            statusCode: function(map) {
                                var code;
                                if (map) {
                                    if (completed) {

                                        // Execute the appropriate callbacks
                                        jqXHR.always(map[jqXHR.status]);
                                    } else {

                                        // Lazy-add the new callbacks in a way that preserves old ones
                                        for (code in map) {
                                            statusCode[code] = [statusCode[code], map[code]];
                                        }
                                    }
                                }
                                return this;
                            },

                            // Cancel the request
                            abort: function(statusText) {
                                var finalText = statusText || strAbort;
                                if (transport) {
                                    transport.abort(finalText);
                                }
                                done(0, finalText);
                                return this;
                            }
                        };

                    // Attach deferreds
                    deferred.promise(jqXHR);

                    // Add protocol if not provided (prefilters might expect it)
                    // Handle falsy url in the settings object (#10093: consistency with old signature)
                    // We also use the url parameter if available
                    s.url = ((url || s.url || location.href) + "")
                        .replace(rprotocol, location.protocol + "//");

                    // Alias method option to type as per ticket #12004
                    s.type = options.method || options.type || s.method || s.type;

                    // Extract dataTypes list
                    s.dataTypes = (s.dataType || "*").toLowerCase().match(rnothtmlwhite) || [""];

                    // A cross-domain request is in order when the origin doesn't match the current origin.
                    if (s.crossDomain == null) {
                        urlAnchor = document.createElement("a");

                        // Support: IE <=8 - 11, Edge 12 - 13
                        // IE throws exception on accessing the href property if url is malformed,
                        // e.g. http://example.com:80x/
                        try {
                            urlAnchor.href = s.url;

                            // Support: IE <=8 - 11 only
                            // Anchor's host property isn't correctly set when s.url is relative
                            urlAnchor.href = urlAnchor.href;
                            s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !==
                                urlAnchor.protocol + "//" + urlAnchor.host;
                        } catch (e) {

                            // If there is an error parsing the URL, assume it is crossDomain,
                            // it can be rejected by the transport if it is invalid
                            s.crossDomain = true;
                        }
                    }

                    // Convert data if not already a string
                    if (s.data && s.processData && typeof s.data !== "string") {
                        s.data = jQuery.param(s.data, s.traditional);
                    }

                    // Apply prefilters
                    inspectPrefiltersOrTransports(prefilters, s, options, jqXHR);

                    // If request was aborted inside a prefilter, stop there
                    if (completed) {
                        return jqXHR;
                    }

                    // We can fire global events as of now if asked to
                    // Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
                    fireGlobals = jQuery.event && s.global;

                    // Watch for a new set of requests
                    if (fireGlobals && jQuery.active++ === 0) {
                        jQuery.event.trigger("ajaxStart");
                    }

                    // Uppercase the type
                    s.type = s.type.toUpperCase();

                    // Determine if request has content
                    s.hasContent = !rnoContent.test(s.type);

                    // Save the URL in case we're toying with the If-Modified-Since
                    // and/or If-None-Match header later on
                    // Remove hash to simplify url manipulation
                    cacheURL = s.url.replace(rhash, "");

                    // More options handling for requests with no content
                    if (!s.hasContent) {

                        // Remember the hash so we can put it back
                        uncached = s.url.slice(cacheURL.length);

                        // If data is available, append data to url
                        if (s.data) {
                            cacheURL += (rquery.test(cacheURL) ? "&" : "?") + s.data;

                            // #9682: remove data so that it's not used in an eventual retry
                            delete s.data;
                        }

                        // Add or update anti-cache param if needed
                        if (s.cache === false) {
                            cacheURL = cacheURL.replace(rantiCache, "$1");
                            uncached = (rquery.test(cacheURL) ? "&" : "?") + "_=" + (nonce++) + uncached;
                        }

                        // Put hash and anti-cache on the URL that will be requested (gh-1732)
                        s.url = cacheURL + uncached;

                        // Change '%20' to '+' if this is encoded form body content (gh-2658)
                    } else if (s.data && s.processData &&
                        (s.contentType || "").indexOf("application/x-www-form-urlencoded") === 0) {
                        s.data = s.data.replace(r20, "+");
                    }

                    // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
                    if (s.ifModified) {
                        if (jQuery.lastModified[cacheURL]) {
                            jqXHR.setRequestHeader("If-Modified-Since", jQuery.lastModified[cacheURL]);
                        }
                        if (jQuery.etag[cacheURL]) {
                            jqXHR.setRequestHeader("If-None-Match", jQuery.etag[cacheURL]);
                        }
                    }

                    // Set the correct header, if data is being sent
                    if (s.data && s.hasContent && s.contentType !== false || options.contentType) {
                        jqXHR.setRequestHeader("Content-Type", s.contentType);
                    }

                    // Set the Accepts header for the server, depending on the dataType
                    jqXHR.setRequestHeader(
                        "Accept",
                        s.dataTypes[0] && s.accepts[s.dataTypes[0]] ?
                        s.accepts[s.dataTypes[0]] +
                        (s.dataTypes[0] !== "*" ? ", " + allTypes + "; q=0.01" : "") :
                        s.accepts["*"]
                    );

                    // Check for headers option
                    for (i in s.headers) {
                        jqXHR.setRequestHeader(i, s.headers[i]);
                    }

                    // Allow custom headers/mimetypes and early abort
                    if (s.beforeSend &&
                        (s.beforeSend.call(callbackContext, jqXHR, s) === false || completed)) {

                        // Abort if not done already and return
                        return jqXHR.abort();
                    }

                    // Aborting is no longer a cancellation
                    strAbort = "abort";

                    // Install callbacks on deferreds
                    completeDeferred.add(s.complete);
                    jqXHR.done(s.success);
                    jqXHR.fail(s.error);

                    // Get transport
                    transport = inspectPrefiltersOrTransports(transports, s, options, jqXHR);

                    // If no transport, we auto-abort
                    if (!transport) {
                        done(-1, "No Transport");
                    } else {
                        jqXHR.readyState = 1;

                        // Send global event
                        if (fireGlobals) {
                            globalEventContext.trigger("ajaxSend", [jqXHR, s]);
                        }

                        // If request was aborted inside ajaxSend, stop there
                        if (completed) {
                            return jqXHR;
                        }

                        // Timeout
                        if (s.async && s.timeout > 0) {
                            timeoutTimer = window.setTimeout(function() {
                                jqXHR.abort("timeout");
                            }, s.timeout);
                        }

                        try {
                            completed = false;
                            transport.send(requestHeaders, done);
                        } catch (e) {

                            // Rethrow post-completion exceptions
                            if (completed) {
                                throw e;
                            }

                            // Propagate others as results
                            done(-1, e);
                        }
                    }

                    // Callback for when everything is done
                    function done(status, nativeStatusText, responses, headers) {
                        var isSuccess, success, error, response, modified,
                            statusText = nativeStatusText;

                        // Ignore repeat invocations
                        if (completed) {
                            return;
                        }

                        completed = true;

                        // Clear timeout if it exists
                        if (timeoutTimer) {
                            window.clearTimeout(timeoutTimer);
                        }

                        // Dereference transport for early garbage collection
                        // (no matter how long the jqXHR object will be used)
                        transport = undefined;

                        // Cache response headers
                        responseHeadersString = headers || "";

                        // Set readyState
                        jqXHR.readyState = status > 0 ? 4 : 0;

                        // Determine if successful
                        isSuccess = status >= 200 && status < 300 || status === 304;

                        // Get response data
                        if (responses) {
                            response = ajaxHandleResponses(s, jqXHR, responses);
                        }

                        // Convert no matter what (that way responseXXX fields are always set)
                        response = ajaxConvert(s, response, jqXHR, isSuccess);

                        // If successful, handle type chaining
                        if (isSuccess) {

                            // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
                            if (s.ifModified) {
                                modified = jqXHR.getResponseHeader("Last-Modified");
                                if (modified) {
                                    jQuery.lastModified[cacheURL] = modified;
                                }
                                modified = jqXHR.getResponseHeader("etag");
                                if (modified) {
                                    jQuery.etag[cacheURL] = modified;
                                }
                            }

                            // if no content
                            if (status === 204 || s.type === "HEAD") {
                                statusText = "nocontent";

                                // if not modified
                            } else if (status === 304) {
                                statusText = "notmodified";

                                // If we have data, let's convert it
                            } else {
                                statusText = response.state;
                                success = response.data;
                                error = response.error;
                                isSuccess = !error;
                            }
                        } else {

                            // Extract error from statusText and normalize for non-aborts
                            error = statusText;
                            if (status || !statusText) {
                                statusText = "error";
                                if (status < 0) {
                                    status = 0;
                                }
                            }
                        }

                        // Set data for the fake xhr object
                        jqXHR.status = status;
                        jqXHR.statusText = (nativeStatusText || statusText) + "";

                        // Success/Error
                        if (isSuccess) {
                            deferred.resolveWith(callbackContext, [success, statusText, jqXHR]);
                        } else {
                            deferred.rejectWith(callbackContext, [jqXHR, statusText, error]);
                        }

                        // Status-dependent callbacks
                        jqXHR.statusCode(statusCode);
                        statusCode = undefined;

                        if (fireGlobals) {
                            globalEventContext.trigger(isSuccess ? "ajaxSuccess" : "ajaxError", [jqXHR, s, isSuccess ? success : error]);
                        }

                        // Complete
                        completeDeferred.fireWith(callbackContext, [jqXHR, statusText]);

                        if (fireGlobals) {
                            globalEventContext.trigger("ajaxComplete", [jqXHR, s]);

                            // Handle the global AJAX counter
                            if (!(--jQuery.active)) {
                                jQuery.event.trigger("ajaxStop");
                            }
                        }
                    }

                    return jqXHR;
                },

                getJSON: function(url, data, callback) {
                    return jQuery.get(url, data, callback, "json");
                },

                getScript: function(url, callback) {
                    return jQuery.get(url, undefined, callback, "script");
                }
            });

            jQuery.each(["get", "post"], function(i, method) {
                jQuery[method] = function(url, data, callback, type) {

                    // Shift arguments if data argument was omitted
                    if (jQuery.isFunction(data)) {
                        type = type || callback;
                        callback = data;
                        data = undefined;
                    }

                    // The url can be an options object (which then must have .url)
                    return jQuery.ajax(jQuery.extend({
                        url: url,
                        type: method,
                        dataType: type,
                        data: data,
                        success: callback
                    }, jQuery.isPlainObject(url) && url));
                };
            });


            jQuery._evalUrl = function(url) {
                return jQuery.ajax({
                    url: url,

                    // Make this explicit, since user can override this through ajaxSetup (#11264)
                    type: "GET",
                    dataType: "script",
                    cache: true,
                    async: false,
                    global: false,
                    "throws": true
                });
            };


            jQuery.fn.extend({
                wrapAll: function(html) {
                    var wrap;

                    if (this[0]) {
                        if (jQuery.isFunction(html)) {
                            html = html.call(this[0]);
                        }

                        // The elements to wrap the target around
                        wrap = jQuery(html, this[0].ownerDocument).eq(0).clone(true);

                        if (this[0].parentNode) {
                            wrap.insertBefore(this[0]);
                        }

                        wrap.map(function() {
                            var elem = this;

                            while (elem.firstElementChild) {
                                elem = elem.firstElementChild;
                            }

                            return elem;
                        }).append(this);
                    }

                    return this;
                },

                wrapInner: function(html) {
                    if (jQuery.isFunction(html)) {
                        return this.each(function(i) {
                            jQuery(this).wrapInner(html.call(this, i));
                        });
                    }

                    return this.each(function() {
                        var self = jQuery(this),
                            contents = self.contents();

                        if (contents.length) {
                            contents.wrapAll(html);

                        } else {
                            self.append(html);
                        }
                    });
                },

                wrap: function(html) {
                    var isFunction = jQuery.isFunction(html);

                    return this.each(function(i) {
                        jQuery(this).wrapAll(isFunction ? html.call(this, i) : html);
                    });
                },

                unwrap: function(selector) {
                    this.parent(selector).not("body").each(function() {
                        jQuery(this).replaceWith(this.childNodes);
                    });
                    return this;
                }
            });


            jQuery.expr.pseudos.hidden = function(elem) {
                return !jQuery.expr.pseudos.visible(elem);
            };
            jQuery.expr.pseudos.visible = function(elem) {
                return !!(elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length);
            };




            jQuery.ajaxSettings.xhr = function() {
                try {
                    return new window.XMLHttpRequest();
                } catch (e) {}
            };

            var xhrSuccessStatus = {

                    // File protocol always yields status code 0, assume 200
                    0: 200,

                    // Support: IE <=9 only
                    // #1450: sometimes IE returns 1223 when it should be 204
                    1223: 204
                },
                xhrSupported = jQuery.ajaxSettings.xhr();

            support.cors = !!xhrSupported && ("withCredentials" in xhrSupported);
            support.ajax = xhrSupported = !!xhrSupported;

            jQuery.ajaxTransport(function(options) {
                var callback, errorCallback;

                // Cross domain only allowed if supported through XMLHttpRequest
                if (support.cors || xhrSupported && !options.crossDomain) {
                    return {
                        send: function(headers, complete) {
                            var i,
                                xhr = options.xhr();

                            xhr.open(
                                options.type,
                                options.url,
                                options.async,
                                options.username,
                                options.password
                            );

                            // Apply custom fields if provided
                            if (options.xhrFields) {
                                for (i in options.xhrFields) {
                                    xhr[i] = options.xhrFields[i];
                                }
                            }

                            // Override mime type if needed
                            if (options.mimeType && xhr.overrideMimeType) {
                                xhr.overrideMimeType(options.mimeType);
                            }

                            // X-Requested-With header
                            // For cross-domain requests, seeing as conditions for a preflight are
                            // akin to a jigsaw puzzle, we simply never set it to be sure.
                            // (it can always be set on a per-request basis or even using ajaxSetup)
                            // For same-domain requests, won't change header if already provided.
                            if (!options.crossDomain && !headers["X-Requested-With"]) {
                                headers["X-Requested-With"] = "XMLHttpRequest";
                            }

                            // Set headers
                            for (i in headers) {
                                xhr.setRequestHeader(i, headers[i]);
                            }

                            // Callback
                            callback = function(type) {
                                return function() {
                                    if (callback) {
                                        callback = errorCallback = xhr.onload =
                                            xhr.onerror = xhr.onabort = xhr.onreadystatechange = null;

                                        if (type === "abort") {
                                            xhr.abort();
                                        } else if (type === "error") {

                                            // Support: IE <=9 only
                                            // On a manual native abort, IE9 throws
                                            // errors on any property access that is not readyState
                                            if (typeof xhr.status !== "number") {
                                                complete(0, "error");
                                            } else {
                                                complete(

                                                    // File: protocol always yields status 0; see #8605, #14207
                                                    xhr.status,
                                                    xhr.statusText
                                                );
                                            }
                                        } else {
                                            complete(
                                                xhrSuccessStatus[xhr.status] || xhr.status,
                                                xhr.statusText,

                                                // Support: IE <=9 only
                                                // IE9 has no XHR2 but throws on binary (trac-11426)
                                                // For XHR2 non-text, let the caller handle it (gh-2498)
                                                (xhr.responseType || "text") !== "text" ||
                                                typeof xhr.responseText !== "string" ? {
                                                    binary: xhr.response
                                                } : {
                                                    text: xhr.responseText
                                                },
                                                xhr.getAllResponseHeaders()
                                            );
                                        }
                                    }
                                };
                            };

                            // Listen to events
                            xhr.onload = callback();
                            errorCallback = xhr.onerror = callback("error");

                            // Support: IE 9 only
                            // Use onreadystatechange to replace onabort
                            // to handle uncaught aborts
                            if (xhr.onabort !== undefined) {
                                xhr.onabort = errorCallback;
                            } else {
                                xhr.onreadystatechange = function() {

                                    // Check readyState before timeout as it changes
                                    if (xhr.readyState === 4) {

                                        // Allow onerror to be called first,
                                        // but that will not handle a native abort
                                        // Also, save errorCallback to a variable
                                        // as xhr.onerror cannot be accessed
                                        window.setTimeout(function() {
                                            if (callback) {
                                                errorCallback();
                                            }
                                        });
                                    }
                                };
                            }

                            // Create the abort callback
                            callback = callback("abort");

                            try {

                                // Do send the request (this may raise an exception)
                                xhr.send(options.hasContent && options.data || null);
                            } catch (e) {

                                // #14683: Only rethrow if this hasn't been notified as an error yet
                                if (callback) {
                                    throw e;
                                }
                            }
                        },

                        abort: function() {
                            if (callback) {
                                callback();
                            }
                        }
                    };
                }
            });




            // Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)
            jQuery.ajaxPrefilter(function(s) {
                if (s.crossDomain) {
                    s.contents.script = false;
                }
            });

            // Install script dataType
            jQuery.ajaxSetup({
                accepts: {
                    script: "text/javascript, application/javascript, " +
                        "application/ecmascript, application/x-ecmascript"
                },
                contents: {
                    script: /\b(?:java|ecma)script\b/
                },
                converters: {
                    "text script": function(text) {
                        jQuery.globalEval(text);
                        return text;
                    }
                }
            });

            // Handle cache's special case and crossDomain
            jQuery.ajaxPrefilter("script", function(s) {
                if (s.cache === undefined) {
                    s.cache = false;
                }
                if (s.crossDomain) {
                    s.type = "GET";
                }
            });

            // Bind script tag hack transport
            jQuery.ajaxTransport("script", function(s) {

                // This transport only deals with cross domain requests
                if (s.crossDomain) {
                    var script, callback;
                    return {
                        send: function(_, complete) {
                            script = jQuery("<script>").prop({
                                charset: s.scriptCharset,
                                src: s.url
                            }).on(
                                "load error",
                                callback = function(evt) {
                                    script.remove();
                                    callback = null;
                                    if (evt) {
                                        complete(evt.type === "error" ? 404 : 200, evt.type);
                                    }
                                }
                            );

                            // Use native DOM manipulation to avoid our domManip AJAX trickery
                            document.head.appendChild(script[0]);
                        },
                        abort: function() {
                            if (callback) {
                                callback();
                            }
                        }
                    };
                }
            });




            var oldCallbacks = [],
                rjsonp = /(=)\?(?=&|$)|\?\?/;

            // Default jsonp settings
            jQuery.ajaxSetup({
                jsonp: "callback",
                jsonpCallback: function() {
                    var callback = oldCallbacks.pop() || (jQuery.expando + "_" + (nonce++));
                    this[callback] = true;
                    return callback;
                }
            });

            // Detect, normalize options and install callbacks for jsonp requests
            jQuery.ajaxPrefilter("json jsonp", function(s, originalSettings, jqXHR) {

                var callbackName, overwritten, responseContainer,
                    jsonProp = s.jsonp !== false && (rjsonp.test(s.url) ?
                        "url" :
                        typeof s.data === "string" &&
                        (s.contentType || "")
                        .indexOf("application/x-www-form-urlencoded") === 0 &&
                        rjsonp.test(s.data) && "data"
                    );

                // Handle iff the expected data type is "jsonp" or we have a parameter to set
                if (jsonProp || s.dataTypes[0] === "jsonp") {

                    // Get callback name, remembering preexisting value associated with it
                    callbackName = s.jsonpCallback = jQuery.isFunction(s.jsonpCallback) ?
                        s.jsonpCallback() :
                        s.jsonpCallback;

                    // Insert callback into url or form data
                    if (jsonProp) {
                        s[jsonProp] = s[jsonProp].replace(rjsonp, "$1" + callbackName);
                    } else if (s.jsonp !== false) {
                        s.url += (rquery.test(s.url) ? "&" : "?") + s.jsonp + "=" + callbackName;
                    }

                    // Use data converter to retrieve json after script execution
                    s.converters["script json"] = function() {
                        if (!responseContainer) {
                            jQuery.error(callbackName + " was not called");
                        }
                        return responseContainer[0];
                    };

                    // Force json dataType
                    s.dataTypes[0] = "json";

                    // Install callback
                    overwritten = window[callbackName];
                    window[callbackName] = function() {
                        responseContainer = arguments;
                    };

                    // Clean-up function (fires after converters)
                    jqXHR.always(function() {

                        // If previous value didn't exist - remove it
                        if (overwritten === undefined) {
                            jQuery(window).removeProp(callbackName);

                            // Otherwise restore preexisting value
                        } else {
                            window[callbackName] = overwritten;
                        }

                        // Save back as free
                        if (s[callbackName]) {

                            // Make sure that re-using the options doesn't screw things around
                            s.jsonpCallback = originalSettings.jsonpCallback;

                            // Save the callback name for future use
                            oldCallbacks.push(callbackName);
                        }

                        // Call if it was a function and we have a response
                        if (responseContainer && jQuery.isFunction(overwritten)) {
                            overwritten(responseContainer[0]);
                        }

                        responseContainer = overwritten = undefined;
                    });

                    // Delegate to script
                    return "script";
                }
            });




            // Support: Safari 8 only
            // In Safari 8 documents created via document.implementation.createHTMLDocument
            // collapse sibling forms: the second one becomes a child of the first one.
            // Because of that, this security measure has to be disabled in Safari 8.
            // https://bugs.webkit.org/show_bug.cgi?id=137337
            support.createHTMLDocument = (function() {
                var body = document.implementation.createHTMLDocument("").body;
                body.innerHTML = "<form></form><form></form>";
                return body.childNodes.length === 2;
            })();


            // Argument "data" should be string of html
            // context (optional): If specified, the fragment will be created in this context,
            // defaults to document
            // keepScripts (optional): If true, will include scripts passed in the html string
            jQuery.parseHTML = function(data, context, keepScripts) {
                if (typeof data !== "string") {
                    return [];
                }
                if (typeof context === "boolean") {
                    keepScripts = context;
                    context = false;
                }

                var base, parsed, scripts;

                if (!context) {

                    // Stop scripts or inline event handlers from being executed immediately
                    // by using document.implementation
                    if (support.createHTMLDocument) {
                        context = document.implementation.createHTMLDocument("");

                        // Set the base href for the created document
                        // so any parsed elements with URLs
                        // are based on the document's URL (gh-2965)
                        base = context.createElement("base");
                        base.href = document.location.href;
                        context.head.appendChild(base);
                    } else {
                        context = document;
                    }
                }

                parsed = rsingleTag.exec(data);
                scripts = !keepScripts && [];

                // Single tag
                if (parsed) {
                    return [context.createElement(parsed[1])];
                }

                parsed = buildFragment([data], context, scripts);

                if (scripts && scripts.length) {
                    jQuery(scripts).remove();
                }

                return jQuery.merge([], parsed.childNodes);
            };


            /**
             * Load a url into a page
             */
            jQuery.fn.load = function(url, params, callback) {
                var selector, type, response,
                    self = this,
                    off = url.indexOf(" ");

                if (off > -1) {
                    selector = stripAndCollapse(url.slice(off));
                    url = url.slice(0, off);
                }

                // If it's a function
                if (jQuery.isFunction(params)) {

                    // We assume that it's the callback
                    callback = params;
                    params = undefined;

                    // Otherwise, build a param string
                } else if (params && typeof params === "object") {
                    type = "POST";
                }

                // If we have elements to modify, make the request
                if (self.length > 0) {
                    jQuery.ajax({
                        url: url,

                        // If "type" variable is undefined, then "GET" method will be used.
                        // Make value of this field explicit since
                        // user can override it through ajaxSetup method
                        type: type || "GET",
                        dataType: "html",
                        data: params
                    }).done(function(responseText) {

                        // Save response for use in complete callback
                        response = arguments;

                        self.html(selector ?

                            // If a selector was specified, locate the right elements in a dummy div
                            // Exclude scripts to avoid IE 'Permission Denied' errors
                            jQuery("<div>").append(jQuery.parseHTML(responseText)).find(selector) :

                            // Otherwise use the full result
                            responseText);

                        // If the request succeeds, this function gets "data", "status", "jqXHR"
                        // but they are ignored because response was set above.
                        // If it fails, this function gets "jqXHR", "status", "error"
                    }).always(callback && function(jqXHR, status) {
                        self.each(function() {
                            callback.apply(this, response || [jqXHR.responseText, status, jqXHR]);
                        });
                    });
                }

                return this;
            };




            // Attach a bunch of functions for handling common AJAX events
            jQuery.each([
                "ajaxStart",
                "ajaxStop",
                "ajaxComplete",
                "ajaxError",
                "ajaxSuccess",
                "ajaxSend"
            ], function(i, type) {
                jQuery.fn[type] = function(fn) {
                    return this.on(type, fn);
                };
            });




            jQuery.expr.pseudos.animated = function(elem) {
                return jQuery.grep(jQuery.timers, function(fn) {
                    return elem === fn.elem;
                }).length;
            };




            jQuery.offset = {
                setOffset: function(elem, options, i) {
                    var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
                        position = jQuery.css(elem, "position"),
                        curElem = jQuery(elem),
                        props = {};

                    // Set position first, in-case top/left are set even on static elem
                    if (position === "static") {
                        elem.style.position = "relative";
                    }

                    curOffset = curElem.offset();
                    curCSSTop = jQuery.css(elem, "top");
                    curCSSLeft = jQuery.css(elem, "left");
                    calculatePosition = (position === "absolute" || position === "fixed") &&
                        (curCSSTop + curCSSLeft).indexOf("auto") > -1;

                    // Need to be able to calculate position if either
                    // top or left is auto and position is either absolute or fixed
                    if (calculatePosition) {
                        curPosition = curElem.position();
                        curTop = curPosition.top;
                        curLeft = curPosition.left;

                    } else {
                        curTop = parseFloat(curCSSTop) || 0;
                        curLeft = parseFloat(curCSSLeft) || 0;
                    }

                    if (jQuery.isFunction(options)) {

                        // Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
                        options = options.call(elem, i, jQuery.extend({}, curOffset));
                    }

                    if (options.top != null) {
                        props.top = (options.top - curOffset.top) + curTop;
                    }
                    if (options.left != null) {
                        props.left = (options.left - curOffset.left) + curLeft;
                    }

                    if ("using" in options) {
                        options.using.call(elem, props);

                    } else {
                        curElem.css(props);
                    }
                }
            };

            jQuery.fn.extend({
                offset: function(options) {

                    // Preserve chaining for setter
                    if (arguments.length) {
                        return options === undefined ?
                            this :
                            this.each(function(i) {
                                jQuery.offset.setOffset(this, options, i);
                            });
                    }

                    var doc, docElem, rect, win,
                        elem = this[0];

                    if (!elem) {
                        return;
                    }

                    // Return zeros for disconnected and hidden (display: none) elements (gh-2310)
                    // Support: IE <=11 only
                    // Running getBoundingClientRect on a
                    // disconnected node in IE throws an error
                    if (!elem.getClientRects().length) {
                        return {
                            top: 0,
                            left: 0
                        };
                    }

                    rect = elem.getBoundingClientRect();

                    doc = elem.ownerDocument;
                    docElem = doc.documentElement;
                    win = doc.defaultView;

                    return {
                        top: rect.top + win.pageYOffset - docElem.clientTop,
                        left: rect.left + win.pageXOffset - docElem.clientLeft
                    };
                },

                position: function() {
                    if (!this[0]) {
                        return;
                    }

                    var offsetParent, offset,
                        elem = this[0],
                        parentOffset = {
                            top: 0,
                            left: 0
                        };

                    // Fixed elements are offset from window (parentOffset = {top:0, left: 0},
                    // because it is its only offset parent
                    if (jQuery.css(elem, "position") === "fixed") {

                        // Assume getBoundingClientRect is there when computed position is fixed
                        offset = elem.getBoundingClientRect();

                    } else {

                        // Get *real* offsetParent
                        offsetParent = this.offsetParent();

                        // Get correct offsets
                        offset = this.offset();
                        if (!nodeName(offsetParent[0], "html")) {
                            parentOffset = offsetParent.offset();
                        }

                        // Add offsetParent borders
                        parentOffset = {
                            top: parentOffset.top + jQuery.css(offsetParent[0], "borderTopWidth", true),
                            left: parentOffset.left + jQuery.css(offsetParent[0], "borderLeftWidth", true)
                        };
                    }

                    // Subtract parent offsets and element margins
                    return {
                        top: offset.top - parentOffset.top - jQuery.css(elem, "marginTop", true),
                        left: offset.left - parentOffset.left - jQuery.css(elem, "marginLeft", true)
                    };
                },

                // This method will return documentElement in the following cases:
                // 1) For the element inside the iframe without offsetParent, this method will return
                //    documentElement of the parent window
                // 2) For the hidden or detached element
                // 3) For body or html element, i.e. in case of the html node - it will return itself
                //
                // but those exceptions were never presented as a real life use-cases
                // and might be considered as more preferable results.
                //
                // This logic, however, is not guaranteed and can change at any point in the future
                offsetParent: function() {
                    return this.map(function() {
                        var offsetParent = this.offsetParent;

                        while (offsetParent && jQuery.css(offsetParent, "position") === "static") {
                            offsetParent = offsetParent.offsetParent;
                        }

                        return offsetParent || documentElement;
                    });
                }
            });

            // Create scrollLeft and scrollTop methods
            jQuery.each({
                scrollLeft: "pageXOffset",
                scrollTop: "pageYOffset"
            }, function(method, prop) {
                var top = "pageYOffset" === prop;

                jQuery.fn[method] = function(val) {
                    return access(this, function(elem, method, val) {

                        // Coalesce documents and windows
                        var win;
                        if (jQuery.isWindow(elem)) {
                            win = elem;
                        } else if (elem.nodeType === 9) {
                            win = elem.defaultView;
                        }

                        if (val === undefined) {
                            return win ? win[prop] : elem[method];
                        }

                        if (win) {
                            win.scrollTo(!top ? val : win.pageXOffset,
                                top ? val : win.pageYOffset
                            );

                        } else {
                            elem[method] = val;
                        }
                    }, method, val, arguments.length);
                };
            });

            // Support: Safari <=7 - 9.1, Chrome <=37 - 49
            // Add the top/left cssHooks using jQuery.fn.position
            // Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
            // Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347
            // getComputedStyle returns percent when specified for top/left/bottom/right;
            // rather than make the css module depend on the offset module, just check for it here
            jQuery.each(["top", "left"], function(i, prop) {
                jQuery.cssHooks[prop] = addGetHookIf(support.pixelPosition,
                    function(elem, computed) {
                        if (computed) {
                            computed = curCSS(elem, prop);

                            // If curCSS returns percentage, fallback to offset
                            return rnumnonpx.test(computed) ?
                                jQuery(elem).position()[prop] + "px" :
                                computed;
                        }
                    }
                );
            });


            // Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
            jQuery.each({
                Height: "height",
                Width: "width"
            }, function(name, type) {
                jQuery.each({
                        padding: "inner" + name,
                        content: type,
                        "": "outer" + name
                    },
                    function(defaultExtra, funcName) {

                        // Margin is only for outerHeight, outerWidth
                        jQuery.fn[funcName] = function(margin, value) {
                            var chainable = arguments.length && (defaultExtra || typeof margin !== "boolean"),
                                extra = defaultExtra || (margin === true || value === true ? "margin" : "border");

                            return access(this, function(elem, type, value) {
                                var doc;

                                if (jQuery.isWindow(elem)) {

                                    // $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)
                                    return funcName.indexOf("outer") === 0 ?
                                        elem["inner" + name] :
                                        elem.document.documentElement["client" + name];
                                }

                                // Get document width or height
                                if (elem.nodeType === 9) {
                                    doc = elem.documentElement;

                                    // Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
                                    // whichever is greatest
                                    return Math.max(
                                        elem.body["scroll" + name], doc["scroll" + name],
                                        elem.body["offset" + name], doc["offset" + name],
                                        doc["client" + name]
                                    );
                                }

                                return value === undefined ?

                                    // Get width or height on the element, requesting but not forcing parseFloat
                                    jQuery.css(elem, type, extra) :

                                    // Set width or height on the element
                                    jQuery.style(elem, type, value, extra);
                            }, type, chainable ? margin : undefined, chainable);
                        };
                    });
            });


            jQuery.fn.extend({

                bind: function(types, data, fn) {
                    return this.on(types, null, data, fn);
                },
                unbind: function(types, fn) {
                    return this.off(types, null, fn);
                },

                delegate: function(selector, types, data, fn) {
                    return this.on(types, selector, data, fn);
                },
                undelegate: function(selector, types, fn) {

                    // ( namespace ) or ( selector, types [, fn] )
                    return arguments.length === 1 ?
                        this.off(selector, "**") :
                        this.off(types, selector || "**", fn);
                }
            });

            jQuery.holdReady = function(hold) {
                if (hold) {
                    jQuery.readyWait++;
                } else {
                    jQuery.ready(true);
                }
            };
            jQuery.isArray = Array.isArray;
            jQuery.parseJSON = JSON.parse;
            jQuery.nodeName = nodeName;




            // Register as a named AMD module, since jQuery can be concatenated with other
            // files that may use define, but not via a proper concatenation script that
            // understands anonymous AMD modules. A named AMD is safest and most robust
            // way to register. Lowercase jquery is used because AMD module names are
            // derived from file names, and jQuery is normally delivered in a lowercase
            // file name. Do this after creating the global so that if an AMD module wants
            // to call noConflict to hide this version of jQuery, it will work.

            // Note that for maximum portability, libraries that are not jQuery should
            // declare themselves as anonymous modules, and avoid setting a global if an
            // AMD loader is present. jQuery is a special case. For more information, see
            // https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

            if (true) {
                !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function() {
                        return jQuery;
                    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
                    __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
            }




            var

            // Map over jQuery in case of overwrite
                _jQuery = window.jQuery,

                // Map over the $ in case of overwrite
                _$ = window.$;

            jQuery.noConflict = function(deep) {
                if (window.$ === jQuery) {
                    window.$ = _$;
                }

                if (deep && window.jQuery === jQuery) {
                    window.jQuery = _jQuery;
                }

                return jQuery;
            };

            // Expose jQuery and $ identifiers, even in AMD
            // (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
            // and CommonJS for browser emulators (#13566)
            if (!noGlobal) {
                window.jQuery = window.$ = jQuery;
            }




            return jQuery;
        });


        /***/
    }),
    /* 3 */
    /***/
    (function(module, __webpack_exports__, __webpack_require__) {

        "use strict";
        Object.defineProperty(__webpack_exports__, "__esModule", {
            value: true
        });
        /* harmony export (binding) */
        __webpack_require__.d(__webpack_exports__, "h", function() {
            return h;
        });
        /* harmony export (binding) */
        __webpack_require__.d(__webpack_exports__, "createElement", function() {
            return h;
        });
        /* harmony export (binding) */
        __webpack_require__.d(__webpack_exports__, "cloneElement", function() {
            return cloneElement;
        });
        /* harmony export (binding) */
        __webpack_require__.d(__webpack_exports__, "Component", function() {
            return Component;
        });
        /* harmony export (binding) */
        __webpack_require__.d(__webpack_exports__, "render", function() {
            return render;
        });
        /* harmony export (binding) */
        __webpack_require__.d(__webpack_exports__, "rerender", function() {
            return rerender;
        });
        /* harmony export (binding) */
        __webpack_require__.d(__webpack_exports__, "options", function() {
            return options;
        });
        /** Virtual DOM Node */
        function VNode() {}

        /** Global options
         *	@public
         *	@namespace options {Object}
         */
        var options = {

            /** If `true`, `prop` changes trigger synchronous component updates.
             *	@name syncComponentUpdates
             *	@type Boolean
             *	@default true
             */
            //syncComponentUpdates: true,

            /** Processes all created VNodes.
             *	@param {VNode} vnode	A newly-created VNode to normalize/process
             */
            //vnode(vnode) { }

            /** Hook invoked after a component is mounted. */
            // afterMount(component) { }

            /** Hook invoked after the DOM is updated with a component's latest render. */
            // afterUpdate(component) { }

            /** Hook invoked immediately before a component is unmounted. */
            // beforeUnmount(component) { }
        };

        var stack = [];

        var EMPTY_CHILDREN = [];

        /**
         * JSX/hyperscript reviver.
         * @see http://jasonformat.com/wtf-is-jsx
         * Benchmarks: https://esbench.com/bench/57ee8f8e330ab09900a1a1a0
         *
         * Note: this is exported as both `h()` and `createElement()` for compatibility reasons.
         *
         * Creates a VNode (virtual DOM element). A tree of VNodes can be used as a lightweight representation
         * of the structure of a DOM tree. This structure can be realized by recursively comparing it against
         * the current _actual_ DOM structure, and applying only the differences.
         *
         * `h()`/`createElement()` accepts an element name, a list of attributes/props,
         * and optionally children to append to the element.
         *
         * @example The following DOM tree
         *
         * `<div id="foo" name="bar">Hello!</div>`
         *
         * can be constructed using this function as:
         *
         * `h('div', { id: 'foo', name : 'bar' }, 'Hello!');`
         *
         * @param {string} nodeName	An element name. Ex: `div`, `a`, `span`, etc.
         * @param {Object} attributes	Any attributes/props to set on the created element.
         * @param rest			Additional arguments are taken to be children to append. Can be infinitely nested Arrays.
         *
         * @public
         */
        function h(nodeName, attributes) {
            var children = EMPTY_CHILDREN,
                lastSimple,
                child,
                simple,
                i;
            for (i = arguments.length; i-- > 2;) {
                stack.push(arguments[i]);
            }
            if (attributes && attributes.children != null) {
                if (!stack.length) stack.push(attributes.children);
                delete attributes.children;
            }
            while (stack.length) {
                if ((child = stack.pop()) && child.pop !== undefined) {
                    for (i = child.length; i--;) {
                        stack.push(child[i]);
                    }
                } else {
                    if (typeof child === 'boolean') child = null;

                    if (simple = typeof nodeName !== 'function') {
                        if (child == null) child = '';
                        else if (typeof child === 'number') child = String(child);
                        else if (typeof child !== 'string') simple = false;
                    }

                    if (simple && lastSimple) {
                        children[children.length - 1] += child;
                    } else if (children === EMPTY_CHILDREN) {
                        children = [child];
                    } else {
                        children.push(child);
                    }

                    lastSimple = simple;
                }
            }

            var p = new VNode();
            p.nodeName = nodeName;
            p.children = children;
            p.attributes = attributes == null ? undefined : attributes;
            p.key = attributes == null ? undefined : attributes.key;

            // if a "vnode hook" is defined, pass every created VNode to it
            if (options.vnode !== undefined) options.vnode(p);

            return p;
        }

        /**
         *  Copy all properties from `props` onto `obj`.
         *  @param {Object} obj		Object onto which properties should be copied.
         *  @param {Object} props	Object from which to copy properties.
         *  @returns obj
         *  @private
         */
        function extend(obj, props) {
            for (var i in props) {
                obj[i] = props[i];
            }
            return obj;
        }

        /**
         * Call a function asynchronously, as soon as possible. Makes
         * use of HTML Promise to schedule the callback if available,
         * otherwise falling back to `setTimeout` (mainly for IE<11).
         *
         * @param {Function} callback
         */
        var defer = typeof Promise == 'function' ? Promise.resolve().then.bind(Promise.resolve()) : setTimeout;

        /**
         * Clones the given VNode, optionally adding attributes/props and replacing its children.
         * @param {VNode} vnode		The virutal DOM element to clone
         * @param {Object} props	Attributes/props to add when cloning
         * @param {VNode} rest		Any additional arguments will be used as replacement children.
         */
        function cloneElement(vnode, props) {
            return h(vnode.nodeName, extend(extend({}, vnode.attributes), props), arguments.length > 2 ? [].slice.call(arguments, 2) : vnode.children);
        }

        // DOM properties that should NOT have "px" added when numeric
        var IS_NON_DIMENSIONAL = /acit|ex(?:s|g|n|p|$)|rph|ows|mnc|ntw|ine[ch]|zoo|^ord/i;

        /** Managed queue of dirty components to be re-rendered */

        var items = [];

        function enqueueRender(component) {
            if (!component._dirty && (component._dirty = true) && items.push(component) == 1) {
                (options.debounceRendering || defer)(rerender);
            }
        }

        function rerender() {
            var p,
                list = items;
            items = [];
            while (p = list.pop()) {
                if (p._dirty) renderComponent(p);
            }
        }

        /**
         * Check if two nodes are equivalent.
         *
         * @param {Node} node			DOM Node to compare
         * @param {VNode} vnode			Virtual DOM node to compare
         * @param {boolean} [hyrdating=false]	If true, ignores component constructors when comparing.
         * @private
         */
        function isSameNodeType(node, vnode, hydrating) {
            if (typeof vnode === 'string' || typeof vnode === 'number') {
                return node.splitText !== undefined;
            }
            if (typeof vnode.nodeName === 'string') {
                return !node._componentConstructor && isNamedNode(node, vnode.nodeName);
            }
            return hydrating || node._componentConstructor === vnode.nodeName;
        }

        /**
         * Check if an Element has a given nodeName, case-insensitively.
         *
         * @param {Element} node	A DOM Element to inspect the name of.
         * @param {String} nodeName	Unnormalized name to compare against.
         */
        function isNamedNode(node, nodeName) {
            return node.normalizedNodeName === nodeName || node.nodeName.toLowerCase() === nodeName.toLowerCase();
        }

        /**
         * Reconstruct Component-style `props` from a VNode.
         * Ensures default/fallback values from `defaultProps`:
         * Own-properties of `defaultProps` not present in `vnode.attributes` are added.
         *
         * @param {VNode} vnode
         * @returns {Object} props
         */
        function getNodeProps(vnode) {
            var props = extend({}, vnode.attributes);
            props.children = vnode.children;

            var defaultProps = vnode.nodeName.defaultProps;
            if (defaultProps !== undefined) {
                for (var i in defaultProps) {
                    if (props[i] === undefined) {
                        props[i] = defaultProps[i];
                    }
                }
            }

            return props;
        }

        /** Create an element with the given nodeName.
         *	@param {String} nodeName
         *	@param {Boolean} [isSvg=false]	If `true`, creates an element within the SVG namespace.
         *	@returns {Element} node
         */
        function createNode(nodeName, isSvg) {
            var node = isSvg ? document.createElementNS('http://www.w3.org/2000/svg', nodeName) : document.createElement(nodeName);
            node.normalizedNodeName = nodeName;
            return node;
        }

        /** Remove a child node from its parent if attached.
         *	@param {Element} node		The node to remove
         */
        function removeNode(node) {
            var parentNode = node.parentNode;
            if (parentNode) parentNode.removeChild(node);
        }

        /** Set a named attribute on the given Node, with special behavior for some names and event handlers.
         *	If `value` is `null`, the attribute/handler will be removed.
         *	@param {Element} node	An element to mutate
         *	@param {string} name	The name/key to set, such as an event or attribute name
         *	@param {any} old	The last value that was set for this name/node pair
         *	@param {any} value	An attribute value, such as a function to be used as an event handler
         *	@param {Boolean} isSvg	Are we currently diffing inside an svg?
         *	@private
         */
        function setAccessor(node, name, old, value, isSvg) {
            if (name === 'className') name = 'class';

            if (name === 'key') {
                // ignore
            } else if (name === 'ref') {
                if (old) old(null);
                if (value) value(node);
            } else if (name === 'class' && !isSvg) {
                node.className = value || '';
            } else if (name === 'style') {
                if (!value || typeof value === 'string' || typeof old === 'string') {
                    node.style.cssText = value || '';
                }
                if (value && typeof value === 'object') {
                    if (typeof old !== 'string') {
                        for (var i in old) {
                            if (!(i in value)) node.style[i] = '';
                        }
                    }
                    for (var i in value) {
                        node.style[i] = typeof value[i] === 'number' && IS_NON_DIMENSIONAL.test(i) === false ? value[i] + 'px' : value[i];
                    }
                }
            } else if (name === 'dangerouslySetInnerHTML') {
                if (value) node.innerHTML = value.__html || '';
            } else if (name[0] == 'o' && name[1] == 'n') {
                var useCapture = name !== (name = name.replace(/Capture$/, ''));
                name = name.toLowerCase().substring(2);
                if (value) {
                    if (!old) node.addEventListener(name, eventProxy, useCapture);
                } else {
                    node.removeEventListener(name, eventProxy, useCapture);
                }
                (node._listeners || (node._listeners = {}))[name] = value;
            } else if (name !== 'list' && name !== 'type' && !isSvg && name in node) {
                setProperty(node, name, value == null ? '' : value);
                if (value == null || value === false) node.removeAttribute(name);
            } else {
                var ns = isSvg && name !== (name = name.replace(/^xlink\:?/, ''));
                if (value == null || value === false) {
                    if (ns) node.removeAttributeNS('http://www.w3.org/1999/xlink', name.toLowerCase());
                    else node.removeAttribute(name);
                } else if (typeof value !== 'function') {
                    if (ns) node.setAttributeNS('http://www.w3.org/1999/xlink', name.toLowerCase(), value);
                    else node.setAttribute(name, value);
                }
            }
        }

        /** Attempt to set a DOM property to the given value.
         *	IE & FF throw for certain property-value combinations.
         */
        function setProperty(node, name, value) {
            try {
                node[name] = value;
            } catch (e) {}
        }

        /** Proxy an event to hooked event handlers
         *	@private
         */
        function eventProxy(e) {
            return this._listeners[e.type](options.event && options.event(e) || e);
        }

        /** Queue of components that have been mounted and are awaiting componentDidMount */
        var mounts = [];

        /** Diff recursion count, used to track the end of the diff cycle. */
        var diffLevel = 0;

        /** Global flag indicating if the diff is currently within an SVG */
        var isSvgMode = false;

        /** Global flag indicating if the diff is performing hydration */
        var hydrating = false;

        /** Invoke queued componentDidMount lifecycle methods */
        function flushMounts() {
            var c;
            while (c = mounts.pop()) {
                if (options.afterMount) options.afterMount(c);
                if (c.componentDidMount) c.componentDidMount();
            }
        }

        /** Apply differences in a given vnode (and it's deep children) to a real DOM Node.
         *	@param {Element} [dom=null]		A DOM node to mutate into the shape of the `vnode`
         *	@param {VNode} vnode			A VNode (with descendants forming a tree) representing the desired DOM structure
         *	@returns {Element} dom			The created/mutated element
         *	@private
         */
        function diff(dom, vnode, context, mountAll, parent, componentRoot) {
            // diffLevel having been 0 here indicates initial entry into the diff (not a subdiff)
            if (!diffLevel++) {
                // when first starting the diff, check if we're diffing an SVG or within an SVG
                isSvgMode = parent != null && parent.ownerSVGElement !== undefined;

                // hydration is indicated by the existing element to be diffed not having a prop cache
                hydrating = dom != null && !('__preactattr_' in dom);
            }

            var ret = idiff(dom, vnode, context, mountAll, componentRoot);

            // append the element if its a new parent
            if (parent && ret.parentNode !== parent) parent.appendChild(ret);

            // diffLevel being reduced to 0 means we're exiting the diff
            if (!--diffLevel) {
                hydrating = false;
                // invoke queued componentDidMount lifecycle methods
                if (!componentRoot) flushMounts();
            }

            return ret;
        }

        /** Internals of `diff()`, separated to allow bypassing diffLevel / mount flushing. */
        function idiff(dom, vnode, context, mountAll, componentRoot) {
            var out = dom,
                prevSvgMode = isSvgMode;

            // empty values (null, undefined, booleans) render as empty Text nodes
            if (vnode == null || typeof vnode === 'boolean') vnode = '';

            // Fast case: Strings & Numbers create/update Text nodes.
            if (typeof vnode === 'string' || typeof vnode === 'number') {

                // update if it's already a Text node:
                if (dom && dom.splitText !== undefined && dom.parentNode && (!dom._component || componentRoot)) {
                    /* istanbul ignore if */
                    /* Browser quirk that can't be covered: https://github.com/developit/preact/commit/fd4f21f5c45dfd75151bd27b4c217d8003aa5eb9 */
                    if (dom.nodeValue != vnode) {
                        dom.nodeValue = vnode;
                    }
                } else {
                    // it wasn't a Text node: replace it with one and recycle the old Element
                    out = document.createTextNode(vnode);
                    if (dom) {
                        if (dom.parentNode) dom.parentNode.replaceChild(out, dom);
                        recollectNodeTree(dom, true);
                    }
                }

                out['__preactattr_'] = true;

                return out;
            }

            // If the VNode represents a Component, perform a component diff:
            var vnodeName = vnode.nodeName;
            if (typeof vnodeName === 'function') {
                return buildComponentFromVNode(dom, vnode, context, mountAll);
            }

            // Tracks entering and exiting SVG namespace when descending through the tree.
            isSvgMode = vnodeName === 'svg' ? true : vnodeName === 'foreignObject' ? false : isSvgMode;

            // If there's no existing element or it's the wrong type, create a new one:
            vnodeName = String(vnodeName);
            if (!dom || !isNamedNode(dom, vnodeName)) {
                out = createNode(vnodeName, isSvgMode);

                if (dom) {
                    // move children into the replacement node
                    while (dom.firstChild) {
                        out.appendChild(dom.firstChild);
                    } // if the previous Element was mounted into the DOM, replace it inline
                    if (dom.parentNode) dom.parentNode.replaceChild(out, dom);

                    // recycle the old element (skips non-Element node types)
                    recollectNodeTree(dom, true);
                }
            }

            var fc = out.firstChild,
                props = out['__preactattr_'],
                vchildren = vnode.children;

            if (props == null) {
                props = out['__preactattr_'] = {};
                for (var a = out.attributes, i = a.length; i--;) {
                    props[a[i].name] = a[i].value;
                }
            }

            // Optimization: fast-path for elements containing a single TextNode:
            if (!hydrating && vchildren && vchildren.length === 1 && typeof vchildren[0] === 'string' && fc != null && fc.splitText !== undefined && fc.nextSibling == null) {
                if (fc.nodeValue != vchildren[0]) {
                    fc.nodeValue = vchildren[0];
                }
            }
            // otherwise, if there are existing or new children, diff them:
            else if (vchildren && vchildren.length || fc != null) {
                innerDiffNode(out, vchildren, context, mountAll, hydrating || props.dangerouslySetInnerHTML != null);
            }

            // Apply attributes/props from VNode to the DOM Element:
            diffAttributes(out, vnode.attributes, props);

            // restore previous SVG mode: (in case we're exiting an SVG namespace)
            isSvgMode = prevSvgMode;

            return out;
        }

        /** Apply child and attribute changes between a VNode and a DOM Node to the DOM.
         *	@param {Element} dom			Element whose children should be compared & mutated
         *	@param {Array} vchildren		Array of VNodes to compare to `dom.childNodes`
         *	@param {Object} context			Implicitly descendant context object (from most recent `getChildContext()`)
         *	@param {Boolean} mountAll
         *	@param {Boolean} isHydrating	If `true`, consumes externally created elements similar to hydration
         */
        function innerDiffNode(dom, vchildren, context, mountAll, isHydrating) {
            var originalChildren = dom.childNodes,
                children = [],
                keyed = {},
                keyedLen = 0,
                min = 0,
                len = originalChildren.length,
                childrenLen = 0,
                vlen = vchildren ? vchildren.length : 0,
                j,
                c,
                f,
                vchild,
                child;

            // Build up a map of keyed children and an Array of unkeyed children:
            if (len !== 0) {
                for (var i = 0; i < len; i++) {
                    var _child = originalChildren[i],
                        props = _child['__preactattr_'],
                        key = vlen && props ? _child._component ? _child._component.__key : props.key : null;
                    if (key != null) {
                        keyedLen++;
                        keyed[key] = _child;
                    } else if (props || (_child.splitText !== undefined ? isHydrating ? _child.nodeValue.trim() : true : isHydrating)) {
                        children[childrenLen++] = _child;
                    }
                }
            }

            if (vlen !== 0) {
                for (var i = 0; i < vlen; i++) {
                    vchild = vchildren[i];
                    child = null;

                    // attempt to find a node based on key matching
                    var key = vchild.key;
                    if (key != null) {
                        if (keyedLen && keyed[key] !== undefined) {
                            child = keyed[key];
                            keyed[key] = undefined;
                            keyedLen--;
                        }
                    }
                    // attempt to pluck a node of the same type from the existing children
                    else if (!child && min < childrenLen) {
                        for (j = min; j < childrenLen; j++) {
                            if (children[j] !== undefined && isSameNodeType(c = children[j], vchild, isHydrating)) {
                                child = c;
                                children[j] = undefined;
                                if (j === childrenLen - 1) childrenLen--;
                                if (j === min) min++;
                                break;
                            }
                        }
                    }

                    // morph the matched/found/created DOM child to match vchild (deep)
                    child = idiff(child, vchild, context, mountAll);

                    f = originalChildren[i];
                    if (child && child !== dom && child !== f) {
                        if (f == null) {
                            dom.appendChild(child);
                        } else if (child === f.nextSibling) {
                            removeNode(f);
                        } else {
                            dom.insertBefore(child, f);
                        }
                    }
                }
            }

            // remove unused keyed children:
            if (keyedLen) {
                for (var i in keyed) {
                    if (keyed[i] !== undefined) recollectNodeTree(keyed[i], false);
                }
            }

            // remove orphaned unkeyed children:
            while (min <= childrenLen) {
                if ((child = children[childrenLen--]) !== undefined) recollectNodeTree(child, false);
            }
        }

        /** Recursively recycle (or just unmount) a node and its descendants.
         *	@param {Node} node						DOM node to start unmount/removal from
         *	@param {Boolean} [unmountOnly=false]	If `true`, only triggers unmount lifecycle, skips removal
         */
        function recollectNodeTree(node, unmountOnly) {
            var component = node._component;
            if (component) {
                // if node is owned by a Component, unmount that component (ends up recursing back here)
                unmountComponent(component);
            } else {
                // If the node's VNode had a ref function, invoke it with null here.
                // (this is part of the React spec, and smart for unsetting references)
                if (node['__preactattr_'] != null && node['__preactattr_'].ref) node['__preactattr_'].ref(null);

                if (unmountOnly === false || node['__preactattr_'] == null) {
                    removeNode(node);
                }

                removeChildren(node);
            }
        }

        /** Recollect/unmount all children.
         *	- we use .lastChild here because it causes less reflow than .firstChild
         *	- it's also cheaper than accessing the .childNodes Live NodeList
         */
        function removeChildren(node) {
            node = node.lastChild;
            while (node) {
                var next = node.previousSibling;
                recollectNodeTree(node, true);
                node = next;
            }
        }

        /** Apply differences in attributes from a VNode to the given DOM Element.
         *	@param {Element} dom		Element with attributes to diff `attrs` against
         *	@param {Object} attrs		The desired end-state key-value attribute pairs
         *	@param {Object} old			Current/previous attributes (from previous VNode or element's prop cache)
         */
        function diffAttributes(dom, attrs, old) {
            var name;

            // remove attributes no longer present on the vnode by setting them to undefined
            for (name in old) {
                if (!(attrs && attrs[name] != null) && old[name] != null) {
                    setAccessor(dom, name, old[name], old[name] = undefined, isSvgMode);
                }
            }

            // add new & update changed attributes
            for (name in attrs) {
                if (name !== 'children' && name !== 'innerHTML' && (!(name in old) || attrs[name] !== (name === 'value' || name === 'checked' ? dom[name] : old[name]))) {
                    setAccessor(dom, name, old[name], old[name] = attrs[name], isSvgMode);
                }
            }
        }

        /** Retains a pool of Components for re-use, keyed on component name.
         *	Note: since component names are not unique or even necessarily available, these are primarily a form of sharding.
         *	@private
         */
        var components = {};

        /** Reclaim a component for later re-use by the recycler. */
        function collectComponent(component) {
            var name = component.constructor.name;
            (components[name] || (components[name] = [])).push(component);
        }

        /** Create a component. Normalizes differences between PFC's and classful Components. */
        function createComponent(Ctor, props, context) {
            var list = components[Ctor.name],
                inst;

            if (Ctor.prototype && Ctor.prototype.render) {
                inst = new Ctor(props, context);
                Component.call(inst, props, context);
            } else {
                inst = new Component(props, context);
                inst.constructor = Ctor;
                inst.render = doRender;
            }

            if (list) {
                for (var i = list.length; i--;) {
                    if (list[i].constructor === Ctor) {
                        inst.nextBase = list[i].nextBase;
                        list.splice(i, 1);
                        break;
                    }
                }
            }
            return inst;
        }

        /** The `.render()` method for a PFC backing instance. */
        function doRender(props, state, context) {
            return this.constructor(props, context);
        }

        /** Set a component's `props` (generally derived from JSX attributes).
         *	@param {Object} props
         *	@param {Object} [opts]
         *	@param {boolean} [opts.renderSync=false]	If `true` and {@link options.syncComponentUpdates} is `true`, triggers synchronous rendering.
         *	@param {boolean} [opts.render=true]			If `false`, no render will be triggered.
         */
        function setComponentProps(component, props, opts, context, mountAll) {
            if (component._disable) return;
            component._disable = true;

            if (component.__ref = props.ref) delete props.ref;
            if (component.__key = props.key) delete props.key;

            if (!component.base || mountAll) {
                if (component.componentWillMount) component.componentWillMount();
            } else if (component.componentWillReceiveProps) {
                component.componentWillReceiveProps(props, context);
            }

            if (context && context !== component.context) {
                if (!component.prevContext) component.prevContext = component.context;
                component.context = context;
            }

            if (!component.prevProps) component.prevProps = component.props;
            component.props = props;

            component._disable = false;

            if (opts !== 0) {
                if (opts === 1 || options.syncComponentUpdates !== false || !component.base) {
                    renderComponent(component, 1, mountAll);
                } else {
                    enqueueRender(component);
                }
            }

            if (component.__ref) component.__ref(component);
        }

        /** Render a Component, triggering necessary lifecycle events and taking High-Order Components into account.
         *	@param {Component} component
         *	@param {Object} [opts]
         *	@param {boolean} [opts.build=false]		If `true`, component will build and store a DOM node if not already associated with one.
         *	@private
         */
        function renderComponent(component, opts, mountAll, isChild) {
            if (component._disable) return;

            var props = component.props,
                state = component.state,
                context = component.context,
                previousProps = component.prevProps || props,
                previousState = component.prevState || state,
                previousContext = component.prevContext || context,
                isUpdate = component.base,
                nextBase = component.nextBase,
                initialBase = isUpdate || nextBase,
                initialChildComponent = component._component,
                skip = false,
                rendered,
                inst,
                cbase;

            // if updating
            if (isUpdate) {
                component.props = previousProps;
                component.state = previousState;
                component.context = previousContext;
                if (opts !== 2 && component.shouldComponentUpdate && component.shouldComponentUpdate(props, state, context) === false) {
                    skip = true;
                } else if (component.componentWillUpdate) {
                    component.componentWillUpdate(props, state, context);
                }
                component.props = props;
                component.state = state;
                component.context = context;
            }

            component.prevProps = component.prevState = component.prevContext = component.nextBase = null;
            component._dirty = false;

            if (!skip) {
                rendered = component.render(props, state, context);

                // context to pass to the child, can be updated via (grand-)parent component
                if (component.getChildContext) {
                    context = extend(extend({}, context), component.getChildContext());
                }

                var childComponent = rendered && rendered.nodeName,
                    toUnmount,
                    base;

                if (typeof childComponent === 'function') {
                    // set up high order component link

                    var childProps = getNodeProps(rendered);
                    inst = initialChildComponent;

                    if (inst && inst.constructor === childComponent && childProps.key == inst.__key) {
                        setComponentProps(inst, childProps, 1, context, false);
                    } else {
                        toUnmount = inst;

                        component._component = inst = createComponent(childComponent, childProps, context);
                        inst.nextBase = inst.nextBase || nextBase;
                        inst._parentComponent = component;
                        setComponentProps(inst, childProps, 0, context, false);
                        renderComponent(inst, 1, mountAll, true);
                    }

                    base = inst.base;
                } else {
                    cbase = initialBase;

                    // destroy high order component link
                    toUnmount = initialChildComponent;
                    if (toUnmount) {
                        cbase = component._component = null;
                    }

                    if (initialBase || opts === 1) {
                        if (cbase) cbase._component = null;
                        base = diff(cbase, rendered, context, mountAll || !isUpdate, initialBase && initialBase.parentNode, true);
                    }
                }

                if (initialBase && base !== initialBase && inst !== initialChildComponent) {
                    var baseParent = initialBase.parentNode;
                    if (baseParent && base !== baseParent) {
                        baseParent.replaceChild(base, initialBase);

                        if (!toUnmount) {
                            initialBase._component = null;
                            recollectNodeTree(initialBase, false);
                        }
                    }
                }

                if (toUnmount) {
                    unmountComponent(toUnmount);
                }

                component.base = base;
                if (base && !isChild) {
                    var componentRef = component,
                        t = component;
                    while (t = t._parentComponent) {
                        (componentRef = t).base = base;
                    }
                    base._component = componentRef;
                    base._componentConstructor = componentRef.constructor;
                }
            }

            if (!isUpdate || mountAll) {
                mounts.unshift(component);
            } else if (!skip) {
                // Ensure that pending componentDidMount() hooks of child components
                // are called before the componentDidUpdate() hook in the parent.
                // Note: disabled as it causes duplicate hooks, see https://github.com/developit/preact/issues/750
                // flushMounts();

                if (component.componentDidUpdate) {
                    component.componentDidUpdate(previousProps, previousState, previousContext);
                }
                if (options.afterUpdate) options.afterUpdate(component);
            }

            if (component._renderCallbacks != null) {
                while (component._renderCallbacks.length) {
                    component._renderCallbacks.pop().call(component);
                }
            }

            if (!diffLevel && !isChild) flushMounts();
        }

        /** Apply the Component referenced by a VNode to the DOM.
         *	@param {Element} dom	The DOM node to mutate
         *	@param {VNode} vnode	A Component-referencing VNode
         *	@returns {Element} dom	The created/mutated element
         *	@private
         */
        function buildComponentFromVNode(dom, vnode, context, mountAll) {
            var c = dom && dom._component,
                originalComponent = c,
                oldDom = dom,
                isDirectOwner = c && dom._componentConstructor === vnode.nodeName,
                isOwner = isDirectOwner,
                props = getNodeProps(vnode);
            while (c && !isOwner && (c = c._parentComponent)) {
                isOwner = c.constructor === vnode.nodeName;
            }

            if (c && isOwner && (!mountAll || c._component)) {
                setComponentProps(c, props, 3, context, mountAll);
                dom = c.base;
            } else {
                if (originalComponent && !isDirectOwner) {
                    unmountComponent(originalComponent);
                    dom = oldDom = null;
                }

                c = createComponent(vnode.nodeName, props, context);
                if (dom && !c.nextBase) {
                    c.nextBase = dom;
                    // passing dom/oldDom as nextBase will recycle it if unused, so bypass recycling on L229:
                    oldDom = null;
                }
                setComponentProps(c, props, 1, context, mountAll);
                dom = c.base;

                if (oldDom && dom !== oldDom) {
                    oldDom._component = null;
                    recollectNodeTree(oldDom, false);
                }
            }

            return dom;
        }

        /** Remove a component from the DOM and recycle it.
         *	@param {Component} component	The Component instance to unmount
         *	@private
         */
        function unmountComponent(component) {
            if (options.beforeUnmount) options.beforeUnmount(component);

            var base = component.base;

            component._disable = true;

            if (component.componentWillUnmount) component.componentWillUnmount();

            component.base = null;

            // recursively tear down & recollect high-order component children:
            var inner = component._component;
            if (inner) {
                unmountComponent(inner);
            } else if (base) {
                if (base['__preactattr_'] && base['__preactattr_'].ref) base['__preactattr_'].ref(null);

                component.nextBase = base;

                removeNode(base);
                collectComponent(component);

                removeChildren(base);
            }

            if (component.__ref) component.__ref(null);
        }

        /** Base Component class.
         *	Provides `setState()` and `forceUpdate()`, which trigger rendering.
         *	@public
         *
         *	@example
         *	class MyFoo extends Component {
         *		render(props, state) {
         *			return <div />;
         *		}
         *	}
         */
        function Component(props, context) {
            this._dirty = true;

            /** @public
             *	@type {object}
             */
            this.context = context;

            /** @public
             *	@type {object}
             */
            this.props = props;

            /** @public
             *	@type {object}
             */
            this.state = this.state || {};
        }

        extend(Component.prototype, {

            /** Returns a `boolean` indicating if the component should re-render when receiving the given `props` and `state`.
             *	@param {object} nextProps
             *	@param {object} nextState
             *	@param {object} nextContext
             *	@returns {Boolean} should the component re-render
             *	@name shouldComponentUpdate
             *	@function
             */

            /** Update component state by copying properties from `state` to `this.state`.
             *	@param {object} state		A hash of state properties to update with new values
             *	@param {function} callback	A function to be called once component state is updated
             */
            setState: function setState(state, callback) {
                var s = this.state;
                if (!this.prevState) this.prevState = extend({}, s);
                extend(s, typeof state === 'function' ? state(s, this.props) : state);
                if (callback)(this._renderCallbacks = this._renderCallbacks || []).push(callback);
                enqueueRender(this);
            },


            /** Immediately perform a synchronous re-render of the component.
             *	@param {function} callback		A function to be called after component is re-rendered.
             *	@private
             */
            forceUpdate: function forceUpdate(callback) {
                if (callback)(this._renderCallbacks = this._renderCallbacks || []).push(callback);
                renderComponent(this, 2);
            },


            /** Accepts `props` and `state`, and returns a new Virtual DOM tree to build.
             *	Virtual DOM is generally constructed via [JSX](http://jasonformat.com/wtf-is-jsx).
             *	@param {object} props		Props (eg: JSX attributes) received from parent element/component
             *	@param {object} state		The component's current state
             *	@param {object} context		Context object (if a parent component has provided context)
             *	@returns VNode
             */
            render: function render() {}
        });

        /** Render JSX into a `parent` Element.
         *	@param {VNode} vnode		A (JSX) VNode to render
         *	@param {Element} parent		DOM element to render into
         *	@param {Element} [merge]	Attempt to re-use an existing DOM tree rooted at `merge`
         *	@public
         *
         *	@example
         *	// render a div into <body>:
         *	render(<div id="hello">hello!</div>, document.body);
         *
         *	@example
         *	// render a "Thing" component into #foo:
         *	const Thing = ({ name }) => <span>{ name }</span>;
         *	render(<Thing name="one" />, document.querySelector('#foo'));
         */
        function render(vnode, parent, merge) {
            return diff(merge, vnode, {}, false, parent, false);
        }

        var preact = {
            h: h,
            createElement: h,
            cloneElement: cloneElement,
            Component: Component,
            render: render,
            rerender: rerender,
            options: options
        };


        /* harmony default export */
        __webpack_exports__["default"] = (preact);
        //# sourceMappingURL=preact.esm.js.map


        /***/
    }),
    /* 4 */
    /***/
    (function(module, exports, __webpack_require__) {

        var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;
        /**
         * EvEmitter v1.1.0
         * Lil' event emitter
         * MIT License
         */

        /* jshint unused: true, undef: true, strict: true */

        (function(global, factory) {
            // universal module definition
            /* jshint strict: false */
            /* globals define, module, window */
            if (true) {
                // AMD - RequireJS
                !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
                    __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
                        (__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :
                        __WEBPACK_AMD_DEFINE_FACTORY__),
                    __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
            } else if (typeof module == 'object' && module.exports) {
                // CommonJS - Browserify, Webpack
                module.exports = factory();
            } else {
                // Browser globals
                global.EvEmitter = factory();
            }

        }(typeof window != 'undefined' ? window : this, function() {

            "use strict";

            function EvEmitter() {}

            var proto = EvEmitter.prototype;

            proto.on = function(eventName, listener) {
                if (!eventName || !listener) {
                    return;
                }
                // set events hash
                var events = this._events = this._events || {};
                // set listeners array
                var listeners = events[eventName] = events[eventName] || [];
                // only add once
                if (listeners.indexOf(listener) == -1) {
                    listeners.push(listener);
                }

                return this;
            };

            proto.once = function(eventName, listener) {
                if (!eventName || !listener) {
                    return;
                }
                // add event
                this.on(eventName, listener);
                // set once flag
                // set onceEvents hash
                var onceEvents = this._onceEvents = this._onceEvents || {};
                // set onceListeners object
                var onceListeners = onceEvents[eventName] = onceEvents[eventName] || {};
                // set flag
                onceListeners[listener] = true;

                return this;
            };

            proto.off = function(eventName, listener) {
                var listeners = this._events && this._events[eventName];
                if (!listeners || !listeners.length) {
                    return;
                }
                var index = listeners.indexOf(listener);
                if (index != -1) {
                    listeners.splice(index, 1);
                }

                return this;
            };

            proto.emitEvent = function(eventName, args) {
                var listeners = this._events && this._events[eventName];
                if (!listeners || !listeners.length) {
                    return;
                }
                // copy over to avoid interference if .off() in listener
                listeners = listeners.slice(0);
                args = args || [];
                // once stuff
                var onceListeners = this._onceEvents && this._onceEvents[eventName];

                for (var i = 0; i < listeners.length; i++) {
                    var listener = listeners[i]
                    var isOnce = onceListeners && onceListeners[listener];
                    if (isOnce) {
                        // remove listener
                        // remove before trigger to prevent recursion
                        this.off(eventName, listener);
                        // unset once flag
                        delete onceListeners[listener];
                    }
                    // trigger listener
                    listener.apply(this, args);
                }

                return this;
            };

            proto.allOff = function() {
                delete this._events;
                delete this._onceEvents;
            };

            return EvEmitter;

        }));


        /***/
    }),
    /* 5 */
    /***/
    (function(module, exports, __webpack_require__) {

        var __WEBPACK_AMD_DEFINE_RESULT__;
        /*!
         * getSize v2.0.2
         * measure size of elements
         * MIT license
         */

        /*jshint browser: true, strict: true, undef: true, unused: true */
        /*global define: false, module: false, console: false */

        (function(window, factory) {
            'use strict';

            if (true) {
                // AMD
                !(__WEBPACK_AMD_DEFINE_RESULT__ = function() {
                        return factory();
                    }.call(exports, __webpack_require__, exports, module),
                    __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
            } else if (typeof module == 'object' && module.exports) {
                // CommonJS
                module.exports = factory();
            } else {
                // browser global
                window.getSize = factory();
            }

        })(window, function factory() {
            'use strict';

            // -------------------------- helpers -------------------------- //

            // get a number from a string, not a percentage
            function getStyleSize(value) {
                var num = parseFloat(value);
                // not a percent like '100%', and a number
                var isValid = value.indexOf('%') == -1 && !isNaN(num);
                return isValid && num;
            }

            function noop() {}

            var logError = typeof console == 'undefined' ? noop :
                function(message) {
                    console.error(message);
                };

            // -------------------------- measurements -------------------------- //

            var measurements = [
                'paddingLeft',
                'paddingRight',
                'paddingTop',
                'paddingBottom',
                'marginLeft',
                'marginRight',
                'marginTop',
                'marginBottom',
                'borderLeftWidth',
                'borderRightWidth',
                'borderTopWidth',
                'borderBottomWidth'
            ];

            var measurementsLength = measurements.length;

            function getZeroSize() {
                var size = {
                    width: 0,
                    height: 0,
                    innerWidth: 0,
                    innerHeight: 0,
                    outerWidth: 0,
                    outerHeight: 0
                };
                for (var i = 0; i < measurementsLength; i++) {
                    var measurement = measurements[i];
                    size[measurement] = 0;
                }
                return size;
            }

            // -------------------------- getStyle -------------------------- //

            /**
             * getStyle, get style of element, check for Firefox bug
             * https://bugzilla.mozilla.org/show_bug.cgi?id=548397
             */
            function getStyle(elem) {
                var style = getComputedStyle(elem);
                if (!style) {
                    logError('Style returned ' + style +
                        '. Are you running this code in a hidden iframe on Firefox? ' +
                        'See http://bit.ly/getsizebug1');
                }
                return style;
            }

            // -------------------------- setup -------------------------- //

            var isSetup = false;

            var isBoxSizeOuter;

            /**
             * setup
             * check isBoxSizerOuter
             * do on first getSize() rather than on page load for Firefox bug
             */
            function setup() {
                // setup once
                if (isSetup) {
                    return;
                }
                isSetup = true;

                // -------------------------- box sizing -------------------------- //

                /**
                 * WebKit measures the outer-width on style.width on border-box elems
                 * IE & Firefox<29 measures the inner-width
                 */
                var div = document.createElement('div');
                div.style.width = '200px';
                div.style.padding = '1px 2px 3px 4px';
                div.style.borderStyle = 'solid';
                div.style.borderWidth = '1px 2px 3px 4px';
                div.style.boxSizing = 'border-box';

                var body = document.body || document.documentElement;
                body.appendChild(div);
                var style = getStyle(div);

                getSize.isBoxSizeOuter = isBoxSizeOuter = getStyleSize(style.width) == 200;
                body.removeChild(div);

            }

            // -------------------------- getSize -------------------------- //

            function getSize(elem) {
                setup();

                // use querySeletor if elem is string
                if (typeof elem == 'string') {
                    elem = document.querySelector(elem);
                }

                // do not proceed on non-objects
                if (!elem || typeof elem != 'object' || !elem.nodeType) {
                    return;
                }

                var style = getStyle(elem);

                // if hidden, everything is 0
                if (style.display == 'none') {
                    return getZeroSize();
                }

                var size = {};
                size.width = elem.offsetWidth;
                size.height = elem.offsetHeight;

                var isBorderBox = size.isBorderBox = style.boxSizing == 'border-box';

                // get all measurements
                for (var i = 0; i < measurementsLength; i++) {
                    var measurement = measurements[i];
                    var value = style[measurement];
                    var num = parseFloat(value);
                    // any 'auto', 'medium' value will be 0
                    size[measurement] = !isNaN(num) ? num : 0;
                }

                var paddingWidth = size.paddingLeft + size.paddingRight;
                var paddingHeight = size.paddingTop + size.paddingBottom;
                var marginWidth = size.marginLeft + size.marginRight;
                var marginHeight = size.marginTop + size.marginBottom;
                var borderWidth = size.borderLeftWidth + size.borderRightWidth;
                var borderHeight = size.borderTopWidth + size.borderBottomWidth;

                var isBorderBoxSizeOuter = isBorderBox && isBoxSizeOuter;

                // overwrite width and height if we can get it from style
                var styleWidth = getStyleSize(style.width);
                if (styleWidth !== false) {
                    size.width = styleWidth +
                        // add padding and border unless it's already including it
                        (isBorderBoxSizeOuter ? 0 : paddingWidth + borderWidth);
                }

                var styleHeight = getStyleSize(style.height);
                if (styleHeight !== false) {
                    size.height = styleHeight +
                        // add padding and border unless it's already including it
                        (isBorderBoxSizeOuter ? 0 : paddingHeight + borderHeight);
                }

                size.innerWidth = size.width - (paddingWidth + borderWidth);
                size.innerHeight = size.height - (paddingHeight + borderHeight);

                size.outerWidth = size.width + marginWidth;
                size.outerHeight = size.height + marginHeight;

                return size;
            }

            return getSize;

        });


        /***/
    }),
    /* 6 */
    /***/
    (function(module, exports, __webpack_require__) {

        var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;
        /*!
         * Unipointer v2.2.1
         * base class for doing one thing with pointer event
         * MIT license
         */

        /*jshint browser: true, undef: true, unused: true, strict: true */

        (function(window, factory) {
            // universal module definition
            /* jshint strict: false */
            /*global define, module, require */
            if (true) {
                // AMD
                !(__WEBPACK_AMD_DEFINE_ARRAY__ = [
                        __webpack_require__(4)
                    ], __WEBPACK_AMD_DEFINE_RESULT__ = function(EvEmitter) {
                        return factory(window, EvEmitter);
                    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
                    __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
            } else if (typeof module == 'object' && module.exports) {
                // CommonJS
                module.exports = factory(
                    window,
                    require('ev-emitter')
                );
            } else {
                // browser global
                window.Unipointer = factory(
                    window,
                    window.EvEmitter
                );
            }

        }(window, function factory(window, EvEmitter) {

            'use strict';

            function noop() {}

            function Unipointer() {}

            // inherit EvEmitter
            var proto = Unipointer.prototype = Object.create(EvEmitter.prototype);

            proto.bindStartEvent = function(elem) {
                this._bindStartEvent(elem, true);
            };

            proto.unbindStartEvent = function(elem) {
                this._bindStartEvent(elem, false);
            };

            /**
             * works as unbinder, as you can ._bindStart( false ) to unbind
             * @param {Boolean} isBind - will unbind if falsey
             */
            proto._bindStartEvent = function(elem, isBind) {
                // munge isBind, default to true
                isBind = isBind === undefined ? true : !!isBind;
                var bindMethod = isBind ? 'addEventListener' : 'removeEventListener';

                if (window.PointerEvent) {
                    // Pointer Events. Chrome 55, IE11, Edge 14
                    elem[bindMethod]('pointerdown', this);
                } else {
                    // listen for both, for devices like Chrome Pixel
                    elem[bindMethod]('mousedown', this);
                    elem[bindMethod]('touchstart', this);
                }
            };

            // trigger handler methods for events
            proto.handleEvent = function(event) {
                var method = 'on' + event.type;
                if (this[method]) {
                    this[method](event);
                }
            };

            // returns the touch that we're keeping track of
            proto.getTouch = function(touches) {
                for (var i = 0; i < touches.length; i++) {
                    var touch = touches[i];
                    if (touch.identifier == this.pointerIdentifier) {
                        return touch;
                    }
                }
            };

            // ----- start event ----- //

            proto.onmousedown = function(event) {
                // dismiss clicks from right or middle buttons
                var button = event.button;
                if (button && (button !== 0 && button !== 1)) {
                    return;
                }
                this._pointerDown(event, event);
            };

            proto.ontouchstart = function(event) {
                this._pointerDown(event, event.changedTouches[0]);
            };

            proto.onpointerdown = function(event) {
                this._pointerDown(event, event);
            };

            /**
             * pointer start
             * @param {Event} event
             * @param {Event or Touch} pointer
             */
            proto._pointerDown = function(event, pointer) {
                // dismiss right click and other pointers
                // button = 0 is okay, 1-4 not
                if (event.button || this.isPointerDown) {
                    return;
                }

                this.isPointerDown = true;
                // save pointer identifier to match up touch events
                this.pointerIdentifier = pointer.pointerId !== undefined ?
                    // pointerId for pointer events, touch.indentifier for touch events
                    pointer.pointerId : pointer.identifier;

                this.pointerDown(event, pointer);
            };

            proto.pointerDown = function(event, pointer) {
                this._bindPostStartEvents(event);
                this.emitEvent('pointerDown', [event, pointer]);
            };

            // hash of events to be bound after start event
            var postStartEvents = {
                mousedown: ['mousemove', 'mouseup'],
                touchstart: ['touchmove', 'touchend', 'touchcancel'],
                pointerdown: ['pointermove', 'pointerup', 'pointercancel'],
            };

            proto._bindPostStartEvents = function(event) {
                if (!event) {
                    return;
                }
                // get proper events to match start event
                var events = postStartEvents[event.type];
                // bind events to node
                events.forEach(function(eventName) {
                    window.addEventListener(eventName, this);
                }, this);
                // save these arguments
                this._boundPointerEvents = events;
            };

            proto._unbindPostStartEvents = function() {
                // check for _boundEvents, in case dragEnd triggered twice (old IE8 bug)
                if (!this._boundPointerEvents) {
                    return;
                }
                this._boundPointerEvents.forEach(function(eventName) {
                    window.removeEventListener(eventName, this);
                }, this);

                delete this._boundPointerEvents;
            };

            // ----- move event ----- //

            proto.onmousemove = function(event) {
                this._pointerMove(event, event);
            };

            proto.onpointermove = function(event) {
                if (event.pointerId == this.pointerIdentifier) {
                    this._pointerMove(event, event);
                }
            };

            proto.ontouchmove = function(event) {
                var touch = this.getTouch(event.changedTouches);
                if (touch) {
                    this._pointerMove(event, touch);
                }
            };

            /**
             * pointer move
             * @param {Event} event
             * @param {Event or Touch} pointer
             * @private
             */
            proto._pointerMove = function(event, pointer) {
                this.pointerMove(event, pointer);
            };

            // public
            proto.pointerMove = function(event, pointer) {
                this.emitEvent('pointerMove', [event, pointer]);
            };

            // ----- end event ----- //


            proto.onmouseup = function(event) {
                this._pointerUp(event, event);
            };

            proto.onpointerup = function(event) {
                if (event.pointerId == this.pointerIdentifier) {
                    this._pointerUp(event, event);
                }
            };

            proto.ontouchend = function(event) {
                var touch = this.getTouch(event.changedTouches);
                if (touch) {
                    this._pointerUp(event, touch);
                }
            };

            /**
             * pointer up
             * @param {Event} event
             * @param {Event or Touch} pointer
             * @private
             */
            proto._pointerUp = function(event, pointer) {
                this._pointerDone();
                this.pointerUp(event, pointer);
            };

            // public
            proto.pointerUp = function(event, pointer) {
                this.emitEvent('pointerUp', [event, pointer]);
            };

            // ----- pointer done ----- //

            // triggered on pointer up & pointer cancel
            proto._pointerDone = function() {
                // reset properties
                this.isPointerDown = false;
                delete this.pointerIdentifier;
                // remove events
                this._unbindPostStartEvents();
                this.pointerDone();
            };

            proto.pointerDone = noop;

            // ----- pointer cancel ----- //

            proto.onpointercancel = function(event) {
                if (event.pointerId == this.pointerIdentifier) {
                    this._pointerCancel(event, event);
                }
            };

            proto.ontouchcancel = function(event) {
                var touch = this.getTouch(event.changedTouches);
                if (touch) {
                    this._pointerCancel(event, touch);
                }
            };

            /**
             * pointer cancel
             * @param {Event} event
             * @param {Event or Touch} pointer
             * @private
             */
            proto._pointerCancel = function(event, pointer) {
                this._pointerDone();
                this.pointerCancel(event, pointer);
            };

            // public
            proto.pointerCancel = function(event, pointer) {
                this.emitEvent('pointerCancel', [event, pointer]);
            };

            // -----  ----- //

            // utility function for getting x/y coords from event
            Unipointer.getPointerPoint = function(pointer) {
                return {
                    x: pointer.pageX,
                    y: pointer.pageY
                };
            };

            // -----  ----- //

            return Unipointer;

        }));


        /***/
    }),
    /* 7 */
    /***/
    (function(module, exports, __webpack_require__) {

        var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;
        /*!
         * Tap listener v2.0.0
         * listens to taps
         * MIT license
         */

        /*jshint browser: true, unused: true, undef: true, strict: true */

        (function(window, factory) {
            // universal module definition
            /*jshint strict: false*/
            /*globals define, module, require */

            if (true) {
                // AMD
                !(__WEBPACK_AMD_DEFINE_ARRAY__ = [
                        __webpack_require__(6)
                    ], __WEBPACK_AMD_DEFINE_RESULT__ = function(Unipointer) {
                        return factory(window, Unipointer);
                    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
                    __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
            } else if (typeof module == 'object' && module.exports) {
                // CommonJS
                module.exports = factory(
                    window,
                    require('unipointer')
                );
            } else {
                // browser global
                window.TapListener = factory(
                    window,
                    window.Unipointer
                );
            }

        }(window, function factory(window, Unipointer) {

            'use strict';

            // --------------------------  TapListener -------------------------- //

            function TapListener(elem) {
                this.bindTap(elem);
            }

            // inherit Unipointer & EventEmitter
            var proto = TapListener.prototype = Object.create(Unipointer.prototype);

            /**
             * bind tap event to element
             * @param {Element} elem
             */
            proto.bindTap = function(elem) {
                if (!elem) {
                    return;
                }
                this.unbindTap();
                this.tapElement = elem;
                this._bindStartEvent(elem, true);
            };

            proto.unbindTap = function() {
                if (!this.tapElement) {
                    return;
                }
                this._bindStartEvent(this.tapElement, true);
                delete this.tapElement;
            };

            /**
             * pointer up
             * @param {Event} event
             * @param {Event or Touch} pointer
             */
            proto.pointerUp = function(event, pointer) {
                // ignore emulated mouse up clicks
                if (this.isIgnoringMouseUp && event.type == 'mouseup') {
                    return;
                }

                var pointerPoint = Unipointer.getPointerPoint(pointer);
                var boundingRect = this.tapElement.getBoundingClientRect();
                var scrollX = window.pageXOffset;
                var scrollY = window.pageYOffset;
                // calculate if pointer is inside tapElement
                var isInside = pointerPoint.x >= boundingRect.left + scrollX &&
                    pointerPoint.x <= boundingRect.right + scrollX &&
                    pointerPoint.y >= boundingRect.top + scrollY &&
                    pointerPoint.y <= boundingRect.bottom + scrollY;
                // trigger callback if pointer is inside element
                if (isInside) {
                    this.emitEvent('tap', [event, pointer]);
                }

                // set flag for emulated clicks 300ms after touchend
                if (event.type != 'mouseup') {
                    this.isIgnoringMouseUp = true;
                    // reset flag after 300ms
                    var _this = this;
                    setTimeout(function() {
                        delete _this.isIgnoringMouseUp;
                    }, 400);
                }
            };

            proto.destroy = function() {
                this.pointerDone();
                this.unbindTap();
            };

            // -----  ----- //

            return TapListener;

        }));


        /***/
    }),
    /* 8 */
    /***/
    (function(module, exports, __webpack_require__) {

        /* WEBPACK VAR INJECTION */
        (function(__webpack_provided_window_dot_jQuery, jQuery) { // ==================================================
            // fancyBox v3.2.5
            //
            // Licensed GPLv3 for open source use
            // or fancyBox Commercial License for commercial use
            //
            // http://fancyapps.com/fancybox/
            // Copyright 2017 fancyApps
            //
            // ==================================================
            ;
            (function(window, document, $, undefined) {
                'use strict';

                // If there's no jQuery, fancyBox can't work
                // =========================================

                if (!$) {
                    return;
                }

                // Check if fancyBox is already initialized
                // ========================================

                if ($.fn.fancybox) {

                    if ('console' in window) {
                        console.log('fancyBox already initialized');
                    }

                    return;
                }

                // Private default settings
                // ========================

                var defaults = {

                    // Enable infinite gallery navigation
                    loop: false,

                    // Space around image, ignored if zoomed-in or viewport width is smaller than 800px
                    margin: [44, 0],

                    // Horizontal space between slides
                    gutter: 50,

                    // Enable keyboard navigation
                    keyboard: true,

                    // Should display navigation arrows at the screen edges
                    arrows: true,

                    // Should display infobar (counter and arrows at the top)
                    infobar: true,

                    // Should display toolbar (buttons at the top)
                    toolbar: true,

                    // What buttons should appear in the top right corner.
                    // Buttons will be created using templates from `btnTpl` option
                    // and they will be placed into toolbar (class="fancybox-toolbar"` element)
                    buttons: [
                        'slideShow',
                        'fullScreen',
                        'thumbs',
                        'share',
                        //'download',
                        //'zoom',
                        'close'
                    ],

                    // Detect "idle" time in seconds
                    idleTime: 3,

                    // Should display buttons at top right corner of the content
                    // If 'auto' - they will be created for content having type 'html', 'inline' or 'ajax'
                    // Use template from `btnTpl.smallBtn` for customization
                    smallBtn: 'auto',

                    // Disable right-click and use simple image protection for images
                    protect: false,

                    // Shortcut to make content "modal" - disable keyboard navigtion, hide buttons, etc
                    modal: false,

                    image: {

                        // Wait for images to load before displaying
                        // Requires predefined image dimensions
                        // If 'auto' - will zoom in thumbnail if 'width' and 'height' attributes are found
                        preload: "auto"

                    },

                    ajax: {

                        // Object containing settings for ajax request
                        settings: {

                            // This helps to indicate that request comes from the modal
                            // Feel free to change naming
                            data: {
                                fancybox: true
                            }
                        }

                    },

                    iframe: {

                        // Iframe template
                        tpl: '<iframe id="fancybox-frame{rnd}" name="fancybox-frame{rnd}" class="fancybox-iframe" frameborder="0" vspace="0" hspace="0" webkitAllowFullScreen mozallowfullscreen allowFullScreen allowtransparency="true" src=""></iframe>',

                        // Preload iframe before displaying it
                        // This allows to calculate iframe content width and height
                        // (note: Due to "Same Origin Policy", you can't get cross domain data).
                        preload: true,

                        // Custom CSS styling for iframe wrapping element
                        // You can use this to set custom iframe dimensions
                        css: {},

                        // Iframe tag attributes
                        attr: {
                            scrolling: 'auto'
                        }

                    },

                    // Default content type if cannot be detected automatically
                    defaultType: 'image',

                    // Open/close animation type
                    // Possible values:
                    //   false            - disable
                    //   "zoom"           - zoom images from/to thumbnail
                    //   "fade"
                    //   "zoom-in-out"
                    //
                    animationEffect: "zoom",

                    // Duration in ms for open/close animation
                    animationDuration: 500,

                    // Should image change opacity while zooming
                    // If opacity is "auto", then opacity will be changed if image and thumbnail have different aspect ratios
                    zoomOpacity: "auto",

                    // Transition effect between slides
                    //
                    // Possible values:
                    //   false            - disable
                    //   "fade'
                    //   "slide'
                    //   "circular'
                    //   "tube'
                    //   "zoom-in-out'
                    //   "rotate'
                    //
                    transitionEffect: "fade",

                    // Duration in ms for transition animation
                    transitionDuration: 366,

                    // Custom CSS class for slide element
                    slideClass: '',

                    // Custom CSS class for layout
                    baseClass: '',

                    // Base template for layout
                    baseTpl: '<div class="fancybox-container" role="dialog" tabindex="-1">' +
                        '<div class="fancybox-bg"></div>' +
                        '<div class="fancybox-inner">' +
                        '<div class="fancybox-infobar">' +
                        '<span data-fancybox-index></span>&nbsp;/&nbsp;<span data-fancybox-count></span>' +
                        '</div>' +
                        '<div class="fancybox-toolbar">{{buttons}}</div>' +
                        '<div class="fancybox-navigation">{{arrows}}</div>' +
                        '<div class="fancybox-stage"></div>' +
                        '<div class="fancybox-caption-wrap"><div class="fancybox-caption"></div></div>' +
                        '</div>' +
                        '</div>',

                    // Loading indicator template
                    spinnerTpl: '<div class="fancybox-loading"></div>',

                    // Error message template
                    errorTpl: '<div class="fancybox-error"><p>{{ERROR}}<p></div>',

                    btnTpl: {

                        download: '<a download data-fancybox-download class="fancybox-button fancybox-button--download" title="{{DOWNLOAD}}">' +
                            '<svg viewBox="0 0 40 40">' +
                            '<path d="M20,23 L20,8 L20,23 L13,16 L20,23 L27,16 L20,23 M26,28 L13,28 L27,28 L14,28" />' +
                            '</svg>' +
                            '</a>',

                        zoom: '<button data-fancybox-zoom class="fancybox-button fancybox-button--zoom" title="{{ZOOM}}">' +
                            '<svg viewBox="0 0 40 40">' +
                            '<path d="M 18,17 m-8,0 a 8,8 0 1,0 16,0 a 8,8 0 1,0 -16,0 M25,23 L31,29 L25,23" />' +
                            '</svg>' +
                            '</button>',

                        close: '<button data-fancybox-close class="fancybox-button fancybox-button--close" title="{{CLOSE}}">' +
                            '<svg viewBox="0 0 40 40">' +
                            '<path d="M10,10 L30,30 M30,10 L10,30" />' +
                            '</svg>' +
                            '</button>',

                        // This small close button will be appended to your html/inline/ajax content by default,
                        // if "smallBtn" option is not set to false
                        smallBtn: '<button data-fancybox-close class="fancybox-close-small" title="{{CLOSE}}"></button>',

                        // Arrows
                        arrowLeft: '<button data-fancybox-prev class="fancybox-button fancybox-button--arrow_left" title="{{PREV}}">' +
                            '<svg viewBox="0 0 40 40">' +
                            '<path d="M10,20 L30,20 L10,20 L18,28 L10,20 L18,12 L10,20"></path>' +
                            '</svg>' +
                            '</button>',

                        arrowRight: '<button data-fancybox-next class="fancybox-button fancybox-button--arrow_right" title="{{NEXT}}">' +
                            '<svg viewBox="0 0 40 40">' +
                            '<path d="M30,20 L10,20 L30,20 L22,28 L30,20 L22,12 L30,20"></path>' +
                            '</svg>' +
                            '</button>'
                    },

                    // Container is injected into this element
                    parentEl: 'body',


                    // Focus handling
                    // ==============

                    // Try to focus on the first focusable element after opening
                    autoFocus: false,

                    // Put focus back to active element after closing
                    backFocus: true,

                    // Do not let user to focus on element outside modal content
                    trapFocus: true,


                    // Module specific options
                    // =======================

                    fullScreen: {
                        autoStart: false,
                    },

                    // Set `touch: false` to disable dragging/swiping
                    touch: {
                        vertical: true, // Allow to drag content vertically
                        momentum: true // Continue movement after releasing mouse/touch when panning
                    },

                    // Hash value when initializing manually,
                    // set `false` to disable hash change
                    hash: null,

                    // Customize or add new media types
                    // Example:
                    /*
                    media : {
                        youtube : {
                            params : {
                                autoplay : 0
                            }
                        }
                    }
                    */
                    media: {},

                    slideShow: {
                        autoStart: false,
                        speed: 4000
                    },

                    thumbs: {
                        autoStart: false, // Display thumbnails on opening
                        hideOnClose: true, // Hide thumbnail grid when closing animation starts
                        parentEl: '.fancybox-container', // Container is injected into this element
                        axis: 'y' // Vertical (y) or horizontal (x) scrolling
                    },

                    // Callbacks
                    //==========

                    // See Documentation/API/Events for more information
                    // Example:
                    /*
                        afterShow: function( instance, current ) {
                             console.info( 'Clicked element:' );
                             console.info( current.opts.$orig );
                        }
                    */

                    onInit: $.noop, // When instance has been initialized

                    beforeLoad: $.noop, // Before the content of a slide is being loaded
                    afterLoad: $.noop, // When the content of a slide is done loading

                    beforeShow: $.noop, // Before open animation starts
                    afterShow: $.noop, // When content is done loading and animating

                    beforeClose: $.noop, // Before the instance attempts to close. Return false to cancel the close.
                    afterClose: $.noop, // After instance has been closed

                    onActivate: $.noop, // When instance is brought to front
                    onDeactivate: $.noop, // When other instance has been activated


                    // Interaction
                    // ===========

                    // Use options below to customize taken action when user clicks or double clicks on the fancyBox area,
                    // each option can be string or method that returns value.
                    //
                    // Possible values:
                    //   "close"           - close instance
                    //   "next"            - move to next gallery item
                    //   "nextOrClose"     - move to next gallery item or close if gallery has only one item
                    //   "toggleControls"  - show/hide controls
                    //   "zoom"            - zoom image (if loaded)
                    //   false             - do nothing

                    // Clicked on the content
                    clickContent: function(current, event) {
                        return current.type === 'image' ? 'zoom' : false;
                    },

                    // Clicked on the slide
                    clickSlide: 'close',

                    // Clicked on the background (backdrop) element
                    clickOutside: 'close',

                    // Same as previous two, but for double click
                    dblclickContent: false,
                    dblclickSlide: false,
                    dblclickOutside: false,


                    // Custom options when mobile device is detected
                    // =============================================

                    mobile: {
                        margin: 0,

                        clickContent: function(current, event) {
                            return current.type === 'image' ? 'toggleControls' : false;
                        },
                        clickSlide: function(current, event) {
                            return current.type === 'image' ? 'toggleControls' : 'close';
                        },
                        dblclickContent: function(current, event) {
                            return current.type === 'image' ? 'zoom' : false;
                        },
                        dblclickSlide: function(current, event) {
                            return current.type === 'image' ? 'zoom' : false;
                        }
                    },


                    // Internationalization
                    // ============

                    lang: 'en',
                    i18n: {
                        'en': {
                            CLOSE: 'Close',
                            NEXT: 'Next',
                            PREV: 'Previous',
                            ERROR: 'The requested content cannot be loaded. <br/> Please try again later.',
                            PLAY_START: 'Start slideshow',
                            PLAY_STOP: 'Pause slideshow',
                            FULL_SCREEN: 'Full screen',
                            THUMBS: 'Thumbnails',
                            DOWNLOAD: 'Download',
                            SHARE: 'Share',
                            ZOOM: 'Zoom'
                        },
                        'de': {
                            CLOSE: 'Schliessen',
                            NEXT: 'Weiter',
                            PREV: 'Zurück',
                            ERROR: 'Die angeforderten Daten konnten nicht geladen werden. <br/> Bitte versuchen Sie es später nochmal.',
                            PLAY_START: 'Diaschau starten',
                            PLAY_STOP: 'Diaschau beenden',
                            FULL_SCREEN: 'Vollbild',
                            THUMBS: 'Vorschaubilder',
                            DOWNLOAD: 'Herunterladen',
                            SHARE: 'Teilen',
                            ZOOM: 'Maßstab'
                        }
                    }

                };

                // Few useful variables and methods
                // ================================

                var $W = $(window);
                var $D = $(document);

                var called = 0;


                // Check if an object is a jQuery object and not a native JavaScript object
                // ========================================================================

                var isQuery = function(obj) {
                    return obj && obj.hasOwnProperty && obj instanceof $;
                };


                // Handle multiple browsers for "requestAnimationFrame" and "cancelAnimationFrame"
                // ===============================================================================

                var requestAFrame = (function() {
                    return window.requestAnimationFrame ||
                        window.webkitRequestAnimationFrame ||
                        window.mozRequestAnimationFrame ||
                        window.oRequestAnimationFrame ||
                        // if all else fails, use setTimeout
                        function(callback) {
                            return window.setTimeout(callback, 1000 / 60);
                        };
                })();


                // Detect the supported transition-end event property name
                // =======================================================

                var transitionEnd = (function() {
                    var t, el = document.createElement("fakeelement");

                    var transitions = {
                        "transition": "transitionend",
                        "OTransition": "oTransitionEnd",
                        "MozTransition": "transitionend",
                        "WebkitTransition": "webkitTransitionEnd"
                    };

                    for (t in transitions) {
                        if (el.style[t] !== undefined) {
                            return transitions[t];
                        }
                    }

                    return 'transitionend';
                })();


                // Force redraw on an element.
                // This helps in cases where the browser doesn't redraw an updated element properly.
                // =================================================================================

                var forceRedraw = function($el) {
                    return ($el && $el.length && $el[0].offsetHeight);
                };


                // Class definition
                // ================

                var FancyBox = function(content, opts, index) {
                    var self = this;

                    self.opts = $.extend(true, {
                        index: index
                    }, $.fancybox.defaults, opts || {});

                    if ($.fancybox.isMobile) {
                        self.opts = $.extend(true, {}, self.opts, self.opts.mobile);
                    }

                    // Exclude buttons option from deep merging
                    if (opts && $.isArray(opts.buttons)) {
                        self.opts.buttons = opts.buttons;
                    }

                    self.id = self.opts.id || ++called;
                    self.group = [];

                    self.currIndex = parseInt(self.opts.index, 10) || 0;
                    self.prevIndex = null;

                    self.prevPos = null;
                    self.currPos = 0;

                    self.firstRun = null;

                    // Create group elements from original item collection
                    self.createGroup(content);

                    if (!self.group.length) {
                        return;
                    }

                    // Save last active element and current scroll position
                    self.$lastFocus = $(document.activeElement).blur();

                    // Collection of gallery objects
                    self.slides = {};

                    self.init();
                };

                $.extend(FancyBox.prototype, {

                    // Create DOM structure
                    // ====================

                    init: function() {
                        var self = this,
                            firstItem = self.group[self.currIndex],
                            firstItemOpts = firstItem.opts,
                            scrollbarWidth = $.fancybox.scrollbarWidth,
                            $scrollDiv,
                            $container,
                            buttonStr;

                        self.scrollTop = $D.scrollTop();
                        self.scrollLeft = $D.scrollLeft();


                        // Hide scrollbars
                        // ===============

                        if (!$.fancybox.getInstance()) {

                            $('body').addClass('fancybox-active');

                            // iOS hack
                            if (/iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream) {

                                // iOS has problems for input elements inside fixed containers,
                                // the workaround is to apply `position: fixed` to `<body>` element,
                                // unfortunately, this makes it lose the scrollbars and forces address bar to appear.

                                if (firstItem.type !== 'image') {
                                    $('body').css('top', $('body').scrollTop() * -1).addClass('fancybox-iosfix');
                                }

                            } else if (!$.fancybox.isMobile && document.body.scrollHeight > window.innerHeight) {

                                if (scrollbarWidth === undefined) {
                                    $scrollDiv = $('<div style="width:50px;height:50px;overflow:scroll;" />').appendTo('body');

                                    scrollbarWidth = $.fancybox.scrollbarWidth = $scrollDiv[0].offsetWidth - $scrollDiv[0].clientWidth;

                                    $scrollDiv.remove();
                                }

                                $('head').append('<style id="fancybox-style-noscroll" type="text/css">.compensate-for-scrollbar { margin-right: ' + scrollbarWidth + 'px; }</style>');
                                $('body').addClass('compensate-for-scrollbar');
                            }
                        }


                        // Build html markup and set references
                        // ====================================

                        // Build html code for buttons and insert into main template
                        buttonStr = '';

                        $.each(firstItemOpts.buttons, function(index, value) {
                            buttonStr += (firstItemOpts.btnTpl[value] || '');
                        });

                        // Create markup from base template, it will be initially hidden to
                        // avoid unnecessary work like painting while initializing is not complete
                        $container = $(
                                self.translate(self,
                                    firstItemOpts.baseTpl
                                    .replace('\{\{buttons\}\}', buttonStr)
                                    .replace('\{\{arrows\}\}', firstItemOpts.btnTpl.arrowLeft + firstItemOpts.btnTpl.arrowRight)
                                )
                            )
                            .attr('id', 'fancybox-container-' + self.id)
                            .addClass('fancybox-is-hidden')
                            .addClass(firstItemOpts.baseClass)
                            .data('FancyBox', self)
                            .appendTo(firstItemOpts.parentEl);

                        // Create object holding references to jQuery wrapped nodes
                        self.$refs = {
                            container: $container
                        };

                        ['bg', 'inner', 'infobar', 'toolbar', 'stage', 'caption', 'navigation'].forEach(function(item) {
                            self.$refs[item] = $container.find('.fancybox-' + item);
                        });

                        self.trigger('onInit');

                        // Enable events, deactive previous instances
                        self.activate();

                        // Build slides, load and reveal content
                        self.jumpTo(self.currIndex);
                    },


                    // Simple i18n support - replaces object keys found in template
                    // with corresponding values
                    // ============================================================

                    translate: function(obj, str) {
                        var arr = obj.opts.i18n[obj.opts.lang];

                        return str.replace(/\{\{(\w+)\}\}/g, function(match, n) {
                            var value = arr[n];

                            if (value === undefined) {
                                return match;
                            }

                            return value;
                        });
                    },

                    // Create array of gally item objects
                    // Check if each object has valid type and content
                    // ===============================================

                    createGroup: function(content) {
                        var self = this;
                        var items = $.makeArray(content);

                        $.each(items, function(i, item) {
                            var obj = {},
                                opts = {},
                                $item,
                                type,
                                src,
                                srcParts;

                            // Step 1 - Make sure we have an object
                            // ====================================

                            if ($.isPlainObject(item)) {

                                // We probably have manual usage here, something like
                                // $.fancybox.open( [ { src : "image.jpg", type : "image" } ] )

                                obj = item;
                                opts = item.opts || item;

                            } else if ($.type(item) === 'object' && $(item).length) {

                                // Here we probably have jQuery collection returned by some selector
                                $item = $(item);

                                opts = $item.data();
                                opts = $.extend({}, opts, opts.options || {});

                                // Here we store clicked element
                                opts.$orig = $item;

                                obj.src = opts.src || $item.attr('href');

                                // Assume that simple syntax is used, for example:
                                //   `$.fancybox.open( $("#test"), {} );`
                                if (!obj.type && !obj.src) {
                                    obj.type = 'inline';
                                    obj.src = item;
                                }

                            } else {

                                // Assume we have a simple html code, for example:
                                //   $.fancybox.open( '<div><h1>Hi!</h1></div>' );

                                obj = {
                                    type: 'html',
                                    src: item + ''
                                };

                            }

                            // Each gallery object has full collection of options
                            obj.opts = $.extend(true, {}, self.opts, opts);

                            // Do not merge buttons array
                            if ($.isArray(opts.buttons)) {
                                obj.opts.buttons = opts.buttons;
                            }


                            // Step 2 - Make sure we have content type, if not - try to guess
                            // ==============================================================

                            type = obj.type || obj.opts.type;
                            src = obj.src || '';

                            if (!type && src) {
                                if (src.match(/(^data:image\/[a-z0-9+\/=]*,)|(\.(jp(e|g|eg)|gif|png|bmp|webp|svg|ico)((\?|#).*)?$)/i)) {
                                    type = 'image';

                                } else if (src.match(/\.(pdf)((\?|#).*)?$/i)) {
                                    type = 'pdf';

                                } else if (src.charAt(0) === '#') {
                                    type = 'inline';
                                }
                            }

                            if (type) {
                                obj.type = type;

                            } else {
                                self.trigger('objectNeedsType', obj);
                            }


                            // Step 3 - Some adjustments
                            // =========================

                            obj.index = self.group.length;

                            // Check if $orig and $thumb objects exist
                            if (obj.opts.$orig && !obj.opts.$orig.length) {
                                delete obj.opts.$orig;
                            }

                            if (!obj.opts.$thumb && obj.opts.$orig) {
                                obj.opts.$thumb = obj.opts.$orig.find('img:first');
                            }

                            if (obj.opts.$thumb && !obj.opts.$thumb.length) {
                                delete obj.opts.$thumb;
                            }

                            // "caption" is a "special" option, it can be used to customize caption per gallery item ..
                            if ($.type(obj.opts.caption) === 'function') {
                                obj.opts.caption = obj.opts.caption.apply(item, [self, obj]);
                            }

                            if ($.type(self.opts.caption) === 'function') {
                                obj.opts.caption = self.opts.caption.apply(item, [self, obj]);
                            }

                            // Make sure we have caption as a string or jQuery object
                            if (!(obj.opts.caption instanceof $)) {
                                obj.opts.caption = obj.opts.caption === undefined ? '' : obj.opts.caption + '';
                            }

                            // Check if url contains "filter" used to filter the content
                            // Example: "ajax.html #something"
                            if (type === 'ajax') {
                                srcParts = src.split(/\s+/, 2);

                                if (srcParts.length > 1) {
                                    obj.src = srcParts.shift();

                                    obj.opts.filter = srcParts.shift();
                                }
                            }

                            if (obj.opts.smallBtn == 'auto') {

                                if ($.inArray(type, ['html', 'inline', 'ajax']) > -1) {
                                    obj.opts.toolbar = false;
                                    obj.opts.smallBtn = true;

                                } else {
                                    obj.opts.smallBtn = false;
                                }

                            }

                            // If the type is "pdf", then simply load file into iframe
                            if (type === 'pdf') {
                                obj.type = 'iframe';

                                obj.opts.iframe.preload = false;
                            }

                            // Hide all buttons and disable interactivity for modal items
                            if (obj.opts.modal) {

                                obj.opts = $.extend(true, obj.opts, {
                                    // Remove buttons
                                    infobar: 0,
                                    toolbar: 0,

                                    smallBtn: 0,

                                    // Disable keyboard navigation
                                    keyboard: 0,

                                    // Disable some modules
                                    slideShow: 0,
                                    fullScreen: 0,
                                    thumbs: 0,
                                    touch: 0,

                                    // Disable click event handlers
                                    clickContent: false,
                                    clickSlide: false,
                                    clickOutside: false,
                                    dblclickContent: false,
                                    dblclickSlide: false,
                                    dblclickOutside: false
                                });

                            }

                            // Step 4 - Add processed object to group
                            // ======================================

                            self.group.push(obj);

                        });

                    },


                    // Attach an event handler functions for:
                    //   - navigation buttons
                    //   - browser scrolling, resizing;
                    //   - focusing
                    //   - keyboard
                    //   - detect idle
                    // ======================================

                    addEvents: function() {
                        var self = this;

                        self.removeEvents();

                        // Make navigation elements clickable
                        self.$refs.container.on('click.fb-close', '[data-fancybox-close]', function(e) {
                            e.stopPropagation();
                            e.preventDefault();

                            self.close(e);

                        }).on('click.fb-prev touchend.fb-prev', '[data-fancybox-prev]', function(e) {
                            e.stopPropagation();
                            e.preventDefault();

                            self.previous();

                        }).on('click.fb-next touchend.fb-next', '[data-fancybox-next]', function(e) {
                            e.stopPropagation();
                            e.preventDefault();

                            self.next();

                        }).on('click.fb', '[data-fancybox-zoom]', function(e) {
                            // Click handler for zoom button
                            self[self.isScaledDown() ? 'scaleToActual' : 'scaleToFit']();
                        });


                        // Handle page scrolling and browser resizing
                        $W.on('orientationchange.fb resize.fb', function(e) {

                            if (e && e.originalEvent && e.originalEvent.type === "resize") {

                                requestAFrame(function() {
                                    self.update();
                                });

                            } else {

                                self.$refs.stage.hide();

                                setTimeout(function() {
                                    self.$refs.stage.show();

                                    self.update();
                                }, 600);

                            }

                        });

                        // Trap keyboard focus inside of the modal, so the user does not accidentally tab outside of the modal
                        // (a.k.a. "escaping the modal")
                        $D.on('focusin.fb', function(e) {
                            var instance = $.fancybox ? $.fancybox.getInstance() : null;

                            if (instance.isClosing || !instance.current || !instance.current.opts.trapFocus || $(e.target).hasClass('fancybox-container') || $(e.target).is(document)) {
                                return;
                            }

                            if (instance && $(e.target).css('position') !== 'fixed' && !instance.$refs.container.has(e.target).length) {
                                e.stopPropagation();

                                instance.focus();

                                // Sometimes page gets scrolled, set it back
                                $W.scrollTop(self.scrollTop).scrollLeft(self.scrollLeft);
                            }
                        });


                        // Enable keyboard navigation
                        $D.on('keydown.fb', function(e) {
                            var current = self.current,
                                keycode = e.keyCode || e.which;

                            if (!current || !current.opts.keyboard) {
                                return;
                            }

                            if ($(e.target).is('input') || $(e.target).is('textarea')) {
                                return;
                            }

                            // Backspace and Esc keys
                            if (keycode === 8 || keycode === 27) {
                                e.preventDefault();

                                self.close(e);

                                return;
                            }

                            // Left arrow and Up arrow
                            if (keycode === 37 || keycode === 38) {
                                e.preventDefault();

                                self.previous();

                                return;
                            }

                            // Righ arrow and Down arrow
                            if (keycode === 39 || keycode === 40) {
                                e.preventDefault();

                                self.next();

                                return;
                            }

                            self.trigger('afterKeydown', e, keycode);
                        });


                        // Hide controls after some inactivity period
                        if (self.group[self.currIndex].opts.idleTime) {
                            self.idleSecondsCounter = 0;

                            $D.on('mousemove.fb-idle mouseleave.fb-idle mousedown.fb-idle touchstart.fb-idle touchmove.fb-idle scroll.fb-idle keydown.fb-idle', function(e) {
                                self.idleSecondsCounter = 0;

                                if (self.isIdle) {
                                    self.showControls();
                                }

                                self.isIdle = false;
                            });

                            self.idleInterval = window.setInterval(function() {
                                self.idleSecondsCounter++;

                                if (self.idleSecondsCounter >= self.group[self.currIndex].opts.idleTime) {
                                    self.isIdle = true;
                                    self.idleSecondsCounter = 0;

                                    self.hideControls();
                                }

                            }, 1000);
                        }

                    },


                    // Remove events added by the core
                    // ===============================

                    removeEvents: function() {
                        var self = this;

                        $W.off('orientationchange.fb resize.fb');
                        $D.off('focusin.fb keydown.fb .fb-idle');

                        this.$refs.container.off('.fb-close .fb-prev .fb-next');

                        if (self.idleInterval) {
                            window.clearInterval(self.idleInterval);

                            self.idleInterval = null;
                        }
                    },


                    // Change to previous gallery item
                    // ===============================

                    previous: function(duration) {
                        return this.jumpTo(this.currPos - 1, duration);
                    },


                    // Change to next gallery item
                    // ===========================

                    next: function(duration) {
                        return this.jumpTo(this.currPos + 1, duration);
                    },


                    // Switch to selected gallery item
                    // ===============================

                    jumpTo: function(pos, duration, slide) {
                        var self = this,
                            firstRun,
                            loop,
                            current,
                            previous,
                            canvasWidth,
                            currentPos,
                            transitionProps;

                        var groupLen = self.group.length;

                        if (self.isSliding || self.isClosing || (self.isAnimating && self.firstRun)) {
                            return;
                        }

                        pos = parseInt(pos, 10);
                        loop = self.current ? self.current.opts.loop : self.opts.loop;

                        if (!loop && (pos < 0 || pos >= groupLen)) {
                            return false;
                        }

                        firstRun = self.firstRun = (self.firstRun === null);

                        if (groupLen < 2 && !firstRun && !!self.isSliding) {
                            return;
                        }

                        previous = self.current;

                        self.prevIndex = self.currIndex;
                        self.prevPos = self.currPos;

                        // Create slides
                        current = self.createSlide(pos);

                        if (groupLen > 1) {
                            if (loop || current.index > 0) {
                                self.createSlide(pos - 1);
                            }

                            if (loop || current.index < groupLen - 1) {
                                self.createSlide(pos + 1);
                            }
                        }

                        self.current = current;
                        self.currIndex = current.index;
                        self.currPos = current.pos;

                        self.trigger('beforeShow', firstRun);

                        self.updateControls();

                        currentPos = $.fancybox.getTranslate(current.$slide);

                        current.isMoved = (currentPos.left !== 0 || currentPos.top !== 0) && !current.$slide.hasClass('fancybox-animated');
                        current.forcedDuration = undefined;

                        if ($.isNumeric(duration)) {
                            current.forcedDuration = duration;
                        } else {
                            duration = current.opts[firstRun ? 'animationDuration' : 'transitionDuration'];
                        }

                        duration = parseInt(duration, 10);

                        // Fresh start - reveal container, current slide and start loading content
                        if (firstRun) {

                            if (current.opts.animationEffect && duration) {
                                self.$refs.container.css('transition-duration', duration + 'ms');
                            }

                            self.$refs.container.removeClass('fancybox-is-hidden');

                            forceRedraw(self.$refs.container);

                            self.$refs.container.addClass('fancybox-is-open');

                            // Make first slide visible (to display loading icon, if needed)
                            current.$slide.addClass('fancybox-slide--current');

                            self.loadSlide(current);

                            self.preload();

                            return;
                        }

                        // Clean up
                        $.each(self.slides, function(index, slide) {
                            $.fancybox.stop(slide.$slide);
                        });

                        // Make current that slide is visible even if content is still loading
                        current.$slide.removeClass('fancybox-slide--next fancybox-slide--previous').addClass('fancybox-slide--current');

                        // If slides have been dragged, animate them to correct position
                        if (current.isMoved) {
                            canvasWidth = Math.round(current.$slide.width());

                            $.each(self.slides, function(index, slide) {
                                var pos = slide.pos - current.pos;

                                $.fancybox.animate(slide.$slide, {
                                    top: 0,
                                    left: (pos * canvasWidth) + (pos * slide.opts.gutter)
                                }, duration, function() {

                                    slide.$slide.removeAttr('style').removeClass('fancybox-slide--next fancybox-slide--previous');

                                    if (slide.pos === self.currPos) {
                                        current.isMoved = false;

                                        self.complete();
                                    }
                                });
                            });

                        } else {
                            self.$refs.stage.children().removeAttr('style');
                        }

                        // Start transition that reveals current content
                        // or wait when it will be loaded

                        if (current.isLoaded) {
                            self.revealContent(current);

                        } else {
                            self.loadSlide(current);
                        }

                        self.preload();

                        if (previous.pos === current.pos) {
                            return;
                        }

                        // Handle previous slide
                        // =====================

                        transitionProps = 'fancybox-slide--' + (previous.pos > current.pos ? 'next' : 'previous');

                        previous.$slide.removeClass('fancybox-slide--complete fancybox-slide--current fancybox-slide--next fancybox-slide--previous');

                        previous.isComplete = false;

                        if (!duration || (!current.isMoved && !current.opts.transitionEffect)) {
                            return;
                        }

                        if (current.isMoved) {
                            previous.$slide.addClass(transitionProps);

                        } else {

                            transitionProps = 'fancybox-animated ' + transitionProps + ' fancybox-fx-' + current.opts.transitionEffect;

                            $.fancybox.animate(previous.$slide, transitionProps, duration, function() {
                                previous.$slide.removeClass(transitionProps).removeAttr('style');
                            });

                        }

                    },


                    // Create new "slide" element
                    // These are gallery items  that are actually added to DOM
                    // =======================================================

                    createSlide: function(pos) {

                        var self = this;
                        var $slide;
                        var index;

                        index = pos % self.group.length;
                        index = index < 0 ? self.group.length + index : index;

                        if (!self.slides[pos] && self.group[index]) {
                            $slide = $('<div class="fancybox-slide"></div>').appendTo(self.$refs.stage);

                            self.slides[pos] = $.extend(true, {}, self.group[index], {
                                pos: pos,
                                $slide: $slide,
                                isLoaded: false,
                            });

                            self.updateSlide(self.slides[pos]);
                        }

                        return self.slides[pos];
                    },


                    // Scale image to the actual size of the image
                    // ===========================================

                    scaleToActual: function(x, y, duration) {

                        var self = this;

                        var current = self.current;
                        var $what = current.$content;

                        var imgPos, posX, posY, scaleX, scaleY;

                        var canvasWidth = parseInt(current.$slide.width(), 10);
                        var canvasHeight = parseInt(current.$slide.height(), 10);

                        var newImgWidth = current.width;
                        var newImgHeight = current.height;

                        if (!(current.type == 'image' && !current.hasError) || !$what || self.isAnimating) {
                            return;
                        }

                        $.fancybox.stop($what);

                        self.isAnimating = true;

                        x = x === undefined ? canvasWidth * 0.5 : x;
                        y = y === undefined ? canvasHeight * 0.5 : y;

                        imgPos = $.fancybox.getTranslate($what);

                        scaleX = newImgWidth / imgPos.width;
                        scaleY = newImgHeight / imgPos.height;

                        // Get center position for original image
                        posX = (canvasWidth * 0.5 - newImgWidth * 0.5);
                        posY = (canvasHeight * 0.5 - newImgHeight * 0.5);

                        // Make sure image does not move away from edges
                        if (newImgWidth > canvasWidth) {
                            posX = imgPos.left * scaleX - ((x * scaleX) - x);

                            if (posX > 0) {
                                posX = 0;
                            }

                            if (posX < canvasWidth - newImgWidth) {
                                posX = canvasWidth - newImgWidth;
                            }
                        }

                        if (newImgHeight > canvasHeight) {
                            posY = imgPos.top * scaleY - ((y * scaleY) - y);

                            if (posY > 0) {
                                posY = 0;
                            }

                            if (posY < canvasHeight - newImgHeight) {
                                posY = canvasHeight - newImgHeight;
                            }
                        }

                        self.updateCursor(newImgWidth, newImgHeight);

                        $.fancybox.animate($what, {
                            top: posY,
                            left: posX,
                            scaleX: scaleX,
                            scaleY: scaleY
                        }, duration || 330, function() {
                            self.isAnimating = false;
                        });

                        // Stop slideshow
                        if (self.SlideShow && self.SlideShow.isActive) {
                            self.SlideShow.stop();
                        }
                    },


                    // Scale image to fit inside parent element
                    // ========================================

                    scaleToFit: function(duration) {

                        var self = this;

                        var current = self.current;
                        var $what = current.$content;
                        var end;

                        if (!(current.type == 'image' && !current.hasError) || !$what || self.isAnimating) {
                            return;
                        }

                        $.fancybox.stop($what);

                        self.isAnimating = true;

                        end = self.getFitPos(current);

                        self.updateCursor(end.width, end.height);

                        $.fancybox.animate($what, {
                            top: end.top,
                            left: end.left,
                            scaleX: end.width / $what.width(),
                            scaleY: end.height / $what.height()
                        }, duration || 330, function() {
                            self.isAnimating = false;
                        });

                    },

                    // Calculate image size to fit inside viewport
                    // ===========================================

                    getFitPos: function(slide) {
                        var self = this;
                        var $what = slide.$content;

                        var imgWidth = slide.width;
                        var imgHeight = slide.height;

                        var margin = slide.opts.margin;

                        var canvasWidth, canvasHeight, minRatio, width, height;

                        if (!$what || !$what.length || (!imgWidth && !imgHeight)) {
                            return false;
                        }

                        // Convert "margin to CSS style: [ top, right, bottom, left ]
                        if ($.type(margin) === "number") {
                            margin = [margin, margin];
                        }

                        if (margin.length == 2) {
                            margin = [margin[0], margin[1], margin[0], margin[1]];
                        }

                        // We can not use $slide width here, because it can have different diemensions while in transiton
                        canvasWidth = parseInt(self.$refs.stage.width(), 10) - (margin[1] + margin[3]);
                        canvasHeight = parseInt(self.$refs.stage.height(), 10) - (margin[0] + margin[2]);

                        minRatio = Math.min(1, canvasWidth / imgWidth, canvasHeight / imgHeight);

                        width = Math.floor(minRatio * imgWidth);
                        height = Math.floor(minRatio * imgHeight);

                        // Use floor rounding to make sure it really fits
                        return {
                            top: Math.floor((canvasHeight - height) * 0.5) + margin[0],
                            left: Math.floor((canvasWidth - width) * 0.5) + margin[3],
                            width: width,
                            height: height
                        };

                    },


                    // Update position and content of all slides
                    // =========================================

                    update: function() {

                        var self = this;

                        $.each(self.slides, function(key, slide) {
                            self.updateSlide(slide);
                        });

                    },


                    // Update slide position and scale content to fit
                    // ==============================================

                    updateSlide: function(slide) {

                        var self = this;
                        var $what = slide.$content;

                        if ($what && (slide.width || slide.height)) {
                            self.isAnimating = false;

                            $.fancybox.stop($what);

                            $.fancybox.setTranslate($what, self.getFitPos(slide));

                            if (slide.pos === self.currPos) {
                                self.updateCursor();
                            }
                        }

                        slide.$slide.trigger('refresh');

                        self.trigger('onUpdate', slide);

                    },

                    // Update cursor style depending if content can be zoomed
                    // ======================================================

                    updateCursor: function(nextWidth, nextHeight) {

                        var self = this;
                        var isScaledDown;

                        var $container = self.$refs.container.removeClass('fancybox-is-zoomable fancybox-can-zoomIn fancybox-can-drag fancybox-can-zoomOut');

                        if (!self.current || self.isClosing) {
                            return;
                        }

                        if (self.isZoomable()) {

                            $container.addClass('fancybox-is-zoomable');

                            if (nextWidth !== undefined && nextHeight !== undefined) {
                                isScaledDown = nextWidth < self.current.width && nextHeight < self.current.height;

                            } else {
                                isScaledDown = self.isScaledDown();
                            }

                            if (isScaledDown) {

                                // If image is scaled down, then, obviously, it can be zoomed to full size
                                $container.addClass('fancybox-can-zoomIn');

                            } else {

                                if (self.current.opts.touch) {

                                    // If image size ir largen than available available and touch module is not disable,
                                    // then user can do panning
                                    $container.addClass('fancybox-can-drag');

                                } else {
                                    $container.addClass('fancybox-can-zoomOut');
                                }

                            }

                        } else if (self.current.opts.touch) {
                            $container.addClass('fancybox-can-drag');
                        }

                    },


                    // Check if current slide is zoomable
                    // ==================================

                    isZoomable: function() {

                        var self = this;

                        var current = self.current;
                        var fitPos;

                        if (!current || self.isClosing) {
                            return;
                        }

                        // Assume that slide is zoomable if
                        //   - image is loaded successfuly
                        //   - click action is "zoom"
                        //   - actual size of the image is smaller than available area
                        if (current.type === 'image' && current.isLoaded && !current.hasError &&
                            (current.opts.clickContent === 'zoom' || ($.isFunction(current.opts.clickContent) && current.opts.clickContent(current) === "zoom"))
                        ) {

                            fitPos = self.getFitPos(current);

                            if (current.width > fitPos.width || current.height > fitPos.height) {
                                return true;
                            }

                        }

                        return false;

                    },


                    // Check if current image dimensions are smaller than actual
                    // =========================================================

                    isScaledDown: function() {

                        var self = this;

                        var current = self.current;
                        var $what = current.$content;

                        var rez = false;

                        if ($what) {
                            rez = $.fancybox.getTranslate($what);
                            rez = rez.width < current.width || rez.height < current.height;
                        }

                        return rez;

                    },


                    // Check if image dimensions exceed parent element
                    // ===============================================

                    canPan: function() {

                        var self = this;

                        var current = self.current;
                        var $what = current.$content;

                        var rez = false;

                        if ($what) {
                            rez = self.getFitPos(current);
                            rez = Math.abs($what.width() - rez.width) > 1 || Math.abs($what.height() - rez.height) > 1;

                        }

                        return rez;

                    },


                    // Load content into the slide
                    // ===========================

                    loadSlide: function(slide) {

                        var self = this,
                            type, $slide;
                        var ajaxLoad;

                        if (slide.isLoading) {
                            return;
                        }

                        if (slide.isLoaded) {
                            return;
                        }

                        slide.isLoading = true;

                        self.trigger('beforeLoad', slide);

                        type = slide.type;
                        $slide = slide.$slide;

                        $slide
                            .off('refresh')
                            .trigger('onReset')
                            .addClass('fancybox-slide--' + (type || 'unknown'))
                            .addClass(slide.opts.slideClass);

                        // Create content depending on the type

                        switch (type) {

                            case 'image':

                                self.setImage(slide);

                                break;

                            case 'iframe':

                                self.setIframe(slide);

                                break;

                            case 'html':

                                self.setContent(slide, slide.src || slide.content);

                                break;

                            case 'inline':

                                if ($(slide.src).length) {
                                    self.setContent(slide, $(slide.src));

                                } else {
                                    self.setError(slide);
                                }

                                break;

                            case 'ajax':

                                self.showLoading(slide);

                                ajaxLoad = $.ajax($.extend({}, slide.opts.ajax.settings, {
                                    url: slide.src,
                                    success: function(data, textStatus) {

                                        if (textStatus === 'success') {
                                            self.setContent(slide, data);
                                        }

                                    },
                                    error: function(jqXHR, textStatus) {

                                        if (jqXHR && textStatus !== 'abort') {
                                            self.setError(slide);
                                        }

                                    }
                                }));

                                $slide.one('onReset', function() {
                                    ajaxLoad.abort();
                                });

                                break;

                            default:

                                self.setError(slide);

                                break;

                        }

                        return true;

                    },


                    // Use thumbnail image, if possible
                    // ================================

                    setImage: function(slide) {

                        var self = this;
                        var srcset = slide.opts.srcset || slide.opts.image.srcset;

                        var found, temp, pxRatio, windowWidth;

                        // If we have "srcset", then we need to find matching "src" value.
                        // This is necessary, because when you set an src attribute, the browser will preload the image
                        // before any javascript or even CSS is applied.
                        if (srcset) {
                            pxRatio = window.devicePixelRatio || 1;
                            windowWidth = window.innerWidth * pxRatio;

                            temp = srcset.split(',').map(function(el) {
                                var ret = {};

                                el.trim().split(/\s+/).forEach(function(el, i) {
                                    var value = parseInt(el.substring(0, el.length - 1), 10);

                                    if (i === 0) {
                                        return (ret.url = el);
                                    }

                                    if (value) {
                                        ret.value = value;
                                        ret.postfix = el[el.length - 1];
                                    }

                                });

                                return ret;
                            });

                            // Sort by value
                            temp.sort(function(a, b) {
                                return a.value - b.value;
                            });

                            // Ok, now we have an array of all srcset values
                            for (var j = 0; j < temp.length; j++) {
                                var el = temp[j];

                                if ((el.postfix === 'w' && el.value >= windowWidth) || (el.postfix === 'x' && el.value >= pxRatio)) {
                                    found = el;
                                    break;
                                }
                            }

                            // If not found, take the last one
                            if (!found && temp.length) {
                                found = temp[temp.length - 1];
                            }

                            if (found) {
                                slide.src = found.url;

                                // If we have default width/height values, we can calculate height for matching source
                                if (slide.width && slide.height && found.postfix == 'w') {
                                    slide.height = (slide.width / slide.height) * found.value;
                                    slide.width = found.value;
                                }
                            }
                        }

                        // This will be wrapper containing both ghost and actual image
                        slide.$content = $('<div class="fancybox-image-wrap"></div>')
                            .addClass('fancybox-is-hidden')
                            .appendTo(slide.$slide);


                        // If we have a thumbnail, we can display it while actual image is loading
                        // Users will not stare at black screen and actual image will appear gradually
                        if (slide.opts.preload !== false && slide.opts.width && slide.opts.height && (slide.opts.thumb || slide.opts.$thumb)) {

                            slide.width = slide.opts.width;
                            slide.height = slide.opts.height;

                            slide.$ghost = $('<img />')
                                .one('error', function() {

                                    $(this).remove();

                                    slide.$ghost = null;

                                    self.setBigImage(slide);

                                })
                                .one('load', function() {

                                    self.afterLoad(slide);

                                    self.setBigImage(slide);

                                })
                                .addClass('fancybox-image')
                                .appendTo(slide.$content)
                                .attr('src', slide.opts.thumb || slide.opts.$thumb.attr('src'));

                        } else {

                            self.setBigImage(slide);

                        }

                    },


                    // Create full-size image
                    // ======================

                    setBigImage: function(slide) {
                        var self = this;
                        var $img = $('<img />');

                        slide.$image = $img
                            .one('error', function() {

                                self.setError(slide);

                            })
                            .one('load', function() {

                                // Clear timeout that checks if loading icon needs to be displayed
                                clearTimeout(slide.timouts);

                                slide.timouts = null;

                                if (self.isClosing) {
                                    return;
                                }

                                slide.width = this.naturalWidth;
                                slide.height = this.naturalHeight;

                                if (slide.opts.image.srcset) {
                                    $img.attr('sizes', '100vw').attr('srcset', slide.opts.image.srcset);
                                }

                                self.hideLoading(slide);

                                if (slide.$ghost) {

                                    slide.timouts = setTimeout(function() {
                                        slide.timouts = null;

                                        slide.$ghost.hide();

                                    }, Math.min(300, Math.max(1000, slide.height / 1600)));

                                } else {
                                    self.afterLoad(slide);
                                }

                            })
                            .addClass('fancybox-image')
                            .attr('src', slide.src)
                            .appendTo(slide.$content);

                        if (($img[0].complete || $img[0].readyState == "complete") && $img[0].naturalWidth && $img[0].naturalHeight) {
                            $img.trigger('load');

                        } else if ($img[0].error) {
                            $img.trigger('error');

                        } else {

                            slide.timouts = setTimeout(function() {
                                if (!$img[0].complete && !slide.hasError) {
                                    self.showLoading(slide);
                                }

                            }, 100);

                        }

                    },


                    // Create iframe wrapper, iframe and bindings
                    // ==========================================

                    setIframe: function(slide) {
                        var self = this,
                            opts = slide.opts.iframe,
                            $slide = slide.$slide,
                            $iframe;

                        slide.$content = $('<div class="fancybox-content' + (opts.preload ? ' fancybox-is-hidden' : '') + '"></div>')
                            .css(opts.css)
                            .appendTo($slide);

                        $iframe = $(opts.tpl.replace(/\{rnd\}/g, new Date().getTime()))
                            .attr(opts.attr)
                            .appendTo(slide.$content);

                        if (opts.preload) {

                            self.showLoading(slide);

                            // Unfortunately, it is not always possible to determine if iframe is successfully loaded
                            // (due to browser security policy)

                            $iframe.on('load.fb error.fb', function(e) {
                                this.isReady = 1;

                                slide.$slide.trigger('refresh');

                                self.afterLoad(slide);
                            });

                            // Recalculate iframe content size
                            // ===============================

                            $slide.on('refresh.fb', function() {
                                var $wrap = slide.$content,
                                    frameWidth = opts.css.width,
                                    frameHeight = opts.css.height,
                                    scrollWidth,
                                    $contents,
                                    $body;

                                if ($iframe[0].isReady !== 1) {
                                    return;
                                }

                                // Check if content is accessible,
                                // it will fail if frame is not with the same origin

                                try {
                                    $contents = $iframe.contents();
                                    $body = $contents.find('body');

                                } catch (ignore) {}

                                // Calculate dimensions for the wrapper
                                if ($body && $body.length) {

                                    if (frameWidth === undefined) {
                                        scrollWidth = $iframe[0].contentWindow.document.documentElement.scrollWidth;

                                        frameWidth = Math.ceil($body.outerWidth(true) + ($wrap.width() - scrollWidth));
                                        frameWidth += $wrap.outerWidth() - $wrap.innerWidth();
                                    }

                                    if (frameHeight === undefined) {
                                        frameHeight = Math.ceil($body.outerHeight(true));
                                        frameHeight += $wrap.outerHeight() - $wrap.innerHeight();
                                    }

                                    // Resize wrapper to fit iframe content
                                    if (frameWidth) {
                                        $wrap.width(frameWidth);
                                    }

                                    if (frameHeight) {
                                        $wrap.height(frameHeight);
                                    }
                                }

                                $wrap.removeClass('fancybox-is-hidden');

                            });

                        } else {

                            this.afterLoad(slide);

                        }

                        $iframe.attr('src', slide.src);

                        if (slide.opts.smallBtn === true) {
                            slide.$content.prepend(self.translate(slide, slide.opts.btnTpl.smallBtn));
                        }

                        // Remove iframe if closing or changing gallery item
                        $slide.one('onReset', function() {

                            // This helps IE not to throw errors when closing
                            try {

                                $(this).find('iframe').hide().attr('src', '//about:blank');

                            } catch (ignore) {}

                            $(this).empty();

                            slide.isLoaded = false;

                        });

                    },


                    // Wrap and append content to the slide
                    // ======================================

                    setContent: function(slide, content) {

                        var self = this;

                        if (self.isClosing) {
                            return;
                        }

                        self.hideLoading(slide);

                        slide.$slide.empty();

                        if (isQuery(content) && content.parent().length) {

                            // If content is a jQuery object, then it will be moved to the slide.
                            // The placeholder is created so we will know where to put it back.
                            // If user is navigating gallery fast, then the content might be already inside fancyBox
                            // =====================================================================================

                            // Make sure content is not already moved to fancyBox
                            content.parent('.fancybox-slide--inline').trigger('onReset');

                            // Create temporary element marking original place of the content
                            slide.$placeholder = $('<div></div>').hide().insertAfter(content);

                            // Make sure content is visible
                            content.css('display', 'inline-block');

                        } else if (!slide.hasError) {

                            // If content is just a plain text, try to convert it to html
                            if ($.type(content) === 'string') {
                                content = $('<div>').append($.trim(content)).contents();

                                // If we have text node, then add wrapping element to make vertical alignment work
                                if (content[0].nodeType === 3) {
                                    content = $('<div>').html(content);
                                }
                            }

                            // If "filter" option is provided, then filter content
                            if (slide.opts.filter) {
                                content = $('<div>').html(content).find(slide.opts.filter);
                            }

                        }

                        slide.$slide.one('onReset', function() {

                            // Put content back
                            if (slide.$placeholder) {
                                slide.$placeholder.after(content.hide()).remove();

                                slide.$placeholder = null;
                            }

                            // Remove custom close button
                            if (slide.$smallBtn) {
                                slide.$smallBtn.remove();

                                slide.$smallBtn = null;
                            }

                            // Remove content and mark slide as not loaded
                            if (!slide.hasError) {
                                $(this).empty();

                                slide.isLoaded = false;
                            }

                        });

                        slide.$content = $(content).appendTo(slide.$slide);

                        this.afterLoad(slide);
                    },

                    // Display error message
                    // =====================

                    setError: function(slide) {

                        slide.hasError = true;

                        slide.$slide.removeClass('fancybox-slide--' + slide.type);

                        this.setContent(slide, this.translate(slide, slide.opts.errorTpl));

                    },


                    // Show loading icon inside the slide
                    // ==================================

                    showLoading: function(slide) {

                        var self = this;

                        slide = slide || self.current;

                        if (slide && !slide.$spinner) {
                            slide.$spinner = $(self.opts.spinnerTpl).appendTo(slide.$slide);
                        }

                    },

                    // Remove loading icon from the slide
                    // ==================================

                    hideLoading: function(slide) {

                        var self = this;

                        slide = slide || self.current;

                        if (slide && slide.$spinner) {
                            slide.$spinner.remove();

                            delete slide.$spinner;
                        }

                    },


                    // Adjustments after slide content has been loaded
                    // ===============================================

                    afterLoad: function(slide) {

                        var self = this;

                        if (self.isClosing) {
                            return;
                        }

                        slide.isLoading = false;
                        slide.isLoaded = true;

                        self.trigger('afterLoad', slide);

                        self.hideLoading(slide);

                        if (slide.opts.smallBtn && !slide.$smallBtn) {
                            slide.$smallBtn = $(self.translate(slide, slide.opts.btnTpl.smallBtn)).appendTo(slide.$content.filter('div,form').first());
                        }

                        if (slide.opts.protect && slide.$content && !slide.hasError) {

                            // Disable right click
                            slide.$content.on('contextmenu.fb', function(e) {
                                if (e.button == 2) {
                                    e.preventDefault();
                                }

                                return true;
                            });

                            // Add fake element on top of the image
                            // This makes a bit harder for user to select image
                            if (slide.type === 'image') {
                                $('<div class="fancybox-spaceball"></div>').appendTo(slide.$content);
                            }

                        }

                        self.revealContent(slide);

                    },


                    // Make content visible
                    // This method is called right after content has been loaded or
                    // user navigates gallery and transition should start
                    // ============================================================

                    revealContent: function(slide) {

                        var self = this;
                        var $slide = slide.$slide;

                        var effect, effectClassName, duration, opacity, end, start = false;

                        effect = slide.opts[self.firstRun ? 'animationEffect' : 'transitionEffect'];
                        duration = slide.opts[self.firstRun ? 'animationDuration' : 'transitionDuration'];

                        duration = parseInt(slide.forcedDuration === undefined ? duration : slide.forcedDuration, 10);

                        if (slide.isMoved || slide.pos !== self.currPos || !duration) {
                            effect = false;
                        }

                        // Check if can zoom
                        if (effect === 'zoom' && !(slide.pos === self.currPos && duration && slide.type === 'image' && !slide.hasError && (start = self.getThumbPos(slide)))) {
                            effect = 'fade';
                        }

                        // Zoom animation
                        // ==============

                        if (effect === 'zoom') {
                            end = self.getFitPos(slide);

                            end.scaleX = end.width / start.width;
                            end.scaleY = end.height / start.height;

                            delete end.width;
                            delete end.height;

                            // Check if we need to animate opacity
                            opacity = slide.opts.zoomOpacity;

                            if (opacity == 'auto') {
                                opacity = Math.abs(slide.width / slide.height - start.width / start.height) > 0.1;
                            }

                            if (opacity) {
                                start.opacity = 0.1;
                                end.opacity = 1;
                            }

                            // Draw image at start position
                            $.fancybox.setTranslate(slide.$content.removeClass('fancybox-is-hidden'), start);

                            forceRedraw(slide.$content);

                            // Start animation
                            $.fancybox.animate(slide.$content, end, duration, function() {
                                self.complete();
                            });

                            return;
                        }

                        self.updateSlide(slide);


                        // Simply show content
                        // ===================

                        if (!effect) {
                            forceRedraw($slide);

                            slide.$content.removeClass('fancybox-is-hidden');

                            if (slide.pos === self.currPos) {
                                self.complete();
                            }

                            return;
                        }

                        $.fancybox.stop($slide);

                        effectClassName = 'fancybox-animated fancybox-slide--' + (slide.pos >= self.prevPos ? 'next' : 'previous') + ' fancybox-fx-' + effect;

                        $slide.removeAttr('style').removeClass('fancybox-slide--current fancybox-slide--next fancybox-slide--previous').addClass(effectClassName);

                        slide.$content.removeClass('fancybox-is-hidden');

                        //Force reflow for CSS3 transitions
                        forceRedraw($slide);

                        $.fancybox.animate($slide, 'fancybox-slide--current', duration, function(e) {
                            $slide.removeClass(effectClassName).removeAttr('style');

                            if (slide.pos === self.currPos) {
                                self.complete();
                            }

                        }, true);

                    },


                    // Check if we can and have to zoom from thumbnail
                    //================================================

                    getThumbPos: function(slide) {

                        var self = this;
                        var rez = false;

                        // Check if element is inside the viewport by at least 1 pixel
                        var isElementVisible = function($el) {
                            var element = $el[0];

                            var elementRect = element.getBoundingClientRect();
                            var parentRects = [];

                            var visibleInAllParents;

                            while (element.parentElement !== null) {
                                if ($(element.parentElement).css('overflow') === 'hidden' || $(element.parentElement).css('overflow') === 'auto') {
                                    parentRects.push(element.parentElement.getBoundingClientRect());
                                }

                                element = element.parentElement;
                            }

                            visibleInAllParents = parentRects.every(function(parentRect) {
                                var visiblePixelX = Math.min(elementRect.right, parentRect.right) - Math.max(elementRect.left, parentRect.left);
                                var visiblePixelY = Math.min(elementRect.bottom, parentRect.bottom) - Math.max(elementRect.top, parentRect.top);

                                return visiblePixelX > 0 && visiblePixelY > 0;
                            });

                            return visibleInAllParents &&
                                elementRect.bottom > 0 && elementRect.right > 0 &&
                                elementRect.left < $(window).width() && elementRect.top < $(window).height();
                        };

                        var $thumb = slide.opts.$thumb;
                        var thumbPos = $thumb ? $thumb.offset() : 0;
                        var slidePos;

                        if (thumbPos && $thumb[0].ownerDocument === document && isElementVisible($thumb)) {
                            slidePos = self.$refs.stage.offset();

                            rez = {
                                top: thumbPos.top - slidePos.top + parseFloat($thumb.css("border-top-width") || 0),
                                left: thumbPos.left - slidePos.left + parseFloat($thumb.css("border-left-width") || 0),
                                width: $thumb.width(),
                                height: $thumb.height(),
                                scaleX: 1,
                                scaleY: 1
                            };
                        }

                        return rez;
                    },


                    // Final adjustments after current gallery item is moved to position
                    // and it`s content is loaded
                    // ==================================================================

                    complete: function() {

                        var self = this;

                        var current = self.current;
                        var slides = {};

                        if (current.isMoved || !current.isLoaded || current.isComplete) {
                            return;
                        }

                        current.isComplete = true;

                        current.$slide.siblings().trigger('onReset');

                        // Trigger any CSS3 transiton inside the slide
                        forceRedraw(current.$slide);

                        current.$slide.addClass('fancybox-slide--complete');

                        // Remove unnecessary slides
                        $.each(self.slides, function(key, slide) {
                            if (slide.pos >= self.currPos - 1 && slide.pos <= self.currPos + 1) {
                                slides[slide.pos] = slide;

                            } else if (slide) {

                                $.fancybox.stop(slide.$slide);

                                slide.$slide.off().remove();
                            }
                        });

                        self.slides = slides;

                        self.updateCursor();

                        self.trigger('afterShow');

                        // Try to focus on the first focusable element
                        if ($(document.activeElement).is('[disabled]') || (current.opts.autoFocus && !(current.type == 'image' || current.type === 'iframe'))) {
                            self.focus();
                        }

                    },


                    // Preload next and previous slides
                    // ================================

                    preload: function() {
                        var self = this;
                        var next, prev;

                        if (self.group.length < 2) {
                            return;
                        }

                        next = self.slides[self.currPos + 1];
                        prev = self.slides[self.currPos - 1];

                        if (next && next.type === 'image') {
                            self.loadSlide(next);
                        }

                        if (prev && prev.type === 'image') {
                            self.loadSlide(prev);
                        }

                    },


                    // Try to find and focus on the first focusable element
                    // ====================================================

                    focus: function() {
                        var current = this.current;
                        var $el;

                        if (this.isClosing) {
                            return;
                        }

                        if (current && current.isComplete) {

                            // Look for first input with autofocus attribute
                            $el = current.$slide.find('input[autofocus]:enabled:visible:first');

                            if (!$el.length) {
                                $el = current.$slide.find('button,:input,[tabindex],a').filter(':enabled:visible:first');
                            }
                        }

                        $el = $el && $el.length ? $el : this.$refs.container;

                        $el.focus();
                    },


                    // Activates current instance - brings container to the front and enables keyboard,
                    // notifies other instances about deactivating
                    // =================================================================================

                    activate: function() {
                        var self = this;

                        // Deactivate all instances
                        $('.fancybox-container').each(function() {
                            var instance = $(this).data('FancyBox');

                            // Skip self and closing instances
                            if (instance && instance.id !== self.id && !instance.isClosing) {
                                instance.trigger('onDeactivate');

                                instance.removeEvents();

                                instance.isVisible = false;
                            }

                        });

                        self.isVisible = true;

                        if (self.current || self.isIdle) {
                            self.update();

                            self.updateControls();
                        }

                        self.trigger('onActivate');

                        self.addEvents();
                    },


                    // Start closing procedure
                    // This will start "zoom-out" animation if needed and clean everything up afterwards
                    // =================================================================================

                    close: function(e, d) {

                        var self = this;
                        var current = self.current;

                        var effect, duration;
                        var $what, opacity, start, end;

                        var done = function() {
                            self.cleanUp(e);
                        };

                        if (self.isClosing) {
                            return false;
                        }

                        self.isClosing = true;

                        // If beforeClose callback prevents closing, make sure content is centered
                        if (self.trigger('beforeClose', e) === false) {
                            self.isClosing = false;

                            requestAFrame(function() {
                                self.update();
                            });

                            return false;
                        }

                        // Remove all events
                        // If there are multiple instances, they will be set again by "activate" method
                        self.removeEvents();

                        if (current.timouts) {
                            clearTimeout(current.timouts);
                        }

                        $what = current.$content;
                        effect = current.opts.animationEffect;
                        duration = $.isNumeric(d) ? d : (effect ? current.opts.animationDuration : 0);

                        // Remove other slides
                        current.$slide.off(transitionEnd).removeClass('fancybox-slide--complete fancybox-slide--next fancybox-slide--previous fancybox-animated');

                        current.$slide.siblings().trigger('onReset').remove();

                        // Trigger animations
                        if (duration) {
                            self.$refs.container.removeClass('fancybox-is-open').addClass('fancybox-is-closing');
                        }

                        // Clean up
                        self.hideLoading(current);

                        self.hideControls();

                        self.updateCursor();

                        // Check if possible to zoom-out
                        if (effect === 'zoom' && !(e !== true && $what && duration && current.type === 'image' && !current.hasError && (end = self.getThumbPos(current)))) {
                            effect = 'fade';
                        }

                        if (effect === 'zoom') {
                            $.fancybox.stop($what);

                            start = $.fancybox.getTranslate($what);

                            start.width = start.width * start.scaleX;
                            start.height = start.height * start.scaleY;

                            // Check if we need to animate opacity
                            opacity = current.opts.zoomOpacity;

                            if (opacity == 'auto') {
                                opacity = Math.abs(current.width / current.height - end.width / end.height) > 0.1;
                            }

                            if (opacity) {
                                end.opacity = 0;
                            }

                            start.scaleX = start.width / end.width;
                            start.scaleY = start.height / end.height;

                            start.width = end.width;
                            start.height = end.height;

                            $.fancybox.setTranslate(current.$content, start);

                            forceRedraw(current.$content);

                            $.fancybox.animate(current.$content, end, duration, done);

                            return true;
                        }

                        if (effect && duration) {

                            // If skip animation
                            if (e === true) {
                                setTimeout(done, duration);

                            } else {
                                $.fancybox.animate(current.$slide.removeClass('fancybox-slide--current'), 'fancybox-animated fancybox-slide--previous fancybox-fx-' + effect, duration, done);
                            }

                        } else {
                            done();
                        }

                        return true;
                    },


                    // Final adjustments after removing the instance
                    // =============================================

                    cleanUp: function(e) {
                        var self = this,
                            $body = $('body'),
                            instance,
                            offset;

                        self.current.$slide.trigger('onReset');

                        self.$refs.container.empty().remove();

                        self.trigger('afterClose', e);

                        // Place back focus
                        if (self.$lastFocus && !!self.current.opts.backFocus) {
                            self.$lastFocus.focus();
                        }

                        self.current = null;

                        // Check if there are other instances
                        instance = $.fancybox.getInstance();

                        if (instance) {
                            instance.activate();

                        } else {

                            $W.scrollTop(self.scrollTop).scrollLeft(self.scrollLeft);

                            $body.removeClass('fancybox-active compensate-for-scrollbar');

                            if ($body.hasClass('fancybox-iosfix')) {
                                offset = parseInt(document.body.style.top, 10);

                                $body.removeClass('fancybox-iosfix').css('top', '').scrollTop(offset * -1);
                            }

                            $('#fancybox-style-noscroll').remove();

                        }

                    },


                    // Call callback and trigger an event
                    // ==================================

                    trigger: function(name, slide) {
                        var args = Array.prototype.slice.call(arguments, 1),
                            self = this,
                            obj = slide && slide.opts ? slide : self.current,
                            rez;

                        if (obj) {
                            args.unshift(obj);

                        } else {
                            obj = self;
                        }

                        args.unshift(self);

                        if ($.isFunction(obj.opts[name])) {
                            rez = obj.opts[name].apply(obj, args);
                        }

                        if (rez === false) {
                            return rez;
                        }

                        if (name === 'afterClose' || !self.$refs) {
                            $D.trigger(name + '.fb', args);

                        } else {
                            self.$refs.container.trigger(name + '.fb', args);
                        }

                    },


                    // Update infobar values, navigation button states and reveal caption
                    // ==================================================================

                    updateControls: function(force) {

                        var self = this;

                        var current = self.current,
                            index = current.index,
                            caption = current.opts.caption,
                            $container = self.$refs.container,
                            $caption = self.$refs.caption;

                        // Recalculate content dimensions
                        current.$slide.trigger('refresh');

                        self.$caption = caption && caption.length ? $caption.html(caption) : null;

                        if (!self.isHiddenControls && !self.isIdle) {
                            self.showControls();
                        }

                        // Update info and navigation elements
                        $container.find('[data-fancybox-count]').html(self.group.length);
                        $container.find('[data-fancybox-index]').html(index + 1);

                        $container.find('[data-fancybox-prev]').prop('disabled', (!current.opts.loop && index <= 0));
                        $container.find('[data-fancybox-next]').prop('disabled', (!current.opts.loop && index >= self.group.length - 1));

                        if (current.type === 'image') {

                            // Update download button source
                            $container.find('[data-fancybox-download]').attr('href', current.opts.image.src || current.src).show();

                        } else {
                            $container.find('[data-fancybox-download],[data-fancybox-zoom]').hide();
                        }
                    },

                    // Hide toolbar and caption
                    // ========================

                    hideControls: function() {

                        this.isHiddenControls = true;

                        this.$refs.container.removeClass('fancybox-show-infobar fancybox-show-toolbar fancybox-show-caption fancybox-show-nav');

                    },

                    showControls: function() {
                        var self = this;
                        var opts = self.current ? self.current.opts : self.opts;
                        var $container = self.$refs.container;

                        self.isHiddenControls = false;
                        self.idleSecondsCounter = 0;

                        $container
                            .toggleClass('fancybox-show-toolbar', !!(opts.toolbar && opts.buttons))
                            .toggleClass('fancybox-show-infobar', !!(opts.infobar && self.group.length > 1))
                            .toggleClass('fancybox-show-nav', !!(opts.arrows && self.group.length > 1))
                            .toggleClass('fancybox-is-modal', !!opts.modal);

                        if (self.$caption) {
                            $container.addClass('fancybox-show-caption ');

                        } else {
                            $container.removeClass('fancybox-show-caption');
                        }

                    },


                    // Toggle toolbar and caption
                    // ==========================

                    toggleControls: function() {
                        if (this.isHiddenControls) {
                            this.showControls();

                        } else {
                            this.hideControls();
                        }

                    },


                });


                $.fancybox = {

                    version: "3.2.5",
                    defaults: defaults,


                    // Get current instance and execute a command.
                    //
                    // Examples of usage:
                    //
                    //   $instance = $.fancybox.getInstance();
                    //   $.fancybox.getInstance().jumpTo( 1 );
                    //   $.fancybox.getInstance( 'jumpTo', 1 );
                    //   $.fancybox.getInstance( function() {
                    //       console.info( this.currIndex );
                    //   });
                    // ======================================================

                    getInstance: function(command) {
                        var instance = $('.fancybox-container:not(".fancybox-is-closing"):last').data('FancyBox');
                        var args = Array.prototype.slice.call(arguments, 1);

                        if (instance instanceof FancyBox) {

                            if ($.type(command) === 'string') {
                                instance[command].apply(instance, args);

                            } else if ($.type(command) === 'function') {
                                command.apply(instance, args);
                            }

                            return instance;
                        }

                        return false;

                    },


                    // Create new instance
                    // ===================

                    open: function(items, opts, index) {
                        return new FancyBox(items, opts, index);
                    },


                    // Close current or all instances
                    // ==============================

                    close: function(all) {
                        var instance = this.getInstance();

                        if (instance) {
                            instance.close();

                            // Try to find and close next instance

                            if (all === true) {
                                this.close();
                            }
                        }

                    },

                    // Close instances and unbind all events
                    // ==============================

                    destroy: function() {

                        this.close(true);

                        $D.off('click.fb-start');

                    },


                    // Try to detect mobile devices
                    // ============================

                    isMobile: document.createTouch !== undefined && /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent),


                    // Detect if 'translate3d' support is available
                    // ============================================

                    use3d: (function() {
                        var div = document.createElement('div');

                        return window.getComputedStyle && window.getComputedStyle(div).getPropertyValue('transform') && !(document.documentMode && document.documentMode < 11);
                    }()),

                    // Helper function to get current visual state of an element
                    // returns array[ top, left, horizontal-scale, vertical-scale, opacity ]
                    // =====================================================================

                    getTranslate: function($el) {
                        var matrix;

                        if (!$el || !$el.length) {
                            return false;
                        }

                        matrix = $el.eq(0).css('transform');

                        if (matrix && matrix.indexOf('matrix') !== -1) {
                            matrix = matrix.split('(')[1];
                            matrix = matrix.split(')')[0];
                            matrix = matrix.split(',');
                        } else {
                            matrix = [];
                        }

                        if (matrix.length) {

                            // If IE
                            if (matrix.length > 10) {
                                matrix = [matrix[13], matrix[12], matrix[0], matrix[5]];

                            } else {
                                matrix = [matrix[5], matrix[4], matrix[0], matrix[3]];
                            }

                            matrix = matrix.map(parseFloat);

                        } else {
                            matrix = [0, 0, 1, 1];

                            var transRegex = /\.*translate\((.*)px,(.*)px\)/i;
                            var transRez = transRegex.exec($el.eq(0).attr('style'));

                            if (transRez) {
                                matrix[0] = parseFloat(transRez[2]);
                                matrix[1] = parseFloat(transRez[1]);
                            }
                        }

                        return {
                            top: matrix[0],
                            left: matrix[1],
                            scaleX: matrix[2],
                            scaleY: matrix[3],
                            opacity: parseFloat($el.css('opacity')),
                            width: $el.width(),
                            height: $el.height()
                        };

                    },


                    // Shortcut for setting "translate3d" properties for element
                    // Can set be used to set opacity, too
                    // ========================================================

                    setTranslate: function($el, props) {
                        var str = '';
                        var css = {};

                        if (!$el || !props) {
                            return;
                        }

                        if (props.left !== undefined || props.top !== undefined) {
                            str = (props.left === undefined ? $el.position().left : props.left) + 'px, ' + (props.top === undefined ? $el.position().top : props.top) + 'px';

                            if (this.use3d) {
                                str = 'translate3d(' + str + ', 0px)';

                            } else {
                                str = 'translate(' + str + ')';
                            }
                        }

                        if (props.scaleX !== undefined && props.scaleY !== undefined) {
                            str = (str.length ? str + ' ' : '') + 'scale(' + props.scaleX + ', ' + props.scaleY + ')';
                        }

                        if (str.length) {
                            css.transform = str;
                        }

                        if (props.opacity !== undefined) {
                            css.opacity = props.opacity;
                        }

                        if (props.width !== undefined) {
                            css.width = props.width;
                        }

                        if (props.height !== undefined) {
                            css.height = props.height;
                        }

                        return $el.css(css);
                    },


                    // Simple CSS transition handler
                    // =============================

                    animate: function($el, to, duration, callback, leaveAnimationName) {
                        if ($.isFunction(duration)) {
                            callback = duration;
                            duration = null;
                        }

                        if (!$.isPlainObject(to)) {
                            $el.removeAttr('style');
                        }

                        $el.on(transitionEnd, function(e) {

                            // Skip events from child elements and z-index change
                            if (e && e.originalEvent && (!$el.is(e.originalEvent.target) || e.originalEvent.propertyName == 'z-index')) {
                                return;
                            }

                            $.fancybox.stop($el);

                            if ($.isPlainObject(to)) {

                                if (to.scaleX !== undefined && to.scaleY !== undefined) {
                                    $el.css('transition-duration', '');

                                    to.width = Math.round($el.width() * to.scaleX);
                                    to.height = Math.round($el.height() * to.scaleY);

                                    to.scaleX = 1;
                                    to.scaleY = 1;

                                    $.fancybox.setTranslate($el, to);
                                }

                            } else if (leaveAnimationName !== true) {
                                $el.removeClass(to);
                            }

                            if ($.isFunction(callback)) {
                                callback(e);
                            }

                        });

                        if ($.isNumeric(duration)) {
                            $el.css('transition-duration', duration + 'ms');
                        }

                        if ($.isPlainObject(to)) {
                            $.fancybox.setTranslate($el, to);

                        } else {
                            $el.addClass(to);
                        }

                        if (to.scaleX && $el.hasClass('fancybox-image-wrap')) {
                            $el.parent().addClass('fancybox-is-scaling');
                        }

                        // Make sure that `transitionend` callback gets fired
                        $el.data("timer", setTimeout(function() {
                            $el.trigger('transitionend');
                        }, duration + 16));

                    },

                    stop: function($el) {
                        clearTimeout($el.data("timer"));

                        $el.off('transitionend').css('transition-duration', '');

                        if ($el.hasClass('fancybox-image-wrap')) {
                            $el.parent().removeClass('fancybox-is-scaling');
                        }
                    }

                };


                // Default click handler for "fancyboxed" links
                // ============================================

                function _run(e) {
                    var $target = $(e.currentTarget),
                        opts = e.data ? e.data.options : {},
                        value = $target.attr('data-fancybox') || '',
                        index = 0,
                        items = [];

                    // Avoid opening multiple times
                    if (e.isDefaultPrevented()) {
                        return;
                    }

                    e.preventDefault();

                    // Get all related items and find index for clicked one
                    if (value) {
                        items = opts.selector ? $(opts.selector) : (e.data ? e.data.items : []);
                        items = items.length ? items.filter('[data-fancybox="' + value + '"]') : $('[data-fancybox="' + value + '"]');

                        index = items.index($target);

                        // Sometimes current item can not be found
                        // (for example, when slider clones items)
                        if (index < 0) {
                            index = 0;
                        }

                    } else {
                        items = [$target];
                    }

                    $.fancybox.open(items, opts, index);
                }


                // Create a jQuery plugin
                // ======================

                $.fn.fancybox = function(options) {
                    var selector;

                    options = options || {};
                    selector = options.selector || false;

                    if (selector) {

                        $('body').off('click.fb-start', selector).on('click.fb-start', selector, {
                            options: options
                        }, _run);

                    } else {

                        this.off('click.fb-start').on('click.fb-start', {
                            items: this,
                            options: options
                        }, _run);

                    }

                    return this;
                };


                // Self initializing plugin
                // ========================

                $D.on('click.fb-start', '[data-fancybox]', _run);

            }(window, document, __webpack_provided_window_dot_jQuery || jQuery));

            // ==========================================================================
            //
            // Media
            // Adds additional media type support
            //
            // ==========================================================================
            ;
            (function($) {

                'use strict';

                // Formats matching url to final form

                var format = function(url, rez, params) {
                    if (!url) {
                        return;
                    }

                    params = params || '';

                    if ($.type(params) === "object") {
                        params = $.param(params, true);
                    }

                    $.each(rez, function(key, value) {
                        url = url.replace('$' + key, value || '');
                    });

                    if (params.length) {
                        url += (url.indexOf('?') > 0 ? '&' : '?') + params;
                    }

                    return url;
                };

                // Object containing properties for each media type

                var defaults = {
                    youtube: {
                        matcher: /(youtube\.com|youtu\.be|youtube\-nocookie\.com)\/(watch\?(.*&)?v=|v\/|u\/|embed\/?)?(videoseries\?list=(.*)|[\w-]{11}|\?listType=(.*)&list=(.*))(.*)/i,
                        params: {
                            autoplay: 1,
                            autohide: 1,
                            fs: 1,
                            rel: 0,
                            hd: 1,
                            wmode: 'transparent',
                            enablejsapi: 1,
                            html5: 1
                        },
                        paramPlace: 8,
                        type: 'iframe',
                        url: '//www.youtube.com/embed/$4',
                        thumb: '//img.youtube.com/vi/$4/hqdefault.jpg'
                    },

                    vimeo: {
                        matcher: /^.+vimeo.com\/(.*\/)?([\d]+)(.*)?/,
                        params: {
                            autoplay: 1,
                            hd: 1,
                            show_title: 1,
                            show_byline: 1,
                            show_portrait: 0,
                            fullscreen: 1,
                            api: 1
                        },
                        paramPlace: 3,
                        type: 'iframe',
                        url: '//player.vimeo.com/video/$2'
                    },

                    metacafe: {
                        matcher: /metacafe.com\/watch\/(\d+)\/(.*)?/,
                        type: 'iframe',
                        url: '//www.metacafe.com/embed/$1/?ap=1'
                    },

                    dailymotion: {
                        matcher: /dailymotion.com\/video\/(.*)\/?(.*)/,
                        params: {
                            additionalInfos: 0,
                            autoStart: 1
                        },
                        type: 'iframe',
                        url: '//www.dailymotion.com/embed/video/$1'
                    },

                    vine: {
                        matcher: /vine.co\/v\/([a-zA-Z0-9\?\=\-]+)/,
                        type: 'iframe',
                        url: '//vine.co/v/$1/embed/simple'
                    },

                    instagram: {
                        matcher: /(instagr\.am|instagram\.com)\/p\/([a-zA-Z0-9_\-]+)\/?/i,
                        type: 'image',
                        url: '//$1/p/$2/media/?size=l'
                    },

                    // Examples:
                    // http://maps.google.com/?ll=48.857995,2.294297&spn=0.007666,0.021136&t=m&z=16
                    // https://www.google.com/maps/@37.7852006,-122.4146355,14.65z
                    // https://www.google.com/maps/place/Googleplex/@37.4220041,-122.0833494,17z/data=!4m5!3m4!1s0x0:0x6c296c66619367e0!8m2!3d37.4219998!4d-122.0840572
                    gmap_place: {
                        matcher: /(maps\.)?google\.([a-z]{2,3}(\.[a-z]{2})?)\/(((maps\/(place\/(.*)\/)?\@(.*),(\d+.?\d+?)z))|(\?ll=))(.*)?/i,
                        type: 'iframe',
                        url: function(rez) {
                            return '//maps.google.' + rez[2] + '/?ll=' + (rez[9] ? rez[9] + '&z=' + Math.floor(rez[10]) + (rez[12] ? rez[12].replace(/^\//, "&") : '') : rez[12]) + '&output=' + (rez[12] && rez[12].indexOf('layer=c') > 0 ? 'svembed' : 'embed');
                        }
                    },

                    // Examples:
                    // https://www.google.com/maps/search/Empire+State+Building/
                    // https://www.google.com/maps/search/?api=1&query=centurylink+field
                    // https://www.google.com/maps/search/?api=1&query=47.5951518,-122.3316393
                    gmap_search: {
                        matcher: /(maps\.)?google\.([a-z]{2,3}(\.[a-z]{2})?)\/(maps\/search\/)(.*)/i,
                        type: 'iframe',
                        url: function(rez) {
                            return '//maps.google.' + rez[2] + '/maps?q=' + rez[5].replace('query=', 'q=').replace('api=1', '') + '&output=embed';
                        }
                    }
                };

                $(document).on('objectNeedsType.fb', function(e, instance, item) {

                    var url = item.src || '',
                        type = false,
                        media,
                        thumb,
                        rez,
                        params,
                        urlParams,
                        paramObj,
                        provider;

                    media = $.extend(true, {}, defaults, item.opts.media);

                    // Look for any matching media type
                    $.each(media, function(providerName, providerOpts) {
                        rez = url.match(providerOpts.matcher);

                        if (!rez) {
                            return;
                        }

                        type = providerOpts.type;
                        paramObj = {};

                        if (providerOpts.paramPlace && rez[providerOpts.paramPlace]) {
                            urlParams = rez[providerOpts.paramPlace];

                            if (urlParams[0] == '?') {
                                urlParams = urlParams.substring(1);
                            }

                            urlParams = urlParams.split('&');

                            for (var m = 0; m < urlParams.length; ++m) {
                                var p = urlParams[m].split('=', 2);

                                if (p.length == 2) {
                                    paramObj[p[0]] = decodeURIComponent(p[1].replace(/\+/g, " "));
                                }
                            }
                        }

                        params = $.extend(true, {}, providerOpts.params, item.opts[providerName], paramObj);

                        url = $.type(providerOpts.url) === "function" ? providerOpts.url.call(this, rez, params, item) : format(providerOpts.url, rez, params);
                        thumb = $.type(providerOpts.thumb) === "function" ? providerOpts.thumb.call(this, rez, params, item) : format(providerOpts.thumb, rez);

                        if (providerName === 'vimeo') {
                            url = url.replace('&%23', '#');
                        }

                        return false;
                    });

                    // If it is found, then change content type and update the url

                    if (type) {
                        item.src = url;
                        item.type = type;

                        if (!item.opts.thumb && !(item.opts.$thumb && item.opts.$thumb.length)) {
                            item.opts.thumb = thumb;
                        }

                        if (type === 'iframe') {
                            $.extend(true, item.opts, {
                                iframe: {
                                    preload: false,
                                    attr: {
                                        scrolling: "no"
                                    }
                                }
                            });

                            item.contentProvider = provider;

                            item.opts.slideClass += ' fancybox-slide--' + (provider == 'gmap_place' || provider == 'gmap_search' ? 'map' : 'video');
                        }

                    } else if (url) {
                        item.type = item.opts.defaultType;
                    }

                });

            }(__webpack_provided_window_dot_jQuery || jQuery));

            // ==========================================================================
            //
            // Guestures
            // Adds touch guestures, handles click and tap events
            //
            // ==========================================================================
            ;
            (function(window, document, $) {
                'use strict';

                var requestAFrame = (function() {
                    return window.requestAnimationFrame ||
                        window.webkitRequestAnimationFrame ||
                        window.mozRequestAnimationFrame ||
                        window.oRequestAnimationFrame ||
                        // if all else fails, use setTimeout
                        function(callback) {
                            return window.setTimeout(callback, 1000 / 60);
                        };
                })();


                var cancelAFrame = (function() {
                    return window.cancelAnimationFrame ||
                        window.webkitCancelAnimationFrame ||
                        window.mozCancelAnimationFrame ||
                        window.oCancelAnimationFrame ||
                        function(id) {
                            window.clearTimeout(id);
                        };
                })();


                var pointers = function(e) {
                    var result = [];

                    e = e.originalEvent || e || window.e;
                    e = e.touches && e.touches.length ? e.touches : (e.changedTouches && e.changedTouches.length ? e.changedTouches : [e]);

                    for (var key in e) {

                        if (e[key].pageX) {
                            result.push({
                                x: e[key].pageX,
                                y: e[key].pageY
                            });

                        } else if (e[key].clientX) {
                            result.push({
                                x: e[key].clientX,
                                y: e[key].clientY
                            });
                        }
                    }

                    return result;
                };

                var distance = function(point2, point1, what) {
                    if (!point1 || !point2) {
                        return 0;
                    }

                    if (what === 'x') {
                        return point2.x - point1.x;

                    } else if (what === 'y') {
                        return point2.y - point1.y;
                    }

                    return Math.sqrt(Math.pow(point2.x - point1.x, 2) + Math.pow(point2.y - point1.y, 2));
                };

                var isClickable = function($el) {

                    if ($el.is('a,area,button,[role="button"],input,label,select,summary,textarea') || $.isFunction($el.get(0).onclick) || $el.data('selectable')) {
                        return true;
                    }

                    // Check for attributes like data-fancybox-next or data-fancybox-close
                    for (var i = 0, atts = $el[0].attributes, n = atts.length; i < n; i++) {
                        if (atts[i].nodeName.substr(0, 14) === 'data-fancybox-') {
                            return true;
                        }
                    }

                    return false;
                };

                var hasScrollbars = function(el) {
                    var overflowY = window.getComputedStyle(el)['overflow-y'];
                    var overflowX = window.getComputedStyle(el)['overflow-x'];

                    var vertical = (overflowY === 'scroll' || overflowY === 'auto') && el.scrollHeight > el.clientHeight;
                    var horizontal = (overflowX === 'scroll' || overflowX === 'auto') && el.scrollWidth > el.clientWidth;

                    return vertical || horizontal;
                };

                var isScrollable = function($el) {
                    var rez = false;

                    while (true) {
                        rez = hasScrollbars($el.get(0));

                        if (rez) {
                            break;
                        }

                        $el = $el.parent();

                        if (!$el.length || $el.hasClass('fancybox-stage') || $el.is('body')) {
                            break;
                        }
                    }

                    return rez;
                };


                var Guestures = function(instance) {
                    var self = this;

                    self.instance = instance;

                    self.$bg = instance.$refs.bg;
                    self.$stage = instance.$refs.stage;
                    self.$container = instance.$refs.container;

                    self.destroy();

                    self.$container.on('touchstart.fb.touch mousedown.fb.touch', $.proxy(self, 'ontouchstart'));
                };

                Guestures.prototype.destroy = function() {
                    this.$container.off('.fb.touch');
                };

                Guestures.prototype.ontouchstart = function(e) {
                    var self = this;

                    var $target = $(e.target);
                    var instance = self.instance;
                    var current = instance.current;
                    var $content = current.$content;

                    var isTouchDevice = (e.type == 'touchstart');

                    // Do not respond to both events
                    if (isTouchDevice) {
                        self.$container.off('mousedown.fb.touch');
                    }

                    // Ignore clicks while zooming or closing
                    if (!current || self.instance.isAnimating || self.instance.isClosing) {
                        e.stopPropagation();
                        e.preventDefault();

                        return;
                    }

                    // Ignore right click
                    if (e.originalEvent && e.originalEvent.button == 2) {
                        return;
                    }

                    // Ignore taping on links, buttons, input elements
                    if (!$target.length || isClickable($target) || isClickable($target.parent())) {
                        return;
                    }

                    // Ignore clicks on the scrollbar
                    if (e.originalEvent.clientX > $target[0].clientWidth + $target.offset().left) {
                        return;
                    }

                    self.startPoints = pointers(e);

                    // Prevent zooming if already swiping
                    if (!self.startPoints || (self.startPoints.length > 1 && instance.isSliding)) {
                        return;
                    }

                    self.$target = $target;
                    self.$content = $content;
                    self.canTap = true;
                    self.opts = current.opts.touch;

                    $(document).off('.fb.touch');

                    $(document).on(isTouchDevice ? 'touchend.fb.touch touchcancel.fb.touch' : 'mouseup.fb.touch mouseleave.fb.touch', $.proxy(self, "ontouchend"));
                    $(document).on(isTouchDevice ? 'touchmove.fb.touch' : 'mousemove.fb.touch', $.proxy(self, "ontouchmove"));

                    if (!(self.opts || instance.canPan()) || !($target.is(self.$stage) || self.$stage.find($target).length)) {

                        // Prevent ghosting
                        if ($target.is('img')) {
                            e.preventDefault();
                        }

                        return;
                    }

                    e.stopPropagation();

                    if (!($.fancybox.isMobile && (isScrollable(self.$target) || isScrollable(self.$target.parent())))) {
                        e.preventDefault();
                    }

                    self.canvasWidth = Math.round(current.$slide[0].clientWidth);
                    self.canvasHeight = Math.round(current.$slide[0].clientHeight);

                    self.startTime = new Date().getTime();
                    self.distanceX = self.distanceY = self.distance = 0;

                    self.isPanning = false;
                    self.isSwiping = false;
                    self.isZooming = false;

                    self.sliderStartPos = self.sliderLastPos || {
                        top: 0,
                        left: 0
                    };
                    self.contentStartPos = $.fancybox.getTranslate(self.$content);
                    self.contentLastPos = null;

                    if (self.startPoints.length === 1 && !self.isZooming) {
                        self.canTap = !instance.isSliding;

                        if (current.type === 'image' && (self.contentStartPos.width > self.canvasWidth + 1 || self.contentStartPos.height > self.canvasHeight + 1)) {

                            $.fancybox.stop(self.$content);

                            self.$content.css('transition-duration', '0ms');

                            self.isPanning = true;

                        } else {

                            self.isSwiping = true;
                        }

                        self.$container.addClass('fancybox-controls--isGrabbing');
                    }

                    if (self.startPoints.length === 2 && !instance.isAnimating && !current.hasError && current.type === 'image' && (current.isLoaded || current.$ghost)) {
                        self.isZooming = true;

                        self.isSwiping = false;
                        self.isPanning = false;

                        $.fancybox.stop(self.$content);

                        self.$content.css('transition-duration', '0ms');

                        self.centerPointStartX = ((self.startPoints[0].x + self.startPoints[1].x) * 0.5) - $(window).scrollLeft();
                        self.centerPointStartY = ((self.startPoints[0].y + self.startPoints[1].y) * 0.5) - $(window).scrollTop();

                        self.percentageOfImageAtPinchPointX = (self.centerPointStartX - self.contentStartPos.left) / self.contentStartPos.width;
                        self.percentageOfImageAtPinchPointY = (self.centerPointStartY - self.contentStartPos.top) / self.contentStartPos.height;

                        self.startDistanceBetweenFingers = distance(self.startPoints[0], self.startPoints[1]);
                    }

                };

                Guestures.prototype.ontouchmove = function(e) {

                    var self = this;

                    self.newPoints = pointers(e);

                    if ($.fancybox.isMobile && (isScrollable(self.$target) || isScrollable(self.$target.parent()))) {
                        e.stopPropagation();

                        self.canTap = false;

                        return;
                    }

                    if (!(self.opts || self.instance.canPan()) || !self.newPoints || !self.newPoints.length) {
                        return;
                    }

                    self.distanceX = distance(self.newPoints[0], self.startPoints[0], 'x');
                    self.distanceY = distance(self.newPoints[0], self.startPoints[0], 'y');

                    self.distance = distance(self.newPoints[0], self.startPoints[0]);

                    // Skip false ontouchmove events (Chrome)
                    if (self.distance > 0) {

                        if (!(self.$target.is(self.$stage) || self.$stage.find(self.$target).length)) {
                            return;
                        }

                        e.stopPropagation();
                        e.preventDefault();

                        if (self.isSwiping) {
                            self.onSwipe();

                        } else if (self.isPanning) {
                            self.onPan();

                        } else if (self.isZooming) {
                            self.onZoom();
                        }

                    }

                };

                Guestures.prototype.onSwipe = function() {

                    var self = this;

                    var swiping = self.isSwiping;
                    var left = self.sliderStartPos.left || 0;
                    var angle;

                    if (swiping === true) {

                        if (Math.abs(self.distance) > 10) {

                            self.canTap = false;

                            if (self.instance.group.length < 2 && self.opts.vertical) {
                                self.isSwiping = 'y';

                            } else if (self.instance.isSliding || self.opts.vertical === false || (self.opts.vertical === 'auto' && $(window).width() > 800)) {
                                self.isSwiping = 'x';

                            } else {
                                angle = Math.abs(Math.atan2(self.distanceY, self.distanceX) * 180 / Math.PI);

                                self.isSwiping = (angle > 45 && angle < 135) ? 'y' : 'x';
                            }

                            self.instance.isSliding = self.isSwiping;

                            // Reset points to avoid jumping, because we dropped first swipes to calculate the angle
                            self.startPoints = self.newPoints;

                            $.each(self.instance.slides, function(index, slide) {
                                $.fancybox.stop(slide.$slide);

                                slide.$slide.css('transition-duration', '0ms');

                                slide.inTransition = false;

                                if (slide.pos === self.instance.current.pos) {
                                    self.sliderStartPos.left = $.fancybox.getTranslate(slide.$slide).left;
                                }
                            });

                            //self.instance.current.isMoved = true;

                            // Stop slideshow
                            if (self.instance.SlideShow && self.instance.SlideShow.isActive) {
                                self.instance.SlideShow.stop();
                            }
                        }

                    } else {

                        if (swiping == 'x') {

                            // Sticky edges
                            if (self.distanceX > 0 && (self.instance.group.length < 2 || (self.instance.current.index === 0 && !self.instance.current.opts.loop))) {
                                left = left + Math.pow(self.distanceX, 0.8);

                            } else if (self.distanceX < 0 && (self.instance.group.length < 2 || (self.instance.current.index === self.instance.group.length - 1 && !self.instance.current.opts.loop))) {
                                left = left - Math.pow(-self.distanceX, 0.8);

                            } else {
                                left = left + self.distanceX;
                            }

                        }

                        self.sliderLastPos = {
                            top: swiping == 'x' ? 0 : self.sliderStartPos.top + self.distanceY,
                            left: left
                        };

                        if (self.requestId) {
                            cancelAFrame(self.requestId);

                            self.requestId = null;
                        }

                        self.requestId = requestAFrame(function() {

                            if (self.sliderLastPos) {
                                $.each(self.instance.slides, function(index, slide) {
                                    var pos = slide.pos - self.instance.currPos;

                                    $.fancybox.setTranslate(slide.$slide, {
                                        top: self.sliderLastPos.top,
                                        left: self.sliderLastPos.left + (pos * self.canvasWidth) + (pos * slide.opts.gutter)
                                    });
                                });

                                self.$container.addClass('fancybox-is-sliding');
                            }

                        });

                    }

                };

                Guestures.prototype.onPan = function() {

                    var self = this;

                    var newOffsetX, newOffsetY, newPos;

                    self.canTap = false;

                    if (self.contentStartPos.width > self.canvasWidth) {
                        newOffsetX = self.contentStartPos.left + self.distanceX;

                    } else {
                        newOffsetX = self.contentStartPos.left;
                    }

                    newOffsetY = self.contentStartPos.top + self.distanceY;

                    newPos = self.limitMovement(newOffsetX, newOffsetY, self.contentStartPos.width, self.contentStartPos.height);

                    newPos.scaleX = self.contentStartPos.scaleX;
                    newPos.scaleY = self.contentStartPos.scaleY;

                    self.contentLastPos = newPos;

                    if (self.requestId) {
                        cancelAFrame(self.requestId);

                        self.requestId = null;
                    }

                    self.requestId = requestAFrame(function() {
                        $.fancybox.setTranslate(self.$content, self.contentLastPos);
                    });
                };

                // Make panning sticky to the edges
                Guestures.prototype.limitMovement = function(newOffsetX, newOffsetY, newWidth, newHeight) {

                    var self = this;

                    var minTranslateX, minTranslateY, maxTranslateX, maxTranslateY;

                    var canvasWidth = self.canvasWidth;
                    var canvasHeight = self.canvasHeight;

                    var currentOffsetX = self.contentStartPos.left;
                    var currentOffsetY = self.contentStartPos.top;

                    var distanceX = self.distanceX;
                    var distanceY = self.distanceY;

                    // Slow down proportionally to traveled distance

                    minTranslateX = Math.max(0, canvasWidth * 0.5 - newWidth * 0.5);
                    minTranslateY = Math.max(0, canvasHeight * 0.5 - newHeight * 0.5);

                    maxTranslateX = Math.min(canvasWidth - newWidth, canvasWidth * 0.5 - newWidth * 0.5);
                    maxTranslateY = Math.min(canvasHeight - newHeight, canvasHeight * 0.5 - newHeight * 0.5);

                    if (newWidth > canvasWidth) {

                        //   ->
                        if (distanceX > 0 && newOffsetX > minTranslateX) {
                            newOffsetX = minTranslateX - 1 + Math.pow(-minTranslateX + currentOffsetX + distanceX, 0.8) || 0;
                        }

                        //    <-
                        if (distanceX < 0 && newOffsetX < maxTranslateX) {
                            newOffsetX = maxTranslateX + 1 - Math.pow(maxTranslateX - currentOffsetX - distanceX, 0.8) || 0;
                        }

                    }

                    if (newHeight > canvasHeight) {

                        //   \/
                        if (distanceY > 0 && newOffsetY > minTranslateY) {
                            newOffsetY = minTranslateY - 1 + Math.pow(-minTranslateY + currentOffsetY + distanceY, 0.8) || 0;
                        }

                        //   /\
                        if (distanceY < 0 && newOffsetY < maxTranslateY) {
                            newOffsetY = maxTranslateY + 1 - Math.pow(maxTranslateY - currentOffsetY - distanceY, 0.8) || 0;
                        }

                    }

                    return {
                        top: newOffsetY,
                        left: newOffsetX
                    };

                };


                Guestures.prototype.limitPosition = function(newOffsetX, newOffsetY, newWidth, newHeight) {

                    var self = this;

                    var canvasWidth = self.canvasWidth;
                    var canvasHeight = self.canvasHeight;

                    if (newWidth > canvasWidth) {
                        newOffsetX = newOffsetX > 0 ? 0 : newOffsetX;
                        newOffsetX = newOffsetX < canvasWidth - newWidth ? canvasWidth - newWidth : newOffsetX;

                    } else {

                        // Center horizontally
                        newOffsetX = Math.max(0, canvasWidth / 2 - newWidth / 2);

                    }

                    if (newHeight > canvasHeight) {
                        newOffsetY = newOffsetY > 0 ? 0 : newOffsetY;
                        newOffsetY = newOffsetY < canvasHeight - newHeight ? canvasHeight - newHeight : newOffsetY;

                    } else {

                        // Center vertically
                        newOffsetY = Math.max(0, canvasHeight / 2 - newHeight / 2);

                    }

                    return {
                        top: newOffsetY,
                        left: newOffsetX
                    };

                };

                Guestures.prototype.onZoom = function() {

                    var self = this;

                    // Calculate current distance between points to get pinch ratio and new width and height

                    var currentWidth = self.contentStartPos.width;
                    var currentHeight = self.contentStartPos.height;

                    var currentOffsetX = self.contentStartPos.left;
                    var currentOffsetY = self.contentStartPos.top;

                    var endDistanceBetweenFingers = distance(self.newPoints[0], self.newPoints[1]);

                    var pinchRatio = endDistanceBetweenFingers / self.startDistanceBetweenFingers;

                    var newWidth = Math.floor(currentWidth * pinchRatio);
                    var newHeight = Math.floor(currentHeight * pinchRatio);

                    // This is the translation due to pinch-zooming
                    var translateFromZoomingX = (currentWidth - newWidth) * self.percentageOfImageAtPinchPointX;
                    var translateFromZoomingY = (currentHeight - newHeight) * self.percentageOfImageAtPinchPointY;

                    //Point between the two touches

                    var centerPointEndX = ((self.newPoints[0].x + self.newPoints[1].x) / 2) - $(window).scrollLeft();
                    var centerPointEndY = ((self.newPoints[0].y + self.newPoints[1].y) / 2) - $(window).scrollTop();

                    // And this is the translation due to translation of the centerpoint
                    // between the two fingers

                    var translateFromTranslatingX = centerPointEndX - self.centerPointStartX;
                    var translateFromTranslatingY = centerPointEndY - self.centerPointStartY;

                    // The new offset is the old/current one plus the total translation

                    var newOffsetX = currentOffsetX + (translateFromZoomingX + translateFromTranslatingX);
                    var newOffsetY = currentOffsetY + (translateFromZoomingY + translateFromTranslatingY);

                    var newPos = {
                        top: newOffsetY,
                        left: newOffsetX,
                        scaleX: self.contentStartPos.scaleX * pinchRatio,
                        scaleY: self.contentStartPos.scaleY * pinchRatio
                    };

                    self.canTap = false;

                    self.newWidth = newWidth;
                    self.newHeight = newHeight;

                    self.contentLastPos = newPos;

                    if (self.requestId) {
                        cancelAFrame(self.requestId);

                        self.requestId = null;
                    }

                    self.requestId = requestAFrame(function() {
                        $.fancybox.setTranslate(self.$content, self.contentLastPos);
                    });

                };

                Guestures.prototype.ontouchend = function(e) {

                    var self = this;
                    var dMs = Math.max((new Date().getTime()) - self.startTime, 1);

                    var swiping = self.isSwiping;
                    var panning = self.isPanning;
                    var zooming = self.isZooming;

                    self.endPoints = pointers(e);

                    self.$container.removeClass('fancybox-controls--isGrabbing');

                    $(document).off('.fb.touch');

                    if (self.requestId) {
                        cancelAFrame(self.requestId);

                        self.requestId = null;
                    }

                    self.isSwiping = false;
                    self.isPanning = false;
                    self.isZooming = false;

                    if (self.canTap) {
                        return self.onTap(e);
                    }

                    self.speed = 366;

                    // Speed in px/ms
                    self.velocityX = self.distanceX / dMs * 0.5;
                    self.velocityY = self.distanceY / dMs * 0.5;

                    self.speedX = Math.max(self.speed * 0.5, Math.min(self.speed * 1.5, (1 / Math.abs(self.velocityX)) * self.speed));

                    if (panning) {
                        self.endPanning();

                    } else if (zooming) {
                        self.endZooming();

                    } else {
                        self.endSwiping(swiping);
                    }

                    return;
                };

                Guestures.prototype.endSwiping = function(swiping) {

                    var self = this;
                    var ret = false;

                    self.instance.isSliding = false;
                    self.sliderLastPos = null;

                    // Close if swiped vertically / navigate if horizontally
                    if (swiping == 'y' && Math.abs(self.distanceY) > 50) {

                        // Continue vertical movement
                        $.fancybox.animate(self.instance.current.$slide, {
                            top: self.sliderStartPos.top + self.distanceY + (self.velocityY * 150),
                            opacity: 0
                        }, 150);

                        ret = self.instance.close(true, 300);

                    } else if (swiping == 'x' && self.distanceX > 50 && self.instance.group.length > 1) {
                        ret = self.instance.previous(self.speedX);

                    } else if (swiping == 'x' && self.distanceX < -50 && self.instance.group.length > 1) {
                        ret = self.instance.next(self.speedX);
                    }

                    if (ret === false && (swiping == 'x' || swiping == 'y')) {
                        self.instance.jumpTo(self.instance.current.index, 150);
                    }

                    self.$container.removeClass('fancybox-is-sliding');

                };

                // Limit panning from edges
                // ========================

                Guestures.prototype.endPanning = function() {

                    var self = this;
                    var newOffsetX, newOffsetY, newPos;

                    if (!self.contentLastPos) {
                        return;
                    }

                    if (self.opts.momentum === false) {
                        newOffsetX = self.contentLastPos.left;
                        newOffsetY = self.contentLastPos.top;

                    } else {

                        // Continue movement
                        newOffsetX = self.contentLastPos.left + (self.velocityX * self.speed);
                        newOffsetY = self.contentLastPos.top + (self.velocityY * self.speed);
                    }

                    newPos = self.limitPosition(newOffsetX, newOffsetY, self.contentStartPos.width, self.contentStartPos.height);

                    newPos.width = self.contentStartPos.width;
                    newPos.height = self.contentStartPos.height;

                    $.fancybox.animate(self.$content, newPos, 330);
                };


                Guestures.prototype.endZooming = function() {

                    var self = this;

                    var current = self.instance.current;

                    var newOffsetX, newOffsetY, newPos, reset;

                    var newWidth = self.newWidth;
                    var newHeight = self.newHeight;

                    if (!self.contentLastPos) {
                        return;
                    }

                    newOffsetX = self.contentLastPos.left;
                    newOffsetY = self.contentLastPos.top;

                    reset = {
                        top: newOffsetY,
                        left: newOffsetX,
                        width: newWidth,
                        height: newHeight,
                        scaleX: 1,
                        scaleY: 1
                    };

                    // Reset scalex/scaleY values; this helps for perfomance and does not break animation
                    $.fancybox.setTranslate(self.$content, reset);

                    if (newWidth < self.canvasWidth && newHeight < self.canvasHeight) {
                        self.instance.scaleToFit(150);

                    } else if (newWidth > current.width || newHeight > current.height) {
                        self.instance.scaleToActual(self.centerPointStartX, self.centerPointStartY, 150);

                    } else {

                        newPos = self.limitPosition(newOffsetX, newOffsetY, newWidth, newHeight);

                        // Switch from scale() to width/height or animation will not work correctly
                        $.fancybox.setTranslate(self.content, $.fancybox.getTranslate(self.$content));

                        $.fancybox.animate(self.$content, newPos, 150);
                    }

                };

                Guestures.prototype.onTap = function(e) {
                    var self = this;
                    var $target = $(e.target);

                    var instance = self.instance;
                    var current = instance.current;

                    var endPoints = (e && pointers(e)) || self.startPoints;

                    var tapX = endPoints[0] ? endPoints[0].x - self.$stage.offset().left : 0;
                    var tapY = endPoints[0] ? endPoints[0].y - self.$stage.offset().top : 0;

                    var where;

                    var process = function(prefix) {

                        var action = current.opts[prefix];

                        if ($.isFunction(action)) {
                            action = action.apply(instance, [current, e]);
                        }

                        if (!action) {
                            return;
                        }

                        switch (action) {

                            case "close":

                                instance.close(self.startEvent);

                                break;

                            case "toggleControls":

                                instance.toggleControls(true);

                                break;

                            case "next":

                                instance.next();

                                break;

                            case "nextOrClose":

                                if (instance.group.length > 1) {
                                    instance.next();

                                } else {
                                    instance.close(self.startEvent);
                                }

                                break;

                            case "zoom":

                                if (current.type == 'image' && (current.isLoaded || current.$ghost)) {

                                    if (instance.canPan()) {
                                        instance.scaleToFit();

                                    } else if (instance.isScaledDown()) {
                                        instance.scaleToActual(tapX, tapY);

                                    } else if (instance.group.length < 2) {
                                        instance.close(self.startEvent);
                                    }
                                }

                                break;
                        }

                    };

                    // Ignore right click
                    if (e.originalEvent && e.originalEvent.button == 2) {
                        return;
                    }

                    // Skip if current slide is not in the center
                    if (instance.isSliding) {
                        return;
                    }

                    // Skip if clicked on the scrollbar
                    if (tapX > $target[0].clientWidth + $target.offset().left) {
                        return;
                    }

                    // Check where is clicked
                    if ($target.is('.fancybox-bg,.fancybox-inner,.fancybox-outer,.fancybox-container')) {
                        where = 'Outside';

                    } else if ($target.is('.fancybox-slide')) {
                        where = 'Slide';

                    } else if (instance.current.$content && instance.current.$content.has(e.target).length) {
                        where = 'Content';

                    } else {
                        return;
                    }

                    // Check if this is a double tap
                    if (self.tapped) {

                        // Stop previously created single tap
                        clearTimeout(self.tapped);
                        self.tapped = null;

                        // Skip if distance between taps is too big
                        if (Math.abs(tapX - self.tapX) > 50 || Math.abs(tapY - self.tapY) > 50 || instance.isSliding) {
                            return this;
                        }

                        // OK, now we assume that this is a double-tap
                        process('dblclick' + where);

                    } else {

                        // Single tap will be processed if user has not clicked second time within 300ms
                        // or there is no need to wait for double-tap
                        self.tapX = tapX;
                        self.tapY = tapY;

                        if (current.opts['dblclick' + where] && current.opts['dblclick' + where] !== current.opts['click' + where]) {
                            self.tapped = setTimeout(function() {
                                self.tapped = null;

                                process('click' + where);

                            }, 300);

                        } else {
                            process('click' + where);
                        }

                    }

                    return this;
                };

                $(document).on('onActivate.fb', function(e, instance) {
                    if (instance && !instance.Guestures) {
                        instance.Guestures = new Guestures(instance);
                    }
                });

                $(document).on('beforeClose.fb', function(e, instance) {
                    if (instance && instance.Guestures) {
                        instance.Guestures.destroy();
                    }
                });


            }(window, document, __webpack_provided_window_dot_jQuery || jQuery));

            // ==========================================================================
            //
            // SlideShow
            // Enables slideshow functionality
            //
            // Example of usage:
            // $.fancybox.getInstance().SlideShow.start()
            //
            // ==========================================================================
            ;
            (function(document, $) {
                'use strict';

                $.extend(true, $.fancybox.defaults, {
                    btnTpl: {
                        slideShow: '<button data-fancybox-play class="fancybox-button fancybox-button--play" title="{{PLAY_START}}">' +
                            '<svg viewBox="0 0 40 40">' +
                            '<path d="M13,12 L27,20 L13,27 Z" />' +
                            '<path d="M15,10 v19 M23,10 v19" />' +
                            '</svg>' +
                            '</button>'
                    },
                    slideShow: {
                        autoStart: false,
                        speed: 3000
                    }
                });

                var SlideShow = function(instance) {
                    this.instance = instance;
                    this.init();
                };

                $.extend(SlideShow.prototype, {
                    timer: null,
                    isActive: false,
                    $button: null,

                    init: function() {
                        var self = this;

                        self.$button = self.instance.$refs.toolbar.find('[data-fancybox-play]').on('click', function() {
                            self.toggle();
                        });

                        if (self.instance.group.length < 2 || !self.instance.group[self.instance.currIndex].opts.slideShow) {
                            self.$button.hide();
                        }
                    },

                    set: function(force) {
                        var self = this;

                        // Check if reached last element
                        if (self.instance && self.instance.current && (force === true || self.instance.current.opts.loop || self.instance.currIndex < self.instance.group.length - 1)) {
                            self.timer = setTimeout(function() {
                                if (self.isActive) {
                                    self.instance.jumpTo((self.instance.currIndex + 1) % self.instance.group.length);
                                }

                            }, self.instance.current.opts.slideShow.speed);

                        } else {
                            self.stop();
                            self.instance.idleSecondsCounter = 0;
                            self.instance.showControls();
                        }
                    },

                    clear: function() {
                        var self = this;

                        clearTimeout(self.timer);

                        self.timer = null;
                    },

                    start: function() {
                        var self = this;
                        var current = self.instance.current;

                        if (current) {
                            self.isActive = true;

                            self.$button
                                .attr('title', current.opts.i18n[current.opts.lang].PLAY_STOP)
                                .removeClass('fancybox-button--play')
                                .addClass('fancybox-button--pause');

                            self.set(true);
                        }
                    },

                    stop: function() {
                        var self = this;
                        var current = self.instance.current;

                        self.clear();

                        self.$button
                            .attr('title', current.opts.i18n[current.opts.lang].PLAY_START)
                            .removeClass('fancybox-button--pause')
                            .addClass('fancybox-button--play');

                        self.isActive = false;
                    },

                    toggle: function() {
                        var self = this;

                        if (self.isActive) {
                            self.stop();

                        } else {
                            self.start();
                        }
                    }

                });

                $(document).on({
                    'onInit.fb': function(e, instance) {
                        if (instance && !instance.SlideShow) {
                            instance.SlideShow = new SlideShow(instance);
                        }
                    },

                    'beforeShow.fb': function(e, instance, current, firstRun) {
                        var SlideShow = instance && instance.SlideShow;

                        if (firstRun) {

                            if (SlideShow && current.opts.slideShow.autoStart) {
                                SlideShow.start();
                            }

                        } else if (SlideShow && SlideShow.isActive) {
                            SlideShow.clear();
                        }
                    },

                    'afterShow.fb': function(e, instance, current) {
                        var SlideShow = instance && instance.SlideShow;

                        if (SlideShow && SlideShow.isActive) {
                            SlideShow.set();
                        }
                    },

                    'afterKeydown.fb': function(e, instance, current, keypress, keycode) {
                        var SlideShow = instance && instance.SlideShow;

                        // "P" or Spacebar
                        if (SlideShow && current.opts.slideShow && (keycode === 80 || keycode === 32) && !$(document.activeElement).is('button,a,input')) {
                            keypress.preventDefault();

                            SlideShow.toggle();
                        }
                    },

                    'beforeClose.fb onDeactivate.fb': function(e, instance) {
                        var SlideShow = instance && instance.SlideShow;

                        if (SlideShow) {
                            SlideShow.stop();
                        }
                    }
                });

                // Page Visibility API to pause slideshow when window is not active
                $(document).on("visibilitychange", function() {
                    var instance = $.fancybox.getInstance();
                    var SlideShow = instance && instance.SlideShow;

                    if (SlideShow && SlideShow.isActive) {
                        if (document.hidden) {
                            SlideShow.clear();

                        } else {
                            SlideShow.set();
                        }
                    }
                });

            }(document, __webpack_provided_window_dot_jQuery || jQuery));

            // ==========================================================================
            //
            // FullScreen
            // Adds fullscreen functionality
            //
            // ==========================================================================
            ;
            (function(document, $) {
                'use strict';

                // Collection of methods supported by user browser
                var fn = (function() {

                    var fnMap = [
                        [
                            'requestFullscreen',
                            'exitFullscreen',
                            'fullscreenElement',
                            'fullscreenEnabled',
                            'fullscreenchange',
                            'fullscreenerror'
                        ],
                        // new WebKit
                        [
                            'webkitRequestFullscreen',
                            'webkitExitFullscreen',
                            'webkitFullscreenElement',
                            'webkitFullscreenEnabled',
                            'webkitfullscreenchange',
                            'webkitfullscreenerror'

                        ],
                        // old WebKit (Safari 5.1)
                        [
                            'webkitRequestFullScreen',
                            'webkitCancelFullScreen',
                            'webkitCurrentFullScreenElement',
                            'webkitCancelFullScreen',
                            'webkitfullscreenchange',
                            'webkitfullscreenerror'

                        ],
                        [
                            'mozRequestFullScreen',
                            'mozCancelFullScreen',
                            'mozFullScreenElement',
                            'mozFullScreenEnabled',
                            'mozfullscreenchange',
                            'mozfullscreenerror'
                        ],
                        [
                            'msRequestFullscreen',
                            'msExitFullscreen',
                            'msFullscreenElement',
                            'msFullscreenEnabled',
                            'MSFullscreenChange',
                            'MSFullscreenError'
                        ]
                    ];

                    var val;
                    var ret = {};
                    var i, j;

                    for (i = 0; i < fnMap.length; i++) {
                        val = fnMap[i];

                        if (val && val[1] in document) {
                            for (j = 0; j < val.length; j++) {
                                ret[fnMap[0][j]] = val[j];
                            }

                            return ret;
                        }
                    }

                    return false;
                })();

                // If browser does not have Full Screen API, then simply unset default button template and stop
                if (!fn) {

                    if ($ && $.fancybox) {
                        $.fancybox.defaults.btnTpl.fullScreen = false;
                    }

                    return;
                }

                var FullScreen = {

                    request: function(elem) {

                        elem = elem || document.documentElement;

                        elem[fn.requestFullscreen](elem.ALLOW_KEYBOARD_INPUT);

                    },
                    exit: function() {

                        document[fn.exitFullscreen]();

                    },
                    toggle: function(elem) {

                        elem = elem || document.documentElement;

                        if (this.isFullscreen()) {
                            this.exit();

                        } else {
                            this.request(elem);
                        }

                    },
                    isFullscreen: function() {

                        return Boolean(document[fn.fullscreenElement]);

                    },
                    enabled: function() {

                        return Boolean(document[fn.fullscreenEnabled]);

                    }
                };

                $.extend(true, $.fancybox.defaults, {
                    btnTpl: {
                        fullScreen: '<button data-fancybox-fullscreen class="fancybox-button fancybox-button--fullscreen" title="{{FULL_SCREEN}}">' +
                            '<svg viewBox="0 0 40 40">' +
                            '<path d="M9,12 h22 v16 h-22 v-16 v16 h22 v-16 Z" />' +
                            '</svg>' +
                            '</button>'
                    },
                    fullScreen: {
                        autoStart: false
                    }
                });

                $(document).on({
                    'onInit.fb': function(e, instance) {
                        var $container;

                        if (instance && instance.group[instance.currIndex].opts.fullScreen) {
                            $container = instance.$refs.container;

                            $container.on('click.fb-fullscreen', '[data-fancybox-fullscreen]', function(e) {

                                e.stopPropagation();
                                e.preventDefault();

                                FullScreen.toggle($container[0]);

                            });

                            if (instance.opts.fullScreen && instance.opts.fullScreen.autoStart === true) {
                                FullScreen.request($container[0]);
                            }

                            // Expose API
                            instance.FullScreen = FullScreen;

                        } else if (instance) {
                            instance.$refs.toolbar.find('[data-fancybox-fullscreen]').hide();
                        }

                    },

                    'afterKeydown.fb': function(e, instance, current, keypress, keycode) {

                        // "P" or Spacebar
                        if (instance && instance.FullScreen && keycode === 70) {
                            keypress.preventDefault();

                            instance.FullScreen.toggle(instance.$refs.container[0]);
                        }

                    },

                    'beforeClose.fb': function(instance) {
                        if (instance && instance.FullScreen) {
                            FullScreen.exit();
                        }
                    }
                });

                $(document).on(fn.fullscreenchange, function() {
                    var isFullscreen = FullScreen.isFullscreen(),
                        instance = $.fancybox.getInstance();

                    if (instance) {

                        // If image is zooming, then force to stop and reposition properly
                        if (instance.current && instance.current.type === 'image' && instance.isAnimating) {
                            instance.current.$content.css('transition', 'none');

                            instance.isAnimating = false;

                            instance.update(true, true, 0);
                        }

                        instance.trigger('onFullscreenChange', isFullscreen);

                        instance.$refs.container.toggleClass('fancybox-is-fullscreen', isFullscreen);
                    }

                });

            }(document, __webpack_provided_window_dot_jQuery || jQuery));

            // ==========================================================================
            //
            // Thumbs
            // Displays thumbnails in a grid
            //
            // ==========================================================================
            ;
            (function(document, $) {
                'use strict';

                // Make sure there are default values
                $.fancybox.defaults = $.extend(true, {
                    btnTpl: {
                        thumbs: '<button data-fancybox-thumbs class="fancybox-button fancybox-button--thumbs" title="{{THUMBS}}">' +
                            '<svg viewBox="0 0 120 120">' +
                            '<path d="M30,30 h14 v14 h-14 Z M50,30 h14 v14 h-14 Z M70,30 h14 v14 h-14 Z M30,50 h14 v14 h-14 Z M50,50 h14 v14 h-14 Z M70,50 h14 v14 h-14 Z M30,70 h14 v14 h-14 Z M50,70 h14 v14 h-14 Z M70,70 h14 v14 h-14 Z" />' +
                            '</svg>' +
                            '</button>'
                    },
                    thumbs: {
                        autoStart: false, // Display thumbnails on opening
                        hideOnClose: true, // Hide thumbnail grid when closing animation starts
                        parentEl: '.fancybox-container', // Container is injected into this element
                        axis: 'y' // Vertical (y) or horizontal (x) scrolling
                    }
                }, $.fancybox.defaults);

                var FancyThumbs = function(instance) {
                    this.init(instance);
                };

                $.extend(FancyThumbs.prototype, {

                    $button: null,
                    $grid: null,
                    $list: null,
                    isVisible: false,
                    isActive: false,

                    init: function(instance) {
                        var self = this;

                        self.instance = instance;

                        instance.Thumbs = self;

                        // Enable thumbs if at least two group items have thumbnails
                        var first = instance.group[0],
                            second = instance.group[1];

                        self.opts = instance.group[instance.currIndex].opts.thumbs;

                        self.$button = instance.$refs.toolbar.find('[data-fancybox-thumbs]');

                        if (self.opts && first && second && (
                                (first.type == 'image' || first.opts.thumb || first.opts.$thumb) &&
                                (second.type == 'image' || second.opts.thumb || second.opts.$thumb)
                            )) {

                            self.$button.show().on('click', function() {
                                self.toggle();
                            });

                            self.isActive = true;

                        } else {
                            self.$button.hide();
                        }
                    },

                    create: function() {
                        var self = this,
                            instance = self.instance,
                            parentEl = self.opts.parentEl,
                            list,
                            src;

                        self.$grid = $('<div class="fancybox-thumbs fancybox-thumbs-' + self.opts.axis + '"></div>').appendTo(instance.$refs.container.find(parentEl).addBack().filter(parentEl));

                        // Build list HTML
                        list = '<ul>';

                        $.each(instance.group, function(i, item) {
                            src = item.opts.thumb || (item.opts.$thumb ? item.opts.$thumb.attr('src') : null);

                            if (!src && item.type === 'image') {
                                src = item.src;
                            }

                            if (src && src.length) {
                                list += '<li data-index="' + i + '"  tabindex="0" class="fancybox-thumbs-loading"><img data-src="' + src + '" /></li>';
                            }
                        });

                        list += '</ul>';

                        self.$list = $(list).appendTo(self.$grid).on('click', 'li', function() {
                            instance.jumpTo($(this).data('index'));
                        });

                        self.$list.find('img').hide().one('load', function() {
                                var $parent = $(this).parent().removeClass('fancybox-thumbs-loading'),
                                    thumbWidth = $parent.outerWidth(),
                                    thumbHeight = $parent.outerHeight(),
                                    width,
                                    height,
                                    widthRatio,
                                    heightRatio;

                                width = this.naturalWidth || this.width;
                                height = this.naturalHeight || this.height;

                                // Calculate thumbnail dimensions; center vertically and horizontally
                                widthRatio = width / thumbWidth;
                                heightRatio = height / thumbHeight;

                                if (widthRatio >= 1 && heightRatio >= 1) {
                                    if (widthRatio > heightRatio) {
                                        width = width / heightRatio;
                                        height = thumbHeight;

                                    } else {
                                        width = thumbWidth;
                                        height = height / widthRatio;
                                    }
                                }

                                $(this).css({
                                    width: Math.floor(width),
                                    height: Math.floor(height),
                                    'margin-top': height > thumbHeight ? (Math.floor(thumbHeight * 0.3 - height * 0.3)) : Math.floor(thumbHeight * 0.5 - height * 0.5),
                                    'margin-left': Math.floor(thumbWidth * 0.5 - width * 0.5)
                                }).show();

                            })
                            .each(function() {
                                this.src = $(this).data('src');
                            });

                        if (self.opts.axis === 'x') {
                            self.$list.width(parseInt(self.$grid.css("padding-right")) + (instance.group.length * self.$list.children().eq(0).outerWidth(true)) + 'px');
                        }
                    },

                    focus: function(duration) {
                        var self = this,
                            $list = self.$list,
                            thumb,
                            thumbPos;

                        if (self.instance.current) {
                            thumb = $list.children()
                                .removeClass('fancybox-thumbs-active')
                                .filter('[data-index="' + self.instance.current.index + '"]')
                                .addClass('fancybox-thumbs-active');

                            thumbPos = thumb.position();

                            // Check if need to scroll to make current thumb visible
                            if (self.opts.axis === 'y' && (thumbPos.top < 0 || thumbPos.top > ($list.height() - thumb.outerHeight()))) {
                                $list.stop().animate({
                                    'scrollTop': $list.scrollTop() + thumbPos.top
                                }, duration);

                            } else if (self.opts.axis === 'x' && (
                                    thumbPos.left < $list.parent().scrollLeft() ||
                                    thumbPos.left > ($list.parent().scrollLeft() + ($list.parent().width() - thumb.outerWidth()))
                                )) {
                                $list.parent().stop().animate({
                                    'scrollLeft': thumbPos.left
                                }, duration);
                            }
                        }
                    },

                    update: function() {
                        this.instance.$refs.container.toggleClass('fancybox-show-thumbs', this.isVisible);

                        if (this.isVisible) {
                            if (!this.$grid) {
                                this.create();
                            }

                            this.instance.trigger('onThumbsShow');

                            this.focus(0);

                        } else if (this.$grid) {
                            this.instance.trigger('onThumbsHide');
                        }

                        // Update content position
                        this.instance.update();
                    },

                    hide: function() {
                        this.isVisible = false;
                        this.update();
                    },

                    show: function() {
                        this.isVisible = true;
                        this.update();
                    },

                    toggle: function() {
                        this.isVisible = !this.isVisible;
                        this.update();
                    }
                });

                $(document).on({

                    'onInit.fb': function(e, instance) {
                        var Thumbs;

                        if (instance && !instance.Thumbs) {
                            Thumbs = new FancyThumbs(instance);

                            if (Thumbs.isActive && Thumbs.opts.autoStart === true) {
                                Thumbs.show();
                            }
                        }
                    },

                    'beforeShow.fb': function(e, instance, item, firstRun) {
                        var Thumbs = instance && instance.Thumbs;

                        if (Thumbs && Thumbs.isVisible) {
                            Thumbs.focus(firstRun ? 0 : 250);
                        }
                    },

                    'afterKeydown.fb': function(e, instance, current, keypress, keycode) {
                        var Thumbs = instance && instance.Thumbs;

                        // "G"
                        if (Thumbs && Thumbs.isActive && keycode === 71) {
                            keypress.preventDefault();

                            Thumbs.toggle();
                        }
                    },

                    'beforeClose.fb': function(e, instance) {
                        var Thumbs = instance && instance.Thumbs;

                        if (Thumbs && Thumbs.isVisible && Thumbs.opts.hideOnClose !== false) {
                            Thumbs.$grid.hide();
                        }
                    }

                });

            }(document, __webpack_provided_window_dot_jQuery));

            //// ==========================================================================
            //
            // Share
            // Displays simple form for sharing current url
            //
            // ==========================================================================
            ;
            (function(document, $) {
                'use strict';

                $.extend(true, $.fancybox.defaults, {
                    btnTpl: {
                        share: '<button data-fancybox-share class="fancybox-button fancybox-button--share" title="{{SHARE}}">' +
                            '<svg viewBox="0 0 40 40">' +
                            '<path d="M6,30 C8,18 19,16 23,16 L23,16 L23,10 L33,20 L23,29 L23,24 C19,24 8,27 6,30 Z">' +
                            '</svg>' +
                            '</button>'
                    },
                    share: {
                        tpl: '<div class="fancybox-share">' +
                            '<h1>{{SHARE}}</h1>' +
                            '<p>' +
                            '<a href="https://www.facebook.com/sharer/sharer.php?u={{src}}" target="_blank" class="fancybox-share_button">' +
                            '<svg version="1.1" viewBox="0 0 32 32" fill="#3b5998"><path d="M27.6 3h-23.2c-.8 0-1.4.6-1.4 1.4v23.1c0 .9.6 1.5 1.4 1.5h12.5v-10.1h-3.4v-3.9h3.4v-2.9c0-3.4 2.1-5.2 5-5.2 1.4 0 2.7.1 3 .2v3.5h-2.1c-1.6 0-1.9.8-1.9 1.9v2.5h3.9l-.5 3.9h-3.4v10.1h6.6c.8 0 1.4-.6 1.4-1.4v-23.2c.1-.8-.5-1.4-1.3-1.4z"></path></svg>' +
                            '<span>Facebook</span>' +
                            '</a>' +
                            '<a href="https://www.pinterest.com/pin/create/button/?url={{src}}&amp;description={{descr}}" target="_blank" class="fancybox-share_button">' +
                            '<svg version="1.1" viewBox="0 0 32 32" fill="#c92228"><path d="M16 3c-7.2 0-13 5.8-13 13 0 5.5 3.4 10.2 8.3 12.1-.1-1-.2-2.6 0-3.7.2-1 1.5-6.5 1.5-6.5s-.4-.8-.4-1.9c0-1.8 1-3.2 2.4-3.2 1.1 0 1.6.8 1.6 1.8 0 1.1-.7 2.8-1.1 4.3-.3 1.3.6 2.3 1.9 2.3 2.3 0 4.1-2.4 4.1-6 0-3.1-2.2-5.3-5.4-5.3-3.7 0-5.9 2.8-5.9 5.6 0 1.1.4 2.3 1 3 .1.1.1.2.1.4-.1.4-.3 1.3-.4 1.5-.1.2-.2.3-.4.2-1.6-.8-2.6-3.1-2.6-5 0-4.1 3-7.9 8.6-7.9 4.5 0 8 3.2 8 7.5 0 4.5-2.8 8.1-6.7 8.1-1.3 0-2.6-.7-3-1.5 0 0-.7 2.5-.8 3.1-.3 1.1-1.1 2.5-1.6 3.4 1.2.4 2.5.6 3.8.6 7.2 0 13-5.8 13-13 0-7.1-5.8-12.9-13-12.9z"></path></svg>' +
                            '<span>Pinterest</span>' +
                            '</a>' +
                            '<a href="https://twitter.com/intent/tweet?url={{src}}&amp;text={{descr}}" target="_blank" class="fancybox-share_button">' +
                            '<svg version="1.1" viewBox="0 0 32 32" fill="#1da1f2"><path d="M30 7.3c-1 .5-2.1.8-3.3.9 1.2-.7 2.1-1.8 2.5-3.2-1.1.7-2.3 1.1-3.6 1.4-1-1.1-2.5-1.8-4.2-1.8-3.2 0-5.7 2.6-5.7 5.7 0 .5.1.9.1 1.3-4.8-.2-9-2.5-11.8-6-.5.9-.8 1.9-.8 3 0 2 1 3.8 2.6 4.8-.9 0-1.8-.3-2.6-.7v.1c0 2.8 2 5.1 4.6 5.6-.5.1-1 .2-1.5.2-.4 0-.7 0-1.1-.1.7 2.3 2.9 3.9 5.4 4-2 1.5-4.4 2.5-7.1 2.5-.5 0-.9 0-1.4-.1 2.5 1.6 5.6 2.6 8.8 2.6 10.6 0 16.3-8.8 16.3-16.3v-.7c1.1-1 2-2 2.8-3.2z"></path></svg>' +
                            '<span>Twitter</span>' +
                            '</a>' +
                            '</p>' +
                            '<p><input type="text" value="{{src_raw}}" onfocus="this.select()" /></p>' +
                            '</div>'
                    }
                });

                function escapeHtml(string) {
                    var entityMap = {
                        '&': '&amp;',
                        '<': '&lt;',
                        '>': '&gt;',
                        '"': '&quot;',
                        "'": '&#39;',
                        '/': '&#x2F;',
                        '`': '&#x60;',
                        '=': '&#x3D;'
                    };

                    return String(string).replace(/[&<>"'`=\/]/g, function(s) {
                        return entityMap[s];
                    });
                }

                $(document).on('click', '[data-fancybox-share]', function() {
                    var f = $.fancybox.getInstance(),
                        url,
                        tpl;

                    if (f) {
                        url = f.current.opts.hash === false ? f.current.src : window.location;
                        tpl = f.current.opts.share.tpl
                            .replace(/\{\{src\}\}/g, encodeURIComponent(url))
                            .replace(/\{\{src_raw\}\}/g, escapeHtml(url))
                            .replace(/\{\{descr\}\}/g, f.$caption ? encodeURIComponent(f.$caption.text()) : '');

                        $.fancybox.open({
                            src: f.translate(f, tpl),
                            type: 'html',
                            opts: {
                                animationEffect: "fade",
                                animationDuration: 250
                            }
                        });
                    }

                });

            }(document, __webpack_provided_window_dot_jQuery || jQuery));

            // ==========================================================================
            //
            // Hash
            // Enables linking to each modal
            //
            // ==========================================================================
            ;
            (function(document, window, $) {
                'use strict';

                // Simple $.escapeSelector polyfill (for jQuery prior v3)
                if (!$.escapeSelector) {
                    $.escapeSelector = function(sel) {
                        var rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\x80-\uFFFF\w-]/g;
                        var fcssescape = function(ch, asCodePoint) {
                            if (asCodePoint) {
                                // U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER
                                if (ch === "\0") {
                                    return "\uFFFD";
                                }

                                // Control characters and (dependent upon position) numbers get escaped as code points
                                return ch.slice(0, -1) + "\\" + ch.charCodeAt(ch.length - 1).toString(16) + " ";
                            }

                            // Other potentially-special ASCII characters get backslash-escaped
                            return "\\" + ch;
                        };

                        return (sel + "").replace(rcssescape, fcssescape);
                    };
                }

                // Create new history entry only once
                var shouldCreateHistory = true;

                // Variable containing last hash value set by fancyBox
                // It will be used to determine if fancyBox needs to close after hash change is detected
                var currentHash = null;

                // Throttling the history change
                var timerID = null;

                // Get info about gallery name and current index from url
                function parseUrl() {
                    var hash = window.location.hash.substr(1);
                    var rez = hash.split('-');
                    var index = rez.length > 1 && /^\+?\d+$/.test(rez[rez.length - 1]) ? parseInt(rez.pop(-1), 10) || 1 : 1;
                    var gallery = rez.join('-');

                    // Index is starting from 1
                    if (index < 1) {
                        index = 1;
                    }

                    return {
                        hash: hash,
                        index: index,
                        gallery: gallery
                    };
                }

                // Trigger click evnt on links to open new fancyBox instance
                function triggerFromUrl(url) {
                    var $el;

                    if (url.gallery !== '') {

                        // If we can find element matching 'data-fancybox' atribute, then trigger click event for that ..
                        $el = $("[data-fancybox='" + $.escapeSelector(url.gallery) + "']").eq(url.index - 1);

                        if (!$el.length) {
                            // .. if not, try finding element by ID
                            $el = $("#" + $.escapeSelector(url.gallery) + "");
                        }

                        if ($el.length) {
                            shouldCreateHistory = false;

                            $el.trigger('click');
                        }

                    }
                }

                // Get gallery name from current instance
                function getGalleryID(instance) {
                    var opts;

                    if (!instance) {
                        return false;
                    }

                    opts = instance.current ? instance.current.opts : instance.opts;

                    return opts.hash || (opts.$orig ? opts.$orig.data('fancybox') : '');
                }

                // Start when DOM becomes ready
                $(function() {

                    // Check if user has disabled this module
                    if ($.fancybox.defaults.hash === false) {
                        return;
                    }

                    // Update hash when opening/closing fancyBox
                    $(document).on({
                        'onInit.fb': function(e, instance) {
                            var url, gallery;

                            if (instance.group[instance.currIndex].opts.hash === false) {
                                return;
                            }

                            url = parseUrl();
                            gallery = getGalleryID(instance);

                            // Make sure gallery start index matches index from hash
                            if (gallery && url.gallery && gallery == url.gallery) {
                                instance.currIndex = url.index - 1;
                            }
                        },

                        'beforeShow.fb': function(e, instance, current) {
                            var gallery;

                            if (!current || current.opts.hash === false) {
                                return;
                            }

                            gallery = getGalleryID(instance);

                            // Update window hash
                            if (gallery && gallery !== '') {

                                if (window.location.hash.indexOf(gallery) < 0) {
                                    instance.opts.origHash = window.location.hash;
                                }

                                currentHash = gallery + (instance.group.length > 1 ? '-' + (current.index + 1) : '');

                                if ('replaceState' in window.history) {
                                    if (timerID) {
                                        clearTimeout(timerID);
                                    }

                                    timerID = setTimeout(function() {
                                        window.history[shouldCreateHistory ? 'pushState' : 'replaceState']({}, document.title, window.location.pathname + window.location.search + '#' + currentHash);

                                        timerID = null;

                                        shouldCreateHistory = false;

                                    }, 300);

                                } else {
                                    window.location.hash = currentHash;
                                }

                            }

                        },

                        'beforeClose.fb': function(e, instance, current) {
                            var gallery, origHash;

                            if (timerID) {
                                clearTimeout(timerID);
                            }

                            if (current.opts.hash === false) {
                                return;
                            }

                            gallery = getGalleryID(instance);
                            origHash = instance && instance.opts.origHash ? instance.opts.origHash : '';

                            // Remove hash from location bar
                            if (gallery && gallery !== '') {

                                if ('replaceState' in history) {
                                    window.history.replaceState({}, document.title, window.location.pathname + window.location.search + origHash);

                                } else {
                                    window.location.hash = origHash;

                                    // Keep original scroll position
                                    $(window).scrollTop(instance.scrollTop).scrollLeft(instance.scrollLeft);
                                }
                            }

                            currentHash = null;
                        }
                    });

                    // Check if need to close after url has changed
                    $(window).on('hashchange.fb', function() {
                        var url = parseUrl();

                        if ($.fancybox.getInstance()) {
                            if (currentHash && currentHash !== url.gallery + '-' + url.index && !(url.index === 1 && currentHash == url.gallery)) {
                                currentHash = null;

                                $.fancybox.close();
                            }

                        } else if (url.gallery !== '') {
                            triggerFromUrl(url);
                        }
                    });

                    // Check current hash and trigger click event on matching element to start fancyBox, if needed
                    setTimeout(function() {
                        triggerFromUrl(parseUrl());
                    }, 50);
                });

            }(document, window, __webpack_provided_window_dot_jQuery || jQuery));

            /* WEBPACK VAR INJECTION */
        }.call(exports, __webpack_require__(2), __webpack_require__(2)))

        /***/
    }),
    /* 9 */
    /***/
    (function(module, exports) {

        /**
         * Checks if `value` is the
         * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
         * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is an object, else `false`.
         * @example
         *
         * _.isObject({});
         * // => true
         *
         * _.isObject([1, 2, 3]);
         * // => true
         *
         * _.isObject(_.noop);
         * // => true
         *
         * _.isObject(null);
         * // => false
         */
        function isObject(value) {
            var type = typeof value;
            return value != null && (type == 'object' || type == 'function');
        }

        module.exports = isObject;


        /***/
    }),
    /* 10 */
    /***/
    (function(module, exports, __webpack_require__) {

        var freeGlobal = __webpack_require__(43);

        /** Detect free variable `self`. */
        var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

        /** Used as a reference to the global object. */
        var root = freeGlobal || freeSelf || Function('return this')();

        module.exports = root;


        /***/
    }),
    /* 11 */
    /***/
    (function(module, exports, __webpack_require__) {

        var root = __webpack_require__(10);

        /** Built-in value references. */
        var Symbol = root.Symbol;

        module.exports = Symbol;


        /***/
    }),
    /* 12 */
    /***/
    (function(module, exports, __webpack_require__) {

        "use strict";


        __webpack_require__(13);

        __webpack_require__(14);

        __webpack_require__(15);

        __webpack_require__(16);

        __webpack_require__(17);

        __webpack_require__(21);

        __webpack_require__(22);

        __webpack_require__(35);

        __webpack_require__(36);

        __webpack_require__(37);

        __webpack_require__(39);

        /***/
    }),
    /* 13 */
    /***/
    (function(module, exports, __webpack_require__) {

        var __WEBPACK_AMD_DEFINE_RESULT__;
        /*! picturefill - v3.0.2 - 2016-02-12
         * https://scottjehl.github.io/picturefill/
         * Copyright (c) 2016 https://github.com/scottjehl/picturefill/blob/master/Authors.txt; Licensed MIT
         */
        /*! Gecko-Picture - v1.0
         * https://github.com/scottjehl/picturefill/tree/3.0/src/plugins/gecko-picture
         * Firefox's early picture implementation (prior to FF41) is static and does
         * not react to viewport changes. This tiny module fixes this.
         */
        (function(window) {
            /*jshint eqnull:true */
            var ua = navigator.userAgent;

            if (window.HTMLPictureElement && ((/ecko/).test(ua) && ua.match(/rv\:(\d+)/) && RegExp.$1 < 45)) {
                addEventListener("resize", (function() {
                    var timer;

                    var dummySrc = document.createElement("source");

                    var fixRespimg = function(img) {
                        var source, sizes;
                        var picture = img.parentNode;

                        if (picture.nodeName.toUpperCase() === "PICTURE") {
                            source = dummySrc.cloneNode();

                            picture.insertBefore(source, picture.firstElementChild);
                            setTimeout(function() {
                                picture.removeChild(source);
                            });
                        } else if (!img._pfLastSize || img.offsetWidth > img._pfLastSize) {
                            img._pfLastSize = img.offsetWidth;
                            sizes = img.sizes;
                            img.sizes += ",100vw";
                            setTimeout(function() {
                                img.sizes = sizes;
                            });
                        }
                    };

                    var findPictureImgs = function() {
                        var i;
                        var imgs = document.querySelectorAll("picture > img, img[srcset][sizes]");
                        for (i = 0; i < imgs.length; i++) {
                            fixRespimg(imgs[i]);
                        }
                    };
                    var onResize = function() {
                        clearTimeout(timer);
                        timer = setTimeout(findPictureImgs, 99);
                    };
                    var mq = window.matchMedia && matchMedia("(orientation: landscape)");
                    var init = function() {
                        onResize();

                        if (mq && mq.addListener) {
                            mq.addListener(onResize);
                        }
                    };

                    dummySrc.srcset = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==";

                    if (/^[c|i]|d$/.test(document.readyState || "")) {
                        init();
                    } else {
                        document.addEventListener("DOMContentLoaded", init);
                    }

                    return onResize;
                })());
            }
        })(window);

        /*! Picturefill - v3.0.2
         * http://scottjehl.github.io/picturefill
         * Copyright (c) 2015 https://github.com/scottjehl/picturefill/blob/master/Authors.txt;
         *  License: MIT
         */

        (function(window, document, undefined) {
            // Enable strict mode
            "use strict";

            // HTML shim|v it for old IE (IE9 will still need the HTML video tag workaround)
            document.createElement("picture");

            var warn, eminpx, alwaysCheckWDescriptor, evalId;
            // local object for method references and testing exposure
            var pf = {};
            var isSupportTestReady = false;
            var noop = function() {};
            var image = document.createElement("img");
            var getImgAttr = image.getAttribute;
            var setImgAttr = image.setAttribute;
            var removeImgAttr = image.removeAttribute;
            var docElem = document.documentElement;
            var types = {};
            var cfg = {
                //resource selection:
                algorithm: ""
            };
            var srcAttr = "data-pfsrc";
            var srcsetAttr = srcAttr + "set";
            // ua sniffing is done for undetectable img loading features,
            // to do some non crucial perf optimizations
            var ua = navigator.userAgent;
            var supportAbort = (/rident/).test(ua) || ((/ecko/).test(ua) && ua.match(/rv\:(\d+)/) && RegExp.$1 > 35);
            var curSrcProp = "currentSrc";
            var regWDesc = /\s+\+?\d+(e\d+)?w/;
            var regSize = /(\([^)]+\))?\s*(.+)/;
            var setOptions = window.picturefillCFG;
            /**
             * Shortcut property for https://w3c.github.io/webappsec/specs/mixedcontent/#restricts-mixed-content ( for easy overriding in tests )
             */
            // baseStyle also used by getEmValue (i.e.: width: 1em is important)
            var baseStyle = "position:absolute;left:0;visibility:hidden;display:block;padding:0;border:none;font-size:1em;width:1em;overflow:hidden;clip:rect(0px, 0px, 0px, 0px)";
            var fsCss = "font-size:100%!important;";
            var isVwDirty = true;

            var cssCache = {};
            var sizeLengthCache = {};
            var DPR = window.devicePixelRatio;
            var units = {
                px: 1,
                "in": 96
            };
            var anchor = document.createElement("a");
            /**
             * alreadyRun flag used for setOptions. is it true setOptions will reevaluate
             * @type {boolean}
             */
            var alreadyRun = false;

            // Reusable, non-"g" Regexes

            // (Don't use \s, to avoid matching non-breaking space.)
            var regexLeadingSpaces = /^[ \t\n\r\u000c]+/,
                regexLeadingCommasOrSpaces = /^[, \t\n\r\u000c]+/,
                regexLeadingNotSpaces = /^[^ \t\n\r\u000c]+/,
                regexTrailingCommas = /[,]+$/,
                regexNonNegativeInteger = /^\d+$/,

                // ( Positive or negative or unsigned integers or decimals, without or without exponents.
                // Must include at least one digit.
                // According to spec tests any decimal point must be followed by a digit.
                // No leading plus sign is allowed.)
                // https://html.spec.whatwg.org/multipage/infrastructure.html#valid-floating-point-number
                regexFloatingPoint = /^-?(?:[0-9]+|[0-9]*\.[0-9]+)(?:[eE][+-]?[0-9]+)?$/;

            var on = function(obj, evt, fn, capture) {
                if (obj.addEventListener) {
                    obj.addEventListener(evt, fn, capture || false);
                } else if (obj.attachEvent) {
                    obj.attachEvent("on" + evt, fn);
                }
            };

            /**
             * simple memoize function:
             */

            var memoize = function(fn) {
                var cache = {};
                return function(input) {
                    if (!(input in cache)) {
                        cache[input] = fn(input);
                    }
                    return cache[input];
                };
            };

            // UTILITY FUNCTIONS

            // Manual is faster than RegEx
            // http://jsperf.com/whitespace-character/5
            function isSpace(c) {
                return (c === "\u0020" || // space
                    c === "\u0009" || // horizontal tab
                    c === "\u000A" || // new line
                    c === "\u000C" || // form feed
                    c === "\u000D"); // carriage return
            }

            /**
             * gets a mediaquery and returns a boolean or gets a css length and returns a number
             * @param css mediaqueries or css length
             * @returns {boolean|number}
             *
             * based on: https://gist.github.com/jonathantneal/db4f77009b155f083738
             */
            var evalCSS = (function() {

                var regLength = /^([\d\.]+)(em|vw|px)$/;
                var replace = function() {
                    var args = arguments,
                        index = 0,
                        string = args[0];
                    while (++index in args) {
                        string = string.replace(args[index], args[++index]);
                    }
                    return string;
                };

                var buildStr = memoize(function(css) {

                    return "return " + replace((css || "").toLowerCase(),
                        // interpret `and`
                        /\band\b/g, "&&",

                        // interpret `,`
                        /,/g, "||",

                        // interpret `min-` as >=
                        /min-([a-z-\s]+):/g, "e.$1>=",

                        // interpret `max-` as <=
                        /max-([a-z-\s]+):/g, "e.$1<=",

                        //calc value
                        /calc([^)]+)/g, "($1)",

                        // interpret css values
                        /(\d+[\.]*[\d]*)([a-z]+)/g, "($1 * e.$2)",
                        //make eval less evil
                        /^(?!(e.[a-z]|[0-9\.&=|><\+\-\*\(\)\/])).*/ig, ""
                    ) + ";";
                });

                return function(css, length) {
                    var parsedLength;
                    if (!(css in cssCache)) {
                        cssCache[css] = false;
                        if (length && (parsedLength = css.match(regLength))) {
                            cssCache[css] = parsedLength[1] * units[parsedLength[2]];
                        } else {
                            /*jshint evil:true */
                            try {
                                cssCache[css] = new Function("e", buildStr(css))(units);
                            } catch (e) {}
                            /*jshint evil:false */
                        }
                    }
                    return cssCache[css];
                };
            })();

            var setResolution = function(candidate, sizesattr) {
                if (candidate.w) { // h = means height: || descriptor.type === 'h' do not handle yet...
                    candidate.cWidth = pf.calcListLength(sizesattr || "100vw");
                    candidate.res = candidate.w / candidate.cWidth;
                } else {
                    candidate.res = candidate.d;
                }
                return candidate;
            };

            /**
             *
             * @param opt
             */
            var picturefill = function(opt) {

                if (!isSupportTestReady) {
                    return;
                }

                var elements, i, plen;

                var options = opt || {};

                if (options.elements && options.elements.nodeType === 1) {
                    if (options.elements.nodeName.toUpperCase() === "IMG") {
                        options.elements = [options.elements];
                    } else {
                        options.context = options.elements;
                        options.elements = null;
                    }
                }

                elements = options.elements || pf.qsa((options.context || document), (options.reevaluate || options.reselect) ? pf.sel : pf.selShort);

                if ((plen = elements.length)) {

                    pf.setupRun(options);
                    alreadyRun = true;

                    // Loop through all elements
                    for (i = 0; i < plen; i++) {
                        pf.fillImg(elements[i], options);
                    }

                    pf.teardownRun(options);
                }
            };

            /**
             * outputs a warning for the developer
             * @param {message}
             * @type {Function}
             */
            warn = (window.console && console.warn) ?
                function(message) {
                    console.warn(message);
                } :
                noop;

            if (!(curSrcProp in image)) {
                curSrcProp = "src";
            }

            // Add support for standard mime types.
            types["image/jpeg"] = true;
            types["image/gif"] = true;
            types["image/png"] = true;

            function detectTypeSupport(type, typeUri) {
                // based on Modernizr's lossless img-webp test
                // note: asynchronous
                var image = new window.Image();
                image.onerror = function() {
                    types[type] = false;
                    picturefill();
                };
                image.onload = function() {
                    types[type] = image.width === 1;
                    picturefill();
                };
                image.src = typeUri;
                return "pending";
            }

            // test svg support
            types["image/svg+xml"] = document.implementation.hasFeature("http://www.w3.org/TR/SVG11/feature#Image", "1.1");

            /**
             * updates the internal vW property with the current viewport width in px
             */
            function updateMetrics() {

                isVwDirty = false;
                DPR = window.devicePixelRatio;
                cssCache = {};
                sizeLengthCache = {};

                pf.DPR = DPR || 1;

                units.width = Math.max(window.innerWidth || 0, docElem.clientWidth);
                units.height = Math.max(window.innerHeight || 0, docElem.clientHeight);

                units.vw = units.width / 100;
                units.vh = units.height / 100;

                evalId = [units.height, units.width, DPR].join("-");

                units.em = pf.getEmValue();
                units.rem = units.em;
            }

            function chooseLowRes(lowerValue, higherValue, dprValue, isCached) {
                var bonusFactor, tooMuch, bonus, meanDensity;

                //experimental
                if (cfg.algorithm === "saveData") {
                    if (lowerValue > 2.7) {
                        meanDensity = dprValue + 1;
                    } else {
                        tooMuch = higherValue - dprValue;
                        bonusFactor = Math.pow(lowerValue - 0.6, 1.5);

                        bonus = tooMuch * bonusFactor;

                        if (isCached) {
                            bonus += 0.1 * bonusFactor;
                        }

                        meanDensity = lowerValue + bonus;
                    }
                } else {
                    meanDensity = (dprValue > 1) ?
                        Math.sqrt(lowerValue * higherValue) :
                        lowerValue;
                }

                return meanDensity > dprValue;
            }

            function applyBestCandidate(img) {
                var srcSetCandidates;
                var matchingSet = pf.getSet(img);
                var evaluated = false;
                if (matchingSet !== "pending") {
                    evaluated = evalId;
                    if (matchingSet) {
                        srcSetCandidates = pf.setRes(matchingSet);
                        pf.applySetCandidate(srcSetCandidates, img);
                    }
                }
                img[pf.ns].evaled = evaluated;
            }

            function ascendingSort(a, b) {
                return a.res - b.res;
            }

            function setSrcToCur(img, src, set) {
                var candidate;
                if (!set && src) {
                    set = img[pf.ns].sets;
                    set = set && set[set.length - 1];
                }

                candidate = getCandidateForSrc(src, set);

                if (candidate) {
                    src = pf.makeUrl(src);
                    img[pf.ns].curSrc = src;
                    img[pf.ns].curCan = candidate;

                    if (!candidate.res) {
                        setResolution(candidate, candidate.set.sizes);
                    }
                }
                return candidate;
            }

            function getCandidateForSrc(src, set) {
                var i, candidate, candidates;
                if (src && set) {
                    candidates = pf.parseSet(set);
                    src = pf.makeUrl(src);
                    for (i = 0; i < candidates.length; i++) {
                        if (src === pf.makeUrl(candidates[i].url)) {
                            candidate = candidates[i];
                            break;
                        }
                    }
                }
                return candidate;
            }

            function getAllSourceElements(picture, candidates) {
                var i, len, source, srcset;

                // SPEC mismatch intended for size and perf:
                // actually only source elements preceding the img should be used
                // also note: don't use qsa here, because IE8 sometimes doesn't like source as the key part in a selector
                var sources = picture.getElementsByTagName("source");

                for (i = 0, len = sources.length; i < len; i++) {
                    source = sources[i];
                    source[pf.ns] = true;
                    srcset = source.getAttribute("srcset");

                    // if source does not have a srcset attribute, skip
                    if (srcset) {
                        candidates.push({
                            srcset: srcset,
                            media: source.getAttribute("media"),
                            type: source.getAttribute("type"),
                            sizes: source.getAttribute("sizes")
                        });
                    }
                }
            }

            /**
             * Srcset Parser
             * By Alex Bell |  MIT License
             *
             * @returns Array [{url: _, d: _, w: _, h:_, set:_(????)}, ...]
             *
             * Based super duper closely on the reference algorithm at:
             * https://html.spec.whatwg.org/multipage/embedded-content.html#parse-a-srcset-attribute
             */

            // 1. Let input be the value passed to this algorithm.
            // (TO-DO : Explain what "set" argument is here. Maybe choose a more
            // descriptive & more searchable name.  Since passing the "set" in really has
            // nothing to do with parsing proper, I would prefer this assignment eventually
            // go in an external fn.)
            function parseSrcset(input, set) {

                function collectCharacters(regEx) {
                    var chars,
                        match = regEx.exec(input.substring(pos));
                    if (match) {
                        chars = match[0];
                        pos += chars.length;
                        return chars;
                    }
                }

                var inputLength = input.length,
                    url,
                    descriptors,
                    currentDescriptor,
                    state,
                    c,

                    // 2. Let position be a pointer into input, initially pointing at the start
                    //    of the string.
                    pos = 0,

                    // 3. Let candidates be an initially empty source set.
                    candidates = [];

                /**
                 * Adds descriptor properties to a candidate, pushes to the candidates array
                 * @return undefined
                 */
                // (Declared outside of the while loop so that it's only created once.
                // (This fn is defined before it is used, in order to pass JSHINT.
                // Unfortunately this breaks the sequencing of the spec comments. :/ )
                function parseDescriptors() {

                    // 9. Descriptor parser: Let error be no.
                    var pError = false,

                        // 10. Let width be absent.
                        // 11. Let density be absent.
                        // 12. Let future-compat-h be absent. (We're implementing it now as h)
                        w, d, h, i,
                        candidate = {},
                        desc, lastChar, value, intVal, floatVal;

                    // 13. For each descriptor in descriptors, run the appropriate set of steps
                    // from the following list:
                    for (i = 0; i < descriptors.length; i++) {
                        desc = descriptors[i];

                        lastChar = desc[desc.length - 1];
                        value = desc.substring(0, desc.length - 1);
                        intVal = parseInt(value, 10);
                        floatVal = parseFloat(value);

                        // If the descriptor consists of a valid non-negative integer followed by
                        // a U+0077 LATIN SMALL LETTER W character
                        if (regexNonNegativeInteger.test(value) && (lastChar === "w")) {

                            // If width and density are not both absent, then let error be yes.
                            if (w || d) {
                                pError = true;
                            }

                            // Apply the rules for parsing non-negative integers to the descriptor.
                            // If the result is zero, let error be yes.
                            // Otherwise, let width be the result.
                            if (intVal === 0) {
                                pError = true;
                            } else {
                                w = intVal;
                            }

                            // If the descriptor consists of a valid floating-point number followed by
                            // a U+0078 LATIN SMALL LETTER X character
                        } else if (regexFloatingPoint.test(value) && (lastChar === "x")) {

                            // If width, density and future-compat-h are not all absent, then let error
                            // be yes.
                            if (w || d || h) {
                                pError = true;
                            }

                            // Apply the rules for parsing floating-point number values to the descriptor.
                            // If the result is less than zero, let error be yes. Otherwise, let density
                            // be the result.
                            if (floatVal < 0) {
                                pError = true;
                            } else {
                                d = floatVal;
                            }

                            // If the descriptor consists of a valid non-negative integer followed by
                            // a U+0068 LATIN SMALL LETTER H character
                        } else if (regexNonNegativeInteger.test(value) && (lastChar === "h")) {

                            // If height and density are not both absent, then let error be yes.
                            if (h || d) {
                                pError = true;
                            }

                            // Apply the rules for parsing non-negative integers to the descriptor.
                            // If the result is zero, let error be yes. Otherwise, let future-compat-h
                            // be the result.
                            if (intVal === 0) {
                                pError = true;
                            } else {
                                h = intVal;
                            }

                            // Anything else, Let error be yes.
                        } else {
                            pError = true;
                        }
                    } // (close step 13 for loop)

                    // 15. If error is still no, then append a new image source to candidates whose
                    // URL is url, associated with a width width if not absent and a pixel
                    // density density if not absent. Otherwise, there is a parse error.
                    if (!pError) {
                        candidate.url = url;

                        if (w) {
                            candidate.w = w;
                        }
                        if (d) {
                            candidate.d = d;
                        }
                        if (h) {
                            candidate.h = h;
                        }
                        if (!h && !d && !w) {
                            candidate.d = 1;
                        }
                        if (candidate.d === 1) {
                            set.has1x = true;
                        }
                        candidate.set = set;

                        candidates.push(candidate);
                    }
                } // (close parseDescriptors fn)

                /**
                 * Tokenizes descriptor properties prior to parsing
                 * Returns undefined.
                 * (Again, this fn is defined before it is used, in order to pass JSHINT.
                 * Unfortunately this breaks the logical sequencing of the spec comments. :/ )
                 */
                function tokenize() {

                    // 8.1. Descriptor tokeniser: Skip whitespace
                    collectCharacters(regexLeadingSpaces);

                    // 8.2. Let current descriptor be the empty string.
                    currentDescriptor = "";

                    // 8.3. Let state be in descriptor.
                    state = "in descriptor";

                    while (true) {

                        // 8.4. Let c be the character at position.
                        c = input.charAt(pos);

                        //  Do the following depending on the value of state.
                        //  For the purpose of this step, "EOF" is a special character representing
                        //  that position is past the end of input.

                        // In descriptor
                        if (state === "in descriptor") {
                            // Do the following, depending on the value of c:

                            // Space character
                            // If current descriptor is not empty, append current descriptor to
                            // descriptors and let current descriptor be the empty string.
                            // Set state to after descriptor.
                            if (isSpace(c)) {
                                if (currentDescriptor) {
                                    descriptors.push(currentDescriptor);
                                    currentDescriptor = "";
                                    state = "after descriptor";
                                }

                                // U+002C COMMA (,)
                                // Advance position to the next character in input. If current descriptor
                                // is not empty, append current descriptor to descriptors. Jump to the step
                                // labeled descriptor parser.
                            } else if (c === ",") {
                                pos += 1;
                                if (currentDescriptor) {
                                    descriptors.push(currentDescriptor);
                                }
                                parseDescriptors();
                                return;

                                // U+0028 LEFT PARENTHESIS (()
                                // Append c to current descriptor. Set state to in parens.
                            } else if (c === "\u0028") {
                                currentDescriptor = currentDescriptor + c;
                                state = "in parens";

                                // EOF
                                // If current descriptor is not empty, append current descriptor to
                                // descriptors. Jump to the step labeled descriptor parser.
                            } else if (c === "") {
                                if (currentDescriptor) {
                                    descriptors.push(currentDescriptor);
                                }
                                parseDescriptors();
                                return;

                                // Anything else
                                // Append c to current descriptor.
                            } else {
                                currentDescriptor = currentDescriptor + c;
                            }
                            // (end "in descriptor"

                            // In parens
                        } else if (state === "in parens") {

                            // U+0029 RIGHT PARENTHESIS ())
                            // Append c to current descriptor. Set state to in descriptor.
                            if (c === ")") {
                                currentDescriptor = currentDescriptor + c;
                                state = "in descriptor";

                                // EOF
                                // Append current descriptor to descriptors. Jump to the step labeled
                                // descriptor parser.
                            } else if (c === "") {
                                descriptors.push(currentDescriptor);
                                parseDescriptors();
                                return;

                                // Anything else
                                // Append c to current descriptor.
                            } else {
                                currentDescriptor = currentDescriptor + c;
                            }

                            // After descriptor
                        } else if (state === "after descriptor") {

                            // Do the following, depending on the value of c:
                            // Space character: Stay in this state.
                            if (isSpace(c)) {

                                // EOF: Jump to the step labeled descriptor parser.
                            } else if (c === "") {
                                parseDescriptors();
                                return;

                                // Anything else
                                // Set state to in descriptor. Set position to the previous character in input.
                            } else {
                                state = "in descriptor";
                                pos -= 1;

                            }
                        }

                        // Advance position to the next character in input.
                        pos += 1;

                        // Repeat this step.
                    } // (close while true loop)
                }

                // 4. Splitting loop: Collect a sequence of characters that are space
                //    characters or U+002C COMMA characters. If any U+002C COMMA characters
                //    were collected, that is a parse error.
                while (true) {
                    collectCharacters(regexLeadingCommasOrSpaces);

                    // 5. If position is past the end of input, return candidates and abort these steps.
                    if (pos >= inputLength) {
                        return candidates; // (we're done, this is the sole return path)
                    }

                    // 6. Collect a sequence of characters that are not space characters,
                    //    and let that be url.
                    url = collectCharacters(regexLeadingNotSpaces);

                    // 7. Let descriptors be a new empty list.
                    descriptors = [];

                    // 8. If url ends with a U+002C COMMA character (,), follow these substeps:
                    //		(1). Remove all trailing U+002C COMMA characters from url. If this removed
                    //         more than one character, that is a parse error.
                    if (url.slice(-1) === ",") {
                        url = url.replace(regexTrailingCommas, "");
                        // (Jump ahead to step 9 to skip tokenization and just push the candidate).
                        parseDescriptors();

                        //	Otherwise, follow these substeps:
                    } else {
                        tokenize();
                    } // (close else of step 8)

                    // 16. Return to the step labeled splitting loop.
                } // (Close of big while loop.)
            }

            /*
             * Sizes Parser
             *
             * By Alex Bell |  MIT License
             *
             * Non-strict but accurate and lightweight JS Parser for the string value <img sizes="here">
             *
             * Reference algorithm at:
             * https://html.spec.whatwg.org/multipage/embedded-content.html#parse-a-sizes-attribute
             *
             * Most comments are copied in directly from the spec
             * (except for comments in parens).
             *
             * Grammar is:
             * <source-size-list> = <source-size># [ , <source-size-value> ]? | <source-size-value>
             * <source-size> = <media-condition> <source-size-value>
             * <source-size-value> = <length>
             * http://www.w3.org/html/wg/drafts/html/master/embedded-content.html#attr-img-sizes
             *
             * E.g. "(max-width: 30em) 100vw, (max-width: 50em) 70vw, 100vw"
             * or "(min-width: 30em), calc(30vw - 15px)" or just "30vw"
             *
             * Returns the first valid <css-length> with a media condition that evaluates to true,
             * or "100vw" if all valid media conditions evaluate to false.
             *
             */

            function parseSizes(strValue) {

                // (Percentage CSS lengths are not allowed in this case, to avoid confusion:
                // https://html.spec.whatwg.org/multipage/embedded-content.html#valid-source-size-list
                // CSS allows a single optional plus or minus sign:
                // http://www.w3.org/TR/CSS2/syndata.html#numbers
                // CSS is ASCII case-insensitive:
                // http://www.w3.org/TR/CSS2/syndata.html#characters )
                // Spec allows exponential notation for <number> type:
                // http://dev.w3.org/csswg/css-values/#numbers
                var regexCssLengthWithUnits = /^(?:[+-]?[0-9]+|[0-9]*\.[0-9]+)(?:[eE][+-]?[0-9]+)?(?:ch|cm|em|ex|in|mm|pc|pt|px|rem|vh|vmin|vmax|vw)$/i;

                // (This is a quick and lenient test. Because of optional unlimited-depth internal
                // grouping parens and strict spacing rules, this could get very complicated.)
                var regexCssCalc = /^calc\((?:[0-9a-z \.\+\-\*\/\(\)]+)\)$/i;

                var i;
                var unparsedSizesList;
                var unparsedSizesListLength;
                var unparsedSize;
                var lastComponentValue;
                var size;

                // UTILITY FUNCTIONS

                //  (Toy CSS parser. The goals here are:
                //  1) expansive test coverage without the weight of a full CSS parser.
                //  2) Avoiding regex wherever convenient.
                //  Quick tests: http://jsfiddle.net/gtntL4gr/3/
                //  Returns an array of arrays.)
                function parseComponentValues(str) {
                    var chrctr;
                    var component = "";
                    var componentArray = [];
                    var listArray = [];
                    var parenDepth = 0;
                    var pos = 0;
                    var inComment = false;

                    function pushComponent() {
                        if (component) {
                            componentArray.push(component);
                            component = "";
                        }
                    }

                    function pushComponentArray() {
                        if (componentArray[0]) {
                            listArray.push(componentArray);
                            componentArray = [];
                        }
                    }

                    // (Loop forwards from the beginning of the string.)
                    while (true) {
                        chrctr = str.charAt(pos);

                        if (chrctr === "") { // ( End of string reached.)
                            pushComponent();
                            pushComponentArray();
                            return listArray;
                        } else if (inComment) {
                            if ((chrctr === "*") && (str[pos + 1] === "/")) { // (At end of a comment.)
                                inComment = false;
                                pos += 2;
                                pushComponent();
                                continue;
                            } else {
                                pos += 1; // (Skip all characters inside comments.)
                                continue;
                            }
                        } else if (isSpace(chrctr)) {
                            // (If previous character in loop was also a space, or if
                            // at the beginning of the string, do not add space char to
                            // component.)
                            if ((str.charAt(pos - 1) && isSpace(str.charAt(pos - 1))) || !component) {
                                pos += 1;
                                continue;
                            } else if (parenDepth === 0) {
                                pushComponent();
                                pos += 1;
                                continue;
                            } else {
                                // (Replace any space character with a plain space for legibility.)
                                chrctr = " ";
                            }
                        } else if (chrctr === "(") {
                            parenDepth += 1;
                        } else if (chrctr === ")") {
                            parenDepth -= 1;
                        } else if (chrctr === ",") {
                            pushComponent();
                            pushComponentArray();
                            pos += 1;
                            continue;
                        } else if ((chrctr === "/") && (str.charAt(pos + 1) === "*")) {
                            inComment = true;
                            pos += 2;
                            continue;
                        }

                        component = component + chrctr;
                        pos += 1;
                    }
                }

                function isValidNonNegativeSourceSizeValue(s) {
                    if (regexCssLengthWithUnits.test(s) && (parseFloat(s) >= 0)) {
                        return true;
                    }
                    if (regexCssCalc.test(s)) {
                        return true;
                    }
                    // ( http://www.w3.org/TR/CSS2/syndata.html#numbers says:
                    // "-0 is equivalent to 0 and is not a negative number." which means that
                    // unitless zero and unitless negative zero must be accepted as special cases.)
                    if ((s === "0") || (s === "-0") || (s === "+0")) {
                        return true;
                    }
                    return false;
                }

                // When asked to parse a sizes attribute from an element, parse a
                // comma-separated list of component values from the value of the element's
                // sizes attribute (or the empty string, if the attribute is absent), and let
                // unparsed sizes list be the result.
                // http://dev.w3.org/csswg/css-syntax/#parse-comma-separated-list-of-component-values

                unparsedSizesList = parseComponentValues(strValue);
                unparsedSizesListLength = unparsedSizesList.length;

                // For each unparsed size in unparsed sizes list:
                for (i = 0; i < unparsedSizesListLength; i++) {
                    unparsedSize = unparsedSizesList[i];

                    // 1. Remove all consecutive <whitespace-token>s from the end of unparsed size.
                    // ( parseComponentValues() already omits spaces outside of parens. )

                    // If unparsed size is now empty, that is a parse error; continue to the next
                    // iteration of this algorithm.
                    // ( parseComponentValues() won't push an empty array. )

                    // 2. If the last component value in unparsed size is a valid non-negative
                    // <source-size-value>, let size be its value and remove the component value
                    // from unparsed size. Any CSS function other than the calc() function is
                    // invalid. Otherwise, there is a parse error; continue to the next iteration
                    // of this algorithm.
                    // http://dev.w3.org/csswg/css-syntax/#parse-component-value
                    lastComponentValue = unparsedSize[unparsedSize.length - 1];

                    if (isValidNonNegativeSourceSizeValue(lastComponentValue)) {
                        size = lastComponentValue;
                        unparsedSize.pop();
                    } else {
                        continue;
                    }

                    // 3. Remove all consecutive <whitespace-token>s from the end of unparsed
                    // size. If unparsed size is now empty, return size and exit this algorithm.
                    // If this was not the last item in unparsed sizes list, that is a parse error.
                    if (unparsedSize.length === 0) {
                        return size;
                    }

                    // 4. Parse the remaining component values in unparsed size as a
                    // <media-condition>. If it does not parse correctly, or it does parse
                    // correctly but the <media-condition> evaluates to false, continue to the
                    // next iteration of this algorithm.
                    // (Parsing all possible compound media conditions in JS is heavy, complicated,
                    // and the payoff is unclear. Is there ever an situation where the
                    // media condition parses incorrectly but still somehow evaluates to true?
                    // Can we just rely on the browser/polyfill to do it?)
                    unparsedSize = unparsedSize.join(" ");
                    if (!(pf.matchesMedia(unparsedSize))) {
                        continue;
                    }

                    // 5. Return size and exit this algorithm.
                    return size;
                }

                // If the above algorithm exhausts unparsed sizes list without returning a
                // size value, return 100vw.
                return "100vw";
            }

            // namespace
            pf.ns = ("pf" + new Date().getTime()).substr(0, 9);

            // srcset support test
            pf.supSrcset = "srcset" in image;
            pf.supSizes = "sizes" in image;
            pf.supPicture = !!window.HTMLPictureElement;

            // UC browser does claim to support srcset and picture, but not sizes,
            // this extended test reveals the browser does support nothing
            if (pf.supSrcset && pf.supPicture && !pf.supSizes) {
                (function(image2) {
                    image.srcset = "data:,a";
                    image2.src = "data:,a";
                    pf.supSrcset = image.complete === image2.complete;
                    pf.supPicture = pf.supSrcset && pf.supPicture;
                })(document.createElement("img"));
            }

            // Safari9 has basic support for sizes, but does't expose the `sizes` idl attribute
            if (pf.supSrcset && !pf.supSizes) {

                (function() {
                    var width2 = "data:image/gif;base64,R0lGODlhAgABAPAAAP///wAAACH5BAAAAAAALAAAAAACAAEAAAICBAoAOw==";
                    var width1 = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==";
                    var img = document.createElement("img");
                    var test = function() {
                        var width = img.width;

                        if (width === 2) {
                            pf.supSizes = true;
                        }

                        alwaysCheckWDescriptor = pf.supSrcset && !pf.supSizes;

                        isSupportTestReady = true;
                        // force async
                        setTimeout(picturefill);
                    };

                    img.onload = test;
                    img.onerror = test;
                    img.setAttribute("sizes", "9px");

                    img.srcset = width1 + " 1w," + width2 + " 9w";
                    img.src = width1;
                })();

            } else {
                isSupportTestReady = true;
            }

            // using pf.qsa instead of dom traversing does scale much better,
            // especially on sites mixing responsive and non-responsive images
            pf.selShort = "picture>img,img[srcset]";
            pf.sel = pf.selShort;
            pf.cfg = cfg;

            /**
             * Shortcut property for `devicePixelRatio` ( for easy overriding in tests )
             */
            pf.DPR = (DPR || 1);
            pf.u = units;

            // container of supported mime types that one might need to qualify before using
            pf.types = types;

            pf.setSize = noop;

            /**
             * Gets a string and returns the absolute URL
             * @param src
             * @returns {String} absolute URL
             */

            pf.makeUrl = memoize(function(src) {
                anchor.href = src;
                return anchor.href;
            });

            /**
             * Gets a DOM element or document and a selctor and returns the found matches
             * Can be extended with jQuery/Sizzle for IE7 support
             * @param context
             * @param sel
             * @returns {NodeList|Array}
             */
            pf.qsa = function(context, sel) {
                return ("querySelector" in context) ? context.querySelectorAll(sel) : [];
            };

            /**
             * Shortcut method for matchMedia ( for easy overriding in tests )
             * wether native or pf.mMQ is used will be decided lazy on first call
             * @returns {boolean}
             */
            pf.matchesMedia = function() {
                if (window.matchMedia && (matchMedia("(min-width: 0.1em)") || {}).matches) {
                    pf.matchesMedia = function(media) {
                        return !media || (matchMedia(media).matches);
                    };
                } else {
                    pf.matchesMedia = pf.mMQ;
                }

                return pf.matchesMedia.apply(this, arguments);
            };

            /**
             * A simplified matchMedia implementation for IE8 and IE9
             * handles only min-width/max-width with px or em values
             * @param media
             * @returns {boolean}
             */
            pf.mMQ = function(media) {
                return media ? evalCSS(media) : true;
            };

            /**
             * Returns the calculated length in css pixel from the given sourceSizeValue
             * http://dev.w3.org/csswg/css-values-3/#length-value
             * intended Spec mismatches:
             * * Does not check for invalid use of CSS functions
             * * Does handle a computed length of 0 the same as a negative and therefore invalid value
             * @param sourceSizeValue
             * @returns {Number}
             */
            pf.calcLength = function(sourceSizeValue) {

                var value = evalCSS(sourceSizeValue, true) || false;
                if (value < 0) {
                    value = false;
                }

                return value;
            };

            /**
             * Takes a type string and checks if its supported
             */

            pf.supportsType = function(type) {
                return (type) ? types[type] : true;
            };

            /**
             * Parses a sourceSize into mediaCondition (media) and sourceSizeValue (length)
             * @param sourceSizeStr
             * @returns {*}
             */
            pf.parseSize = memoize(function(sourceSizeStr) {
                var match = (sourceSizeStr || "").match(regSize);
                return {
                    media: match && match[1],
                    length: match && match[2]
                };
            });

            pf.parseSet = function(set) {
                if (!set.cands) {
                    set.cands = parseSrcset(set.srcset, set);
                }
                return set.cands;
            };

            /**
             * returns 1em in css px for html/body default size
             * function taken from respondjs
             * @returns {*|number}
             */
            pf.getEmValue = function() {
                var body;
                if (!eminpx && (body = document.body)) {
                    var div = document.createElement("div"),
                        originalHTMLCSS = docElem.style.cssText,
                        originalBodyCSS = body.style.cssText;

                    div.style.cssText = baseStyle;

                    // 1em in a media query is the value of the default font size of the browser
                    // reset docElem and body to ensure the correct value is returned
                    docElem.style.cssText = fsCss;
                    body.style.cssText = fsCss;

                    body.appendChild(div);
                    eminpx = div.offsetWidth;
                    body.removeChild(div);

                    //also update eminpx before returning
                    eminpx = parseFloat(eminpx, 10);

                    // restore the original values
                    docElem.style.cssText = originalHTMLCSS;
                    body.style.cssText = originalBodyCSS;

                }
                return eminpx || 16;
            };

            /**
             * Takes a string of sizes and returns the width in pixels as a number
             */
            pf.calcListLength = function(sourceSizeListStr) {
                // Split up source size list, ie ( max-width: 30em ) 100%, ( max-width: 50em ) 50%, 33%
                //
                //                           or (min-width:30em) calc(30% - 15px)
                if (!(sourceSizeListStr in sizeLengthCache) || cfg.uT) {
                    var winningLength = pf.calcLength(parseSizes(sourceSizeListStr));

                    sizeLengthCache[sourceSizeListStr] = !winningLength ? units.width : winningLength;
                }

                return sizeLengthCache[sourceSizeListStr];
            };

            /**
             * Takes a candidate object with a srcset property in the form of url/
             * ex. "images/pic-medium.png 1x, images/pic-medium-2x.png 2x" or
             *     "images/pic-medium.png 400w, images/pic-medium-2x.png 800w" or
             *     "images/pic-small.png"
             * Get an array of image candidates in the form of
             *      {url: "/foo/bar.png", resolution: 1}
             * where resolution is http://dev.w3.org/csswg/css-values-3/#resolution-value
             * If sizes is specified, res is calculated
             */
            pf.setRes = function(set) {
                var candidates;
                if (set) {

                    candidates = pf.parseSet(set);

                    for (var i = 0, len = candidates.length; i < len; i++) {
                        setResolution(candidates[i], set.sizes);
                    }
                }
                return candidates;
            };

            pf.setRes.res = setResolution;

            pf.applySetCandidate = function(candidates, img) {
                if (!candidates.length) {
                    return;
                }
                var candidate,
                    i,
                    j,
                    length,
                    bestCandidate,
                    curSrc,
                    curCan,
                    candidateSrc,
                    abortCurSrc;

                var imageData = img[pf.ns];
                var dpr = pf.DPR;

                curSrc = imageData.curSrc || img[curSrcProp];

                curCan = imageData.curCan || setSrcToCur(img, curSrc, candidates[0].set);

                // if we have a current source, we might either become lazy or give this source some advantage
                if (curCan && curCan.set === candidates[0].set) {

                    // if browser can abort image request and the image has a higher pixel density than needed
                    // and this image isn't downloaded yet, we skip next part and try to save bandwidth
                    abortCurSrc = (supportAbort && !img.complete && curCan.res - 0.1 > dpr);

                    if (!abortCurSrc) {
                        curCan.cached = true;

                        // if current candidate is "best", "better" or "okay",
                        // set it to bestCandidate
                        if (curCan.res >= dpr) {
                            bestCandidate = curCan;
                        }
                    }
                }

                if (!bestCandidate) {

                    candidates.sort(ascendingSort);

                    length = candidates.length;
                    bestCandidate = candidates[length - 1];

                    for (i = 0; i < length; i++) {
                        candidate = candidates[i];
                        if (candidate.res >= dpr) {
                            j = i - 1;

                            // we have found the perfect candidate,
                            // but let's improve this a little bit with some assumptions ;-)
                            if (candidates[j] &&
                                (abortCurSrc || curSrc !== pf.makeUrl(candidate.url)) &&
                                chooseLowRes(candidates[j].res, candidate.res, dpr, candidates[j].cached)) {

                                bestCandidate = candidates[j];

                            } else {
                                bestCandidate = candidate;
                            }
                            break;
                        }
                    }
                }

                if (bestCandidate) {

                    candidateSrc = pf.makeUrl(bestCandidate.url);

                    imageData.curSrc = candidateSrc;
                    imageData.curCan = bestCandidate;

                    if (candidateSrc !== curSrc) {
                        pf.setSrc(img, bestCandidate);
                    }
                    pf.setSize(img);
                }
            };

            pf.setSrc = function(img, bestCandidate) {
                var origWidth;
                img.src = bestCandidate.url;

                // although this is a specific Safari issue, we don't want to take too much different code paths
                if (bestCandidate.set.type === "image/svg+xml") {
                    origWidth = img.style.width;
                    img.style.width = (img.offsetWidth + 1) + "px";

                    // next line only should trigger a repaint
                    // if... is only done to trick dead code removal
                    if (img.offsetWidth + 1) {
                        img.style.width = origWidth;
                    }
                }
            };

            pf.getSet = function(img) {
                var i, set, supportsType;
                var match = false;
                var sets = img[pf.ns].sets;

                for (i = 0; i < sets.length && !match; i++) {
                    set = sets[i];

                    if (!set.srcset || !pf.matchesMedia(set.media) || !(supportsType = pf.supportsType(set.type))) {
                        continue;
                    }

                    if (supportsType === "pending") {
                        set = supportsType;
                    }

                    match = set;
                    break;
                }

                return match;
            };

            pf.parseSets = function(element, parent, options) {
                var srcsetAttribute, imageSet, isWDescripor, srcsetParsed;

                var hasPicture = parent && parent.nodeName.toUpperCase() === "PICTURE";
                var imageData = element[pf.ns];

                if (imageData.src === undefined || options.src) {
                    imageData.src = getImgAttr.call(element, "src");
                    if (imageData.src) {
                        setImgAttr.call(element, srcAttr, imageData.src);
                    } else {
                        removeImgAttr.call(element, srcAttr);
                    }
                }

                if (imageData.srcset === undefined || options.srcset || !pf.supSrcset || element.srcset) {
                    srcsetAttribute = getImgAttr.call(element, "srcset");
                    imageData.srcset = srcsetAttribute;
                    srcsetParsed = true;
                }

                imageData.sets = [];

                if (hasPicture) {
                    imageData.pic = true;
                    getAllSourceElements(parent, imageData.sets);
                }

                if (imageData.srcset) {
                    imageSet = {
                        srcset: imageData.srcset,
                        sizes: getImgAttr.call(element, "sizes")
                    };

                    imageData.sets.push(imageSet);

                    isWDescripor = (alwaysCheckWDescriptor || imageData.src) && regWDesc.test(imageData.srcset || "");

                    // add normal src as candidate, if source has no w descriptor
                    if (!isWDescripor && imageData.src && !getCandidateForSrc(imageData.src, imageSet) && !imageSet.has1x) {
                        imageSet.srcset += ", " + imageData.src;
                        imageSet.cands.push({
                            url: imageData.src,
                            d: 1,
                            set: imageSet
                        });
                    }

                } else if (imageData.src) {
                    imageData.sets.push({
                        srcset: imageData.src,
                        sizes: null
                    });
                }

                imageData.curCan = null;
                imageData.curSrc = undefined;

                // if img has picture or the srcset was removed or has a srcset and does not support srcset at all
                // or has a w descriptor (and does not support sizes) set support to false to evaluate
                imageData.supported = !(hasPicture || (imageSet && !pf.supSrcset) || (isWDescripor && !pf.supSizes));

                if (srcsetParsed && pf.supSrcset && !imageData.supported) {
                    if (srcsetAttribute) {
                        setImgAttr.call(element, srcsetAttr, srcsetAttribute);
                        element.srcset = "";
                    } else {
                        removeImgAttr.call(element, srcsetAttr);
                    }
                }

                if (imageData.supported && !imageData.srcset && ((!imageData.src && element.src) || element.src !== pf.makeUrl(imageData.src))) {
                    if (imageData.src === null) {
                        element.removeAttribute("src");
                    } else {
                        element.src = imageData.src;
                    }
                }

                imageData.parsed = true;
            };

            pf.fillImg = function(element, options) {
                var imageData;
                var extreme = options.reselect || options.reevaluate;

                // expando for caching data on the img
                if (!element[pf.ns]) {
                    element[pf.ns] = {};
                }

                imageData = element[pf.ns];

                // if the element has already been evaluated, skip it
                // unless `options.reevaluate` is set to true ( this, for example,
                // is set to true when running `picturefill` on `resize` ).
                if (!extreme && imageData.evaled === evalId) {
                    return;
                }

                if (!imageData.parsed || options.reevaluate) {
                    pf.parseSets(element, element.parentNode, options);
                }

                if (!imageData.supported) {
                    applyBestCandidate(element);
                } else {
                    imageData.evaled = evalId;
                }
            };

            pf.setupRun = function() {
                if (!alreadyRun || isVwDirty || (DPR !== window.devicePixelRatio)) {
                    updateMetrics();
                }
            };

            // If picture is supported, well, that's awesome.
            if (pf.supPicture) {
                picturefill = noop;
                pf.fillImg = noop;
            } else {

                // Set up picture polyfill by polling the document
                (function() {
                    var isDomReady;
                    var regReady = window.attachEvent ? /d$|^c/ : /d$|^c|^i/;

                    var run = function() {
                        var readyState = document.readyState || "";

                        timerId = setTimeout(run, readyState === "loading" ? 200 : 999);
                        if (document.body) {
                            pf.fillImgs();
                            isDomReady = isDomReady || regReady.test(readyState);
                            if (isDomReady) {
                                clearTimeout(timerId);
                            }

                        }
                    };

                    var timerId = setTimeout(run, document.body ? 9 : 99);

                    // Also attach picturefill on resize and readystatechange
                    // http://modernjavascript.blogspot.com/2013/08/building-better-debounce.html
                    var debounce = function(func, wait) {
                        var timeout, timestamp;
                        var later = function() {
                            var last = (new Date()) - timestamp;

                            if (last < wait) {
                                timeout = setTimeout(later, wait - last);
                            } else {
                                timeout = null;
                                func();
                            }
                        };

                        return function() {
                            timestamp = new Date();

                            if (!timeout) {
                                timeout = setTimeout(later, wait);
                            }
                        };
                    };
                    var lastClientWidth = docElem.clientHeight;
                    var onResize = function() {
                        isVwDirty = Math.max(window.innerWidth || 0, docElem.clientWidth) !== units.width || docElem.clientHeight !== lastClientWidth;
                        lastClientWidth = docElem.clientHeight;
                        if (isVwDirty) {
                            pf.fillImgs();
                        }
                    };

                    on(window, "resize", debounce(onResize, 99));
                    on(document, "readystatechange", run);
                })();
            }

            pf.picturefill = picturefill;
            //use this internally for easy monkey patching/performance testing
            pf.fillImgs = picturefill;
            pf.teardownRun = noop;

            /* expose methods for testing */
            picturefill._ = pf;

            window.picturefillCFG = {
                pf: pf,
                push: function(args) {
                    var name = args.shift();
                    if (typeof pf[name] === "function") {
                        pf[name].apply(pf, args);
                    } else {
                        cfg[name] = args[0];
                        if (alreadyRun) {
                            pf.fillImgs({
                                reselect: true
                            });
                        }
                    }
                }
            };

            while (setOptions && setOptions.length) {
                window.picturefillCFG.push(setOptions.shift());
            }

            /* expose picturefill */
            window.picturefill = picturefill;

            /* expose picturefill */
            if (typeof module === "object" && typeof module.exports === "object") {
                // CommonJS, just export
                module.exports = picturefill;
            } else if (true) {
                // AMD support
                !(__WEBPACK_AMD_DEFINE_RESULT__ = function() {
                        return picturefill;
                    }.call(exports, __webpack_require__, exports, module),
                    __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
            }

            // IE8 evals this sync, so it must be the last thing we do
            if (!pf.supPicture) {
                types["image/webp"] = detectTypeSupport("image/webp", "data:image/webp;base64,UklGRkoAAABXRUJQVlA4WAoAAAAQAAAAAAAAAAAAQUxQSAwAAAABBxAR/Q9ERP8DAABWUDggGAAAADABAJ0BKgEAAQADADQlpAADcAD++/1QAA==");
            }

        })(window, document);


        /***/
    }),
    /* 14 */
    /***/
    (function(module, exports) {

        // removed by extract-text-webpack-plugin

        /***/
    }),
    /* 15 */
    /***/
    (function(module, exports, __webpack_require__) {

        "use strict";


        Modernizr.on('cssgrid', function(result) {
            if (!result) {
                document.body.classList.add('no-grid');
            }
        });

        /***/
    }),
    /* 16 */
    /***/
    (function(module, exports, __webpack_require__) {

        "use strict";


        var heroBanner = document.querySelector('.js-hero-banner');

        var height = window.innerHeight * 0.5;

        function setOpacity() {
            var opacity = (height - window.pageYOffset) / height;
            heroBanner.style.opacity = Math.min(1, Math.max(0, opacity));
            window.requestAnimationFrame(setOpacity);
        }

        if (heroBanner) {
            setOpacity();
        }

        /***/
    }),
    /* 17 */
    /***/
    (function(module, exports, __webpack_require__) {

        "use strict";


        var _scrollmonitor = __webpack_require__(18);

        var _scrollmonitor2 = _interopRequireDefault(_scrollmonitor);

        __webpack_require__(19);

        __webpack_require__(20);

        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }

        function _toConsumableArray(arr) {
            if (Array.isArray(arr)) {
                for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
                    arr2[i] = arr[i];
                }
                return arr2;
            } else {
                return Array.from(arr);
            }
        }

        /**
         * Navigation
         */

        var sections = [].concat(_toConsumableArray(document.querySelectorAll('.js-section')));
        var sectionLinks = [].concat(_toConsumableArray(document.querySelectorAll('.js-section-link')));
        var navPointer = document.querySelector('.js-nav-pointer');

        sections.forEach(function(section) {
            // We need the id's to match the sections real id used with anchor tags so
            // as an work around we're targeting the id="comic-section" instead and
            // stripping the '-section' part.
            var id = section.id.replace('-section', '');
            var watcher = _scrollmonitor2.default.create(section, {
                top: -500,
                bottom: -500
            });

            watcher.enterViewport(function() {
                sectionLinks.forEach(function(sectionLink) {
                    sectionLink.classList.remove('is-active');
                });

                sectionLinks.filter(function(sectionLink) {
                    return sectionLink.href.split('#')[1] === id;
                }).forEach(function(sectionLink) {
                    sectionLink.classList.add('is-active');
                    var activeLink = document.querySelector('.js-section-link.is-active');
                    var activeLinkOffset = activeLink.getAttribute('data-pointer-offset');
                    navPointer.style.transform = 'translateY(' + activeLinkOffset + 'px)';
                });
            });
        });

        /*
         * Mobile Nav
         */

        var mobileNavButton = document.querySelector('.js-mobile-nav-button');
        var mobileNavLinks = [].concat(_toConsumableArray(document.querySelectorAll('.js-mobile-nav-link')));
        var mobileNavDrawer = document.querySelector('.js-mobile-nav-drawer');

        function toggleActive() {
            mobileNavDrawer.classList.toggle('is-active');
            mobileNavButton.classList.toggle('is-active');
            document.body.classList.toggle('mobile-nav-active');
        }

        mobileNavButton.addEventListener('click', function() {
            toggleActive();
        });

        mobileNavDrawer.addEventListener('click', function() {
            toggleActive();
        });

        mobileNavLinks.forEach(function(link) {
            link.addEventListener('click', toggleActive);
        });

        /***/
    }),
    /* 18 */
    /***/
    (function(module, exports, __webpack_require__) {

        ! function(t, e) {
            true ? module.exports = e() : "function" == typeof define && define.amd ? define("scrollMonitor", [], e) : "object" == typeof exports ? exports.scrollMonitor = e() : t.scrollMonitor = e()
        }(this, function() {
            return function(t) {
                function e(o) {
                    if (i[o]) return i[o].exports;
                    var s = i[o] = {
                        exports: {},
                        id: o,
                        loaded: !1
                    };
                    return t[o].call(s.exports, s, s.exports, e), s.loaded = !0, s.exports
                }
                var i = {};
                return e.m = t, e.c = i, e.p = "", e(0)
            }([function(t, e, i) {
                "use strict";
                var o = i(1),
                    s = o.isInBrowser,
                    n = i(2),
                    r = new n(s ? document.body : null);
                r.setStateFromDOM(null), r.listenToDOM(), s && (window.scrollMonitor = r), t.exports = r
            }, function(t, e) {
                "use strict";
                e.VISIBILITYCHANGE = "visibilityChange", e.ENTERVIEWPORT = "enterViewport", e.FULLYENTERVIEWPORT = "fullyEnterViewport", e.EXITVIEWPORT = "exitViewport", e.PARTIALLYEXITVIEWPORT = "partiallyExitViewport", e.LOCATIONCHANGE = "locationChange", e.STATECHANGE = "stateChange", e.eventTypes = [e.VISIBILITYCHANGE, e.ENTERVIEWPORT, e.FULLYENTERVIEWPORT, e.EXITVIEWPORT, e.PARTIALLYEXITVIEWPORT, e.LOCATIONCHANGE, e.STATECHANGE], e.isOnServer = "undefined" == typeof window, e.isInBrowser = !e.isOnServer, e.defaultOffsets = {
                    top: 0,
                    bottom: 0
                }
            }, function(t, e, i) {
                "use strict";

                function o(t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }

                function s(t) {
                    return c ? 0 : t === document.body ? window.innerHeight || document.documentElement.clientHeight : t.clientHeight
                }

                function n(t) {
                    return c ? 0 : t === document.body ? Math.max(document.body.scrollHeight, document.documentElement.scrollHeight, document.body.offsetHeight, document.documentElement.offsetHeight, document.documentElement.clientHeight) : t.scrollHeight
                }

                function r(t) {
                    return c ? 0 : t === document.body ? window.pageYOffset || document.documentElement && document.documentElement.scrollTop || document.body.scrollTop : t.scrollTop
                }
                var h = i(1),
                    c = h.isOnServer,
                    a = h.isInBrowser,
                    l = h.eventTypes,
                    p = i(3),
                    u = !1;
                if (a) try {
                    var w = Object.defineProperty({}, "passive", {
                        get: function() {
                            u = !0
                        }
                    });
                    window.addEventListener("test", null, w)
                } catch (t) {}
                var d = !!u && {
                        capture: !1,
                        passive: !0
                    },
                    f = function() {
                        function t(e, i) {
                            function h() {
                                if (a.viewportTop = r(e), a.viewportBottom = a.viewportTop + a.viewportHeight, a.documentHeight = n(e), a.documentHeight !== p) {
                                    for (u = a.watchers.length; u--;) a.watchers[u].recalculateLocation();
                                    p = a.documentHeight
                                }
                            }

                            function c() {
                                for (w = a.watchers.length; w--;) a.watchers[w].update();
                                for (w = a.watchers.length; w--;) a.watchers[w].triggerCallbacks()
                            }
                            o(this, t);
                            var a = this;
                            this.item = e, this.watchers = [], this.viewportTop = null, this.viewportBottom = null, this.documentHeight = n(e), this.viewportHeight = s(e), this.DOMListener = function() {
                                t.prototype.DOMListener.apply(a, arguments)
                            }, this.eventTypes = l, i && (this.containerWatcher = i.create(e));
                            var p, u, w;
                            this.update = function() {
                                h(), c()
                            }, this.recalculateLocations = function() {
                                this.documentHeight = 0, this.update()
                            }
                        }
                        return t.prototype.listenToDOM = function() {
                            a && (window.addEventListener ? (this.item === document.body ? window.addEventListener("scroll", this.DOMListener, d) : this.item.addEventListener("scroll", this.DOMListener, d), window.addEventListener("resize", this.DOMListener)) : (this.item === document.body ? window.attachEvent("onscroll", this.DOMListener) : this.item.attachEvent("onscroll", this.DOMListener), window.attachEvent("onresize", this.DOMListener)), this.destroy = function() {
                                window.addEventListener ? (this.item === document.body ? (window.removeEventListener("scroll", this.DOMListener, d), this.containerWatcher.destroy()) : this.item.removeEventListener("scroll", this.DOMListener, d), window.removeEventListener("resize", this.DOMListener)) : (this.item === document.body ? (window.detachEvent("onscroll", this.DOMListener), this.containerWatcher.destroy()) : this.item.detachEvent("onscroll", this.DOMListener), window.detachEvent("onresize", this.DOMListener))
                            })
                        }, t.prototype.destroy = function() {}, t.prototype.DOMListener = function(t) {
                            this.setStateFromDOM(t)
                        }, t.prototype.setStateFromDOM = function(t) {
                            var e = r(this.item),
                                i = s(this.item),
                                o = n(this.item);
                            this.setState(e, i, o, t)
                        }, t.prototype.setState = function(t, e, i, o) {
                            var s = e !== this.viewportHeight || i !== this.contentHeight;
                            if (this.latestEvent = o, this.viewportTop = t, this.viewportHeight = e, this.viewportBottom = t + e, this.contentHeight = i, s)
                                for (var n = this.watchers.length; n--;) this.watchers[n].recalculateLocation();
                            this.updateAndTriggerWatchers(o)
                        }, t.prototype.updateAndTriggerWatchers = function(t) {
                            for (var e = this.watchers.length; e--;) this.watchers[e].update();
                            for (e = this.watchers.length; e--;) this.watchers[e].triggerCallbacks(t)
                        }, t.prototype.createCustomContainer = function() {
                            return new t
                        }, t.prototype.createContainer = function(e) {
                            "string" == typeof e ? e = document.querySelector(e) : e && e.length > 0 && (e = e[0]);
                            var i = new t(e, this);
                            return i.setStateFromDOM(), i.listenToDOM(), i
                        }, t.prototype.create = function(t, e) {
                            "string" == typeof t ? t = document.querySelector(t) : t && t.length > 0 && (t = t[0]);
                            var i = new p(this, t, e);
                            return this.watchers.push(i), i
                        }, t.prototype.beget = function(t, e) {
                            return this.create(t, e)
                        }, t
                    }();
                t.exports = f
            }, function(t, e, i) {
                "use strict";

                function o(t, e, i) {
                    function o(t, e) {
                        if (0 !== t.length)
                            for (E = t.length; E--;) y = t[E], y.callback.call(s, e, s), y.isOne && t.splice(E, 1)
                    }
                    var s = this;
                    this.watchItem = e, this.container = t, i ? i === +i ? this.offsets = {
                        top: i,
                        bottom: i
                    } : this.offsets = {
                        top: i.top || w.top,
                        bottom: i.bottom || w.bottom
                    } : this.offsets = w, this.callbacks = {};
                    for (var d = 0, f = u.length; d < f; d++) s.callbacks[u[d]] = [];
                    this.locked = !1;
                    var m, v, b, I, E, y;
                    this.triggerCallbacks = function(t) {
                        switch (this.isInViewport && !m && o(this.callbacks[r], t), this.isFullyInViewport && !v && o(this.callbacks[h], t), this.isAboveViewport !== b && this.isBelowViewport !== I && (o(this.callbacks[n], t), v || this.isFullyInViewport || (o(this.callbacks[h], t), o(this.callbacks[a], t)), m || this.isInViewport || (o(this.callbacks[r], t), o(this.callbacks[c], t))), !this.isFullyInViewport && v && o(this.callbacks[a], t), !this.isInViewport && m && o(this.callbacks[c], t), this.isInViewport !== m && o(this.callbacks[n], t), !0) {
                            case m !== this.isInViewport:
                            case v !== this.isFullyInViewport:
                            case b !== this.isAboveViewport:
                            case I !== this.isBelowViewport:
                                o(this.callbacks[p], t)
                        }
                        m = this.isInViewport, v = this.isFullyInViewport, b = this.isAboveViewport, I = this.isBelowViewport
                    }, this.recalculateLocation = function() {
                        if (!this.locked) {
                            var t = this.top,
                                e = this.bottom;
                            if (this.watchItem.nodeName) {
                                var i = this.watchItem.style.display;
                                "none" === i && (this.watchItem.style.display = "");
                                for (var s = 0, n = this.container; n.containerWatcher;) s += n.containerWatcher.top - n.containerWatcher.container.viewportTop, n = n.containerWatcher.container;
                                var r = this.watchItem.getBoundingClientRect();
                                this.top = r.top + this.container.viewportTop - s, this.bottom = r.bottom + this.container.viewportTop - s, "none" === i && (this.watchItem.style.display = i)
                            } else this.watchItem === +this.watchItem ? this.watchItem > 0 ? this.top = this.bottom = this.watchItem : this.top = this.bottom = this.container.documentHeight - this.watchItem : (this.top = this.watchItem.top, this.bottom = this.watchItem.bottom);
                            this.top -= this.offsets.top, this.bottom += this.offsets.bottom, this.height = this.bottom - this.top, void 0 === t && void 0 === e || this.top === t && this.bottom === e || o(this.callbacks[l], null)
                        }
                    }, this.recalculateLocation(), this.update(), m = this.isInViewport, v = this.isFullyInViewport, b = this.isAboveViewport, I = this.isBelowViewport
                }
                var s = i(1),
                    n = s.VISIBILITYCHANGE,
                    r = s.ENTERVIEWPORT,
                    h = s.FULLYENTERVIEWPORT,
                    c = s.EXITVIEWPORT,
                    a = s.PARTIALLYEXITVIEWPORT,
                    l = s.LOCATIONCHANGE,
                    p = s.STATECHANGE,
                    u = s.eventTypes,
                    w = s.defaultOffsets;
                o.prototype = {
                    on: function(t, e, i) {
                        switch (!0) {
                            case t === n && !this.isInViewport && this.isAboveViewport:
                            case t === r && this.isInViewport:
                            case t === h && this.isFullyInViewport:
                            case t === c && this.isAboveViewport && !this.isInViewport:
                            case t === a && this.isInViewport && this.isAboveViewport:
                                if (e.call(this, this.container.latestEvent, this), i) return
                        }
                        if (!this.callbacks[t]) throw new Error("Tried to add a scroll monitor listener of type " + t + ". Your options are: " + u.join(", "));
                        this.callbacks[t].push({
                            callback: e,
                            isOne: i || !1
                        })
                    },
                    off: function(t, e) {
                        if (!this.callbacks[t]) throw new Error("Tried to remove a scroll monitor listener of type " + t + ". Your options are: " + u.join(", "));
                        for (var i, o = 0; i = this.callbacks[t][o]; o++)
                            if (i.callback === e) {
                                this.callbacks[t].splice(o, 1);
                                break
                            }
                    },
                    one: function(t, e) {
                        this.on(t, e, !0)
                    },
                    recalculateSize: function() {
                        this.height = this.watchItem.offsetHeight + this.offsets.top + this.offsets.bottom, this.bottom = this.top + this.height
                    },
                    update: function() {
                        this.isAboveViewport = this.top < this.container.viewportTop, this.isBelowViewport = this.bottom > this.container.viewportBottom, this.isInViewport = this.top < this.container.viewportBottom && this.bottom > this.container.viewportTop, this.isFullyInViewport = this.top >= this.container.viewportTop && this.bottom <= this.container.viewportBottom || this.isAboveViewport && this.isBelowViewport
                    },
                    destroy: function() {
                        var t = this.container.watchers.indexOf(this),
                            e = this;
                        this.container.watchers.splice(t, 1);
                        for (var i = 0, o = u.length; i < o; i++) e.callbacks[u[i]].length = 0
                    },
                    lock: function() {
                        this.locked = !0
                    },
                    unlock: function() {
                        this.locked = !1
                    }
                };
                for (var d = function(t) {
                        return function(e, i) {
                            this.on.call(this, t, e, i)
                        }
                    }, f = 0, m = u.length; f < m; f++) {
                    var v = u[f];
                    o.prototype[v] = d(v)
                }
                t.exports = o
            }])
        });
        //# sourceMappingURL=scrollMonitor.js.map

        /***/
    }),
    /* 19 */
    /***/
    (function(module, exports, __webpack_require__) {

        "use strict";


        /**
         * Array.from Polyfill for IE10
         */

        // Production steps of ECMA-262, Edition 6, 22.1.2.1
        if (!Array.from) {
            Array.from = function() {
                var toStr = Object.prototype.toString;
                var isCallable = function isCallable(fn) {
                    return typeof fn === 'function' || toStr.call(fn) === '[object Function]';
                };
                var toInteger = function toInteger(value) {
                    var number = Number(value);
                    if (isNaN(number)) {
                        return 0;
                    }
                    if (number === 0 || !isFinite(number)) {
                        return number;
                    }
                    return (number > 0 ? 1 : -1) * Math.floor(Math.abs(number));
                };
                var maxSafeInteger = Math.pow(2, 53) - 1;
                var toLength = function toLength(value) {
                    var len = toInteger(value);
                    return Math.min(Math.max(len, 0), maxSafeInteger);
                };

                // The length property of the from method is 1.
                return function from(arrayLike /* , mapFn, thisArg */ ) {
                    // 1. Let C be the this value.
                    var C = this;

                    // 2. Let items be ToObject(arrayLike).
                    var items = Object(arrayLike);

                    // 3. ReturnIfAbrupt(items).
                    if (arrayLike == null) {
                        throw new TypeError('Array.from requires an array-like object - not null or undefined');
                    }

                    // 4. If mapfn is undefined, then let mapping be false.
                    var mapFn = arguments.length > 1 ? arguments[1] : void undefined;
                    var T = void 0;
                    if (typeof mapFn !== 'undefined') {
                        // 5. else
                        // 5. a If IsCallable(mapfn) is false, throw a TypeError exception.
                        if (!isCallable(mapFn)) {
                            throw new TypeError('Array.from: when provided, the second argument must be a function');
                        }

                        // 5. b. If thisArg was supplied, let T be thisArg; else let T be undefined.
                        if (arguments.length > 2) {
                            T = arguments[2];
                        }
                    }

                    // 10. Let lenValue be Get(items, "length").
                    // 11. Let len be ToLength(lenValue).
                    var len = toLength(items.length);

                    // 13. If IsConstructor(C) is true, then
                    // 13. a. Let A be the result of calling the [[Construct]] internal method
                    // of C with an argument list containing the single item len.
                    // 14. a. Else, Let A be ArrayCreate(len).
                    var A = isCallable(C) ? Object(new C(len)) : new Array(len);

                    // 16. Let k be 0.
                    var k = 0;
                    // 17. Repeat, while k < len… (also steps a - h)
                    var kValue = void 0;
                    while (k < len) {
                        kValue = items[k];
                        if (mapFn) {
                            A[k] = typeof T === 'undefined' ? mapFn(kValue, k) : mapFn.call(T, kValue, k);
                        } else {
                            A[k] = kValue;
                        }
                        k += 1;
                    }
                    // 18. Let putStatus be Put(A, "length", len, true).
                    A.length = len;
                    // 20. Return A.
                    return A;
                };
            }();
        }

        /***/
    }),
    /* 20 */
    /***/
    (function(module, exports, __webpack_require__) {

        "use strict";


        /**
         * ForEach for looping through nodeLists
         */
        function forEach(array, callback, scope) {
            for (var i = 0; i < array.length; i++) {
                callback.call(scope, i, array[i]); // passes back stuff we need
            }
        }

        /***/
    }),
    /* 21 */
    /***/
    (function(module, exports, __webpack_require__) {

        "use strict";
        /* WEBPACK VAR INJECTION */
        (function($) {

            /**
             * smooth scrolling
             */

            $(function() {
                $('a[href*="#"]:not([href="#"])').click(function() {
                    if (location.pathname.replace(/^\//, '') == this.pathname.replace(/^\//, '') && location.hostname == this.hostname) {
                        var target = $(this.hash);
                        target = target.length ? target : $('[name=' + this.hash.slice(1) + ']');
                        if (target.length && this.hash !== '#intro') {
                            $('html, body').animate({
                                scrollTop: target.offset().top - 40
                            }, 1000);
                            return false;
                        }
                        $('html, body').animate({
                            scrollTop: 0
                        }, 1000);
                        return false;
                    }
                });
            });
            /* WEBPACK VAR INJECTION */
        }.call(exports, __webpack_require__(2)))

        /***/
    }),
    /* 22 */
    /***/
    (function(module, exports, __webpack_require__) {

        "use strict";


        var _flickity = __webpack_require__(23);

        var _flickity2 = _interopRequireDefault(_flickity);

        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }

        function _toConsumableArray(arr) {
            if (Array.isArray(arr)) {
                for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
                    arr2[i] = arr[i];
                }
                return arr2;
            } else {
                return Array.from(arr);
            }
        }
        /**
         * Wallpaper Carousel
         */


        var skinsCarousel = document.querySelector('.js-skins-carousel');
        var skinsCarouselTriggers = [].concat(_toConsumableArray(document.querySelectorAll('.js-skins-carousel-trigger'))).map(function(node) {
            return {
                node: node,
                index: Number(node.getAttribute('data-slide')) - 1
            };
        });

        var flkty = new _flickity2.default(skinsCarousel, {
            lazyLoad: true,
            prevNextButtons: false,
            pageDots: false,
            wrapAround: true,
            draggable: false
        });

        function setCurrentSlide(index) {
            flkty.select(index);
        }

        skinsCarouselTriggers.forEach(function(trigger) {
            trigger.node.addEventListener('click', function() {
                setCurrentSlide(trigger.index);
            });
        });

        flkty.on('select', function() {
            skinsCarouselTriggers.forEach(function(trigger) {
                if (trigger.index === flkty.selectedIndex) {
                    trigger.node.classList.add('is-active');
                } else {
                    trigger.node.classList.remove('is-active');
                }
            });
        });

        /***/
    }),
    /* 23 */
    /***/
    (function(module, exports, __webpack_require__) {

        var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;
        /*!
         * Flickity v2.0.10
         * Touch, responsive, flickable carousels
         *
         * Licensed GPLv3 for open source use
         * or Flickity Commercial License for commercial use
         *
         * http://flickity.metafizzy.co
         * Copyright 2017 Metafizzy
         */

        (function(window, factory) {
            // universal module definition
            /* jshint strict: false */
            if (true) {
                // AMD
                !(__WEBPACK_AMD_DEFINE_ARRAY__ = [
                        __webpack_require__(1),
                        __webpack_require__(28),
                        __webpack_require__(30),
                        __webpack_require__(31),
                        __webpack_require__(32),
                        __webpack_require__(33),
                        __webpack_require__(34)
                    ], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
                    __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
                        (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
                    __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
            } else if (typeof module == 'object' && module.exports) {
                // CommonJS
                module.exports = factory(
                    require('./flickity'),
                    require('./drag'),
                    require('./prev-next-button'),
                    require('./page-dots'),
                    require('./player'),
                    require('./add-remove-cell'),
                    require('./lazyload')
                );
            }

        })(window, function factory(Flickity) {
            /*jshint strict: false*/
            return Flickity;
        });


        /***/
    }),
    /* 24 */
    /***/
    (function(module, exports, __webpack_require__) {

        var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;
        /**
         * matchesSelector v2.0.2
         * matchesSelector( element, '.selector' )
         * MIT license
         */

        /*jshint browser: true, strict: true, undef: true, unused: true */

        (function(window, factory) {
            /*global define: false, module: false */
            'use strict';
            // universal module definition
            if (true) {
                // AMD
                !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
                    __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
                        (__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :
                        __WEBPACK_AMD_DEFINE_FACTORY__),
                    __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
            } else if (typeof module == 'object' && module.exports) {
                // CommonJS
                module.exports = factory();
            } else {
                // browser global
                window.matchesSelector = factory();
            }

        }(window, function factory() {
            'use strict';

            var matchesMethod = (function() {
                var ElemProto = window.Element.prototype;
                // check for the standard method name first
                if (ElemProto.matches) {
                    return 'matches';
                }
                // check un-prefixed
                if (ElemProto.matchesSelector) {
                    return 'matchesSelector';
                }
                // check vendor prefixes
                var prefixes = ['webkit', 'moz', 'ms', 'o'];

                for (var i = 0; i < prefixes.length; i++) {
                    var prefix = prefixes[i];
                    var method = prefix + 'MatchesSelector';
                    if (ElemProto[method]) {
                        return method;
                    }
                }
            })();

            return function matchesSelector(elem, selector) {
                return elem[matchesMethod](selector);
            };

        }));


        /***/
    }),
    /* 25 */
    /***/
    (function(module, exports, __webpack_require__) {

        var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__; // Flickity.Cell
        (function(window, factory) {
            // universal module definition
            /* jshint strict: false */
            if (true) {
                // AMD
                !(__WEBPACK_AMD_DEFINE_ARRAY__ = [
                        __webpack_require__(5)
                    ], __WEBPACK_AMD_DEFINE_RESULT__ = function(getSize) {
                        return factory(window, getSize);
                    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
                    __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
            } else if (typeof module == 'object' && module.exports) {
                // CommonJS
                module.exports = factory(
                    window,
                    require('get-size')
                );
            } else {
                // browser global
                window.Flickity = window.Flickity || {};
                window.Flickity.Cell = factory(
                    window,
                    window.getSize
                );
            }

        }(window, function factory(window, getSize) {

            'use strict';

            function Cell(elem, parent) {
                this.element = elem;
                this.parent = parent;

                this.create();
            }

            var proto = Cell.prototype;

            proto.create = function() {
                this.element.style.position = 'absolute';
                this.x = 0;
                this.shift = 0;
            };

            proto.destroy = function() {
                // reset style
                this.element.style.position = '';
                var side = this.parent.originSide;
                this.element.style[side] = '';
            };

            proto.getSize = function() {
                this.size = getSize(this.element);
            };

            proto.setPosition = function(x) {
                this.x = x;
                this.updateTarget();
                this.renderPosition(x);
            };

            // setDefaultTarget v1 method, backwards compatibility, remove in v3
            proto.updateTarget = proto.setDefaultTarget = function() {
                var marginProperty = this.parent.originSide == 'left' ? 'marginLeft' : 'marginRight';
                this.target = this.x + this.size[marginProperty] +
                    this.size.width * this.parent.cellAlign;
            };

            proto.renderPosition = function(x) {
                // render position of cell with in slider
                var side = this.parent.originSide;
                this.element.style[side] = this.parent.getPositionValue(x);
            };

            /**
             * @param {Integer} factor - 0, 1, or -1
             **/
            proto.wrapShift = function(shift) {
                this.shift = shift;
                this.renderPosition(this.x + this.parent.slideableWidth * shift);
            };

            proto.remove = function() {
                this.element.parentNode.removeChild(this.element);
            };

            return Cell;

        }));


        /***/
    }),
    /* 26 */
    /***/
    (function(module, exports, __webpack_require__) {

        var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__; // slide
        (function(window, factory) {
            // universal module definition
            /* jshint strict: false */
            if (true) {
                // AMD
                !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
                    __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
                        (__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :
                        __WEBPACK_AMD_DEFINE_FACTORY__),
                    __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
            } else if (typeof module == 'object' && module.exports) {
                // CommonJS
                module.exports = factory();
            } else {
                // browser global
                window.Flickity = window.Flickity || {};
                window.Flickity.Slide = factory();
            }

        }(window, function factory() {
            'use strict';

            function Slide(parent) {
                this.parent = parent;
                this.isOriginLeft = parent.originSide == 'left';
                this.cells = [];
                this.outerWidth = 0;
                this.height = 0;
            }

            var proto = Slide.prototype;

            proto.addCell = function(cell) {
                this.cells.push(cell);
                this.outerWidth += cell.size.outerWidth;
                this.height = Math.max(cell.size.outerHeight, this.height);
                // first cell stuff
                if (this.cells.length == 1) {
                    this.x = cell.x; // x comes from first cell
                    var beginMargin = this.isOriginLeft ? 'marginLeft' : 'marginRight';
                    this.firstMargin = cell.size[beginMargin];
                }
            };

            proto.updateTarget = function() {
                var endMargin = this.isOriginLeft ? 'marginRight' : 'marginLeft';
                var lastCell = this.getLastCell();
                var lastMargin = lastCell ? lastCell.size[endMargin] : 0;
                var slideWidth = this.outerWidth - (this.firstMargin + lastMargin);
                this.target = this.x + this.firstMargin + slideWidth * this.parent.cellAlign;
            };

            proto.getLastCell = function() {
                return this.cells[this.cells.length - 1];
            };

            proto.select = function() {
                this.changeSelectedClass('add');
            };

            proto.unselect = function() {
                this.changeSelectedClass('remove');
            };

            proto.changeSelectedClass = function(method) {
                this.cells.forEach(function(cell) {
                    cell.element.classList[method]('is-selected');
                });
            };

            proto.getCellElements = function() {
                return this.cells.map(function(cell) {
                    return cell.element;
                });
            };

            return Slide;

        }));


        /***/
    }),
    /* 27 */
    /***/
    (function(module, exports, __webpack_require__) {

        var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__; // animate
        (function(window, factory) {
            // universal module definition
            /* jshint strict: false */
            if (true) {
                // AMD
                !(__WEBPACK_AMD_DEFINE_ARRAY__ = [
                        __webpack_require__(0)
                    ], __WEBPACK_AMD_DEFINE_RESULT__ = function(utils) {
                        return factory(window, utils);
                    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
                    __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
            } else if (typeof module == 'object' && module.exports) {
                // CommonJS
                module.exports = factory(
                    window,
                    require('fizzy-ui-utils')
                );
            } else {
                // browser global
                window.Flickity = window.Flickity || {};
                window.Flickity.animatePrototype = factory(
                    window,
                    window.fizzyUIUtils
                );
            }

        }(window, function factory(window, utils) {

            'use strict';

            // -------------------------- requestAnimationFrame -------------------------- //

            // get rAF, prefixed, if present
            var requestAnimationFrame = window.requestAnimationFrame ||
                window.webkitRequestAnimationFrame;

            // fallback to setTimeout
            var lastTime = 0;
            if (!requestAnimationFrame) {
                requestAnimationFrame = function(callback) {
                    var currTime = new Date().getTime();
                    var timeToCall = Math.max(0, 16 - (currTime - lastTime));
                    var id = setTimeout(callback, timeToCall);
                    lastTime = currTime + timeToCall;
                    return id;
                };
            }

            // -------------------------- animate -------------------------- //

            var proto = {};

            proto.startAnimation = function() {
                if (this.isAnimating) {
                    return;
                }

                this.isAnimating = true;
                this.restingFrames = 0;
                this.animate();
            };

            proto.animate = function() {
                this.applyDragForce();
                this.applySelectedAttraction();

                var previousX = this.x;

                this.integratePhysics();
                this.positionSlider();
                this.settle(previousX);
                // animate next frame
                if (this.isAnimating) {
                    var _this = this;
                    requestAnimationFrame(function animateFrame() {
                        _this.animate();
                    });
                }
            };


            var transformProperty = (function() {
                var style = document.documentElement.style;
                if (typeof style.transform == 'string') {
                    return 'transform';
                }
                return 'WebkitTransform';
            })();

            proto.positionSlider = function() {
                var x = this.x;
                // wrap position around
                if (this.options.wrapAround && this.cells.length > 1) {
                    x = utils.modulo(x, this.slideableWidth);
                    x = x - this.slideableWidth;
                    this.shiftWrapCells(x);
                }

                x = x + this.cursorPosition;
                // reverse if right-to-left and using transform
                x = this.options.rightToLeft && transformProperty ? -x : x;
                var value = this.getPositionValue(x);
                // use 3D tranforms for hardware acceleration on iOS
                // but use 2D when settled, for better font-rendering
                this.slider.style[transformProperty] = this.isAnimating ?
                    'translate3d(' + value + ',0,0)' : 'translateX(' + value + ')';

                // scroll event
                var firstSlide = this.slides[0];
                if (firstSlide) {
                    var positionX = -this.x - firstSlide.target;
                    var progress = positionX / this.slidesWidth;
                    this.dispatchEvent('scroll', null, [progress, positionX]);
                }
            };

            proto.positionSliderAtSelected = function() {
                if (!this.cells.length) {
                    return;
                }
                this.x = -this.selectedSlide.target;
                this.positionSlider();
            };

            proto.getPositionValue = function(position) {
                if (this.options.percentPosition) {
                    // percent position, round to 2 digits, like 12.34%
                    return (Math.round((position / this.size.innerWidth) * 10000) * 0.01) + '%';
                } else {
                    // pixel positioning
                    return Math.round(position) + 'px';
                }
            };

            proto.settle = function(previousX) {
                // keep track of frames where x hasn't moved
                if (!this.isPointerDown && Math.round(this.x * 100) == Math.round(previousX * 100)) {
                    this.restingFrames++;
                }
                // stop animating if resting for 3 or more frames
                if (this.restingFrames > 2) {
                    this.isAnimating = false;
                    delete this.isFreeScrolling;
                    // render position with translateX when settled
                    this.positionSlider();
                    this.dispatchEvent('settle');
                }
            };

            proto.shiftWrapCells = function(x) {
                // shift before cells
                var beforeGap = this.cursorPosition + x;
                this._shiftCells(this.beforeShiftCells, beforeGap, -1);
                // shift after cells
                var afterGap = this.size.innerWidth - (x + this.slideableWidth + this.cursorPosition);
                this._shiftCells(this.afterShiftCells, afterGap, 1);
            };

            proto._shiftCells = function(cells, gap, shift) {
                for (var i = 0; i < cells.length; i++) {
                    var cell = cells[i];
                    var cellShift = gap > 0 ? shift : 0;
                    cell.wrapShift(cellShift);
                    gap -= cell.size.outerWidth;
                }
            };

            proto._unshiftCells = function(cells) {
                if (!cells || !cells.length) {
                    return;
                }
                for (var i = 0; i < cells.length; i++) {
                    cells[i].wrapShift(0);
                }
            };

            // -------------------------- physics -------------------------- //

            proto.integratePhysics = function() {
                this.x += this.velocity;
                this.velocity *= this.getFrictionFactor();
            };

            proto.applyForce = function(force) {
                this.velocity += force;
            };

            proto.getFrictionFactor = function() {
                return 1 - this.options[this.isFreeScrolling ? 'freeScrollFriction' : 'friction'];
            };

            proto.getRestingPosition = function() {
                // my thanks to Steven Wittens, who simplified this math greatly
                return this.x + this.velocity / (1 - this.getFrictionFactor());
            };

            proto.applyDragForce = function() {
                if (!this.isPointerDown) {
                    return;
                }
                // change the position to drag position by applying force
                var dragVelocity = this.dragX - this.x;
                var dragForce = dragVelocity - this.velocity;
                this.applyForce(dragForce);
            };

            proto.applySelectedAttraction = function() {
                // do not attract if pointer down or no cells
                if (this.isPointerDown || this.isFreeScrolling || !this.cells.length) {
                    return;
                }
                var distance = this.selectedSlide.target * -1 - this.x;
                var force = distance * this.options.selectedAttraction;
                this.applyForce(force);
            };

            return proto;

        }));


        /***/
    }),
    /* 28 */
    /***/
    (function(module, exports, __webpack_require__) {

        var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__; // drag
        (function(window, factory) {
            // universal module definition
            /* jshint strict: false */
            if (true) {
                // AMD
                !(__WEBPACK_AMD_DEFINE_ARRAY__ = [
                        __webpack_require__(1),
                        __webpack_require__(29),
                        __webpack_require__(0)
                    ], __WEBPACK_AMD_DEFINE_RESULT__ = function(Flickity, Unidragger, utils) {
                        return factory(window, Flickity, Unidragger, utils);
                    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
                    __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
            } else if (typeof module == 'object' && module.exports) {
                // CommonJS
                module.exports = factory(
                    window,
                    require('./flickity'),
                    require('unidragger'),
                    require('fizzy-ui-utils')
                );
            } else {
                // browser global
                window.Flickity = factory(
                    window,
                    window.Flickity,
                    window.Unidragger,
                    window.fizzyUIUtils
                );
            }

        }(window, function factory(window, Flickity, Unidragger, utils) {

            'use strict';

            // ----- defaults ----- //

            utils.extend(Flickity.defaults, {
                draggable: true,
                dragThreshold: 3,
            });

            // ----- create ----- //

            Flickity.createMethods.push('_createDrag');

            // -------------------------- drag prototype -------------------------- //

            var proto = Flickity.prototype;
            utils.extend(proto, Unidragger.prototype);
            proto._touchActionValue = 'pan-y';

            // --------------------------  -------------------------- //

            var isTouch = 'createTouch' in document;
            var isTouchmoveScrollCanceled = false;

            proto._createDrag = function() {
                this.on('activate', this.bindDrag);
                this.on('uiChange', this._uiChangeDrag);
                this.on('childUIPointerDown', this._childUIPointerDownDrag);
                this.on('deactivate', this.unbindDrag);
                // HACK - add seemingly innocuous handler to fix iOS 10 scroll behavior
                // #457, RubaXa/Sortable#973
                if (isTouch && !isTouchmoveScrollCanceled) {
                    window.addEventListener('touchmove', function() {});
                    isTouchmoveScrollCanceled = true;
                }
            };

            proto.bindDrag = function() {
                if (!this.options.draggable || this.isDragBound) {
                    return;
                }
                this.element.classList.add('is-draggable');
                this.handles = [this.viewport];
                this.bindHandles();
                this.isDragBound = true;
            };

            proto.unbindDrag = function() {
                if (!this.isDragBound) {
                    return;
                }
                this.element.classList.remove('is-draggable');
                this.unbindHandles();
                delete this.isDragBound;
            };

            proto._uiChangeDrag = function() {
                delete this.isFreeScrolling;
            };

            proto._childUIPointerDownDrag = function(event) {
                event.preventDefault();
                this.pointerDownFocus(event);
            };

            // -------------------------- pointer events -------------------------- //

            // nodes that have text fields
            var cursorNodes = {
                TEXTAREA: true,
                INPUT: true,
                OPTION: true,
            };

            // input types that do not have text fields
            var clickTypes = {
                radio: true,
                checkbox: true,
                button: true,
                submit: true,
                image: true,
                file: true,
            };

            proto.pointerDown = function(event, pointer) {
                // dismiss inputs with text fields. #403, #404
                var isCursorInput = cursorNodes[event.target.nodeName] &&
                    !clickTypes[event.target.type];
                if (isCursorInput) {
                    // reset pointerDown logic
                    this.isPointerDown = false;
                    delete this.pointerIdentifier;
                    return;
                }

                this._dragPointerDown(event, pointer);

                // kludge to blur focused inputs in dragger
                var focused = document.activeElement;
                if (focused && focused.blur && focused != this.element &&
                    // do not blur body for IE9 & 10, #117
                    focused != document.body) {
                    focused.blur();
                }
                this.pointerDownFocus(event);
                // stop if it was moving
                this.dragX = this.x;
                this.viewport.classList.add('is-pointer-down');
                // bind move and end events
                this._bindPostStartEvents(event);
                // track scrolling
                this.pointerDownScroll = getScrollPosition();
                window.addEventListener('scroll', this);

                this.dispatchEvent('pointerDown', event, [pointer]);
            };

            proto.pointerDownFocus = function(event) {
                // focus element, if not touch, and its not an input or select
                var canPointerDown = getCanPointerDown(event);
                if (!this.options.accessibility || canPointerDown) {
                    return;
                }
                var prevScrollY = window.pageYOffset;
                this.element.focus();
                // hack to fix scroll jump after focus, #76
                if (window.pageYOffset != prevScrollY) {
                    window.scrollTo(window.pageXOffset, prevScrollY);
                }
            };

            var focusNodes = {
                INPUT: true,
                SELECT: true,
            };

            function getCanPointerDown(event) {
                var isTouchStart = event.type == 'touchstart';
                var isTouchPointer = event.pointerType == 'touch';
                var isFocusNode = focusNodes[event.target.nodeName];
                return isTouchStart || isTouchPointer || isFocusNode;
            }

            proto.canPreventDefaultOnPointerDown = function(event) {
                // prevent default, unless touchstart or input
                var canPointerDown = getCanPointerDown(event);
                return !canPointerDown;
            };

            // ----- move ----- //

            proto.hasDragStarted = function(moveVector) {
                return Math.abs(moveVector.x) > this.options.dragThreshold;
            };

            // ----- up ----- //

            proto.pointerUp = function(event, pointer) {
                delete this.isTouchScrolling;
                this.viewport.classList.remove('is-pointer-down');
                this.dispatchEvent('pointerUp', event, [pointer]);
                this._dragPointerUp(event, pointer);
            };

            proto.pointerDone = function() {
                window.removeEventListener('scroll', this);
                delete this.pointerDownScroll;
            };

            // -------------------------- dragging -------------------------- //

            proto.dragStart = function(event, pointer) {
                this.dragStartPosition = this.x;
                this.startAnimation();
                window.removeEventListener('scroll', this);
                this.dispatchEvent('dragStart', event, [pointer]);
            };

            proto.pointerMove = function(event, pointer) {
                var moveVector = this._dragPointerMove(event, pointer);
                this.dispatchEvent('pointerMove', event, [pointer, moveVector]);
                this._dragMove(event, pointer, moveVector);
            };

            proto.dragMove = function(event, pointer, moveVector) {
                event.preventDefault();

                this.previousDragX = this.dragX;
                // reverse if right-to-left
                var direction = this.options.rightToLeft ? -1 : 1;
                var dragX = this.dragStartPosition + moveVector.x * direction;

                if (!this.options.wrapAround && this.slides.length) {
                    // slow drag
                    var originBound = Math.max(-this.slides[0].target, this.dragStartPosition);
                    dragX = dragX > originBound ? (dragX + originBound) * 0.5 : dragX;
                    var endBound = Math.min(-this.getLastSlide().target, this.dragStartPosition);
                    dragX = dragX < endBound ? (dragX + endBound) * 0.5 : dragX;
                }

                this.dragX = dragX;

                this.dragMoveTime = new Date();
                this.dispatchEvent('dragMove', event, [pointer, moveVector]);
            };

            proto.dragEnd = function(event, pointer) {
                if (this.options.freeScroll) {
                    this.isFreeScrolling = true;
                }
                // set selectedIndex based on where flick will end up
                var index = this.dragEndRestingSelect();

                if (this.options.freeScroll && !this.options.wrapAround) {
                    // if free-scroll & not wrap around
                    // do not free-scroll if going outside of bounding slides
                    // so bounding slides can attract slider, and keep it in bounds
                    var restingX = this.getRestingPosition();
                    this.isFreeScrolling = -restingX > this.slides[0].target &&
                        -restingX < this.getLastSlide().target;
                } else if (!this.options.freeScroll && index == this.selectedIndex) {
                    // boost selection if selected index has not changed
                    index += this.dragEndBoostSelect();
                }
                delete this.previousDragX;
                // apply selection
                // TODO refactor this, selecting here feels weird
                // HACK, set flag so dragging stays in correct direction
                this.isDragSelect = this.options.wrapAround;
                this.select(index);
                delete this.isDragSelect;
                this.dispatchEvent('dragEnd', event, [pointer]);
            };

            proto.dragEndRestingSelect = function() {
                var restingX = this.getRestingPosition();
                // how far away from selected slide
                var distance = Math.abs(this.getSlideDistance(-restingX, this.selectedIndex));
                // get closet resting going up and going down
                var positiveResting = this._getClosestResting(restingX, distance, 1);
                var negativeResting = this._getClosestResting(restingX, distance, -1);
                // use closer resting for wrap-around
                var index = positiveResting.distance < negativeResting.distance ?
                    positiveResting.index : negativeResting.index;
                return index;
            };

            /**
             * given resting X and distance to selected cell
             * get the distance and index of the closest cell
             * @param {Number} restingX - estimated post-flick resting position
             * @param {Number} distance - distance to selected cell
             * @param {Integer} increment - +1 or -1, going up or down
             * @returns {Object} - { distance: {Number}, index: {Integer} }
             */
            proto._getClosestResting = function(restingX, distance, increment) {
                var index = this.selectedIndex;
                var minDistance = Infinity;
                var condition = this.options.contain && !this.options.wrapAround ?
                    // if contain, keep going if distance is equal to minDistance
                    function(d, md) {
                        return d <= md;
                    } : function(d, md) {
                        return d < md;
                    };
                while (condition(distance, minDistance)) {
                    // measure distance to next cell
                    index += increment;
                    minDistance = distance;
                    distance = this.getSlideDistance(-restingX, index);
                    if (distance === null) {
                        break;
                    }
                    distance = Math.abs(distance);
                }
                return {
                    distance: minDistance,
                    // selected was previous index
                    index: index - increment
                };
            };

            /**
             * measure distance between x and a slide target
             * @param {Number} x
             * @param {Integer} index - slide index
             */
            proto.getSlideDistance = function(x, index) {
                var len = this.slides.length;
                // wrap around if at least 2 slides
                var isWrapAround = this.options.wrapAround && len > 1;
                var slideIndex = isWrapAround ? utils.modulo(index, len) : index;
                var slide = this.slides[slideIndex];
                if (!slide) {
                    return null;
                }
                // add distance for wrap-around slides
                var wrap = isWrapAround ? this.slideableWidth * Math.floor(index / len) : 0;
                return x - (slide.target + wrap);
            };

            proto.dragEndBoostSelect = function() {
                // do not boost if no previousDragX or dragMoveTime
                if (this.previousDragX === undefined || !this.dragMoveTime ||
                    // or if drag was held for 100 ms
                    new Date() - this.dragMoveTime > 100) {
                    return 0;
                }

                var distance = this.getSlideDistance(-this.dragX, this.selectedIndex);
                var delta = this.previousDragX - this.dragX;
                if (distance > 0 && delta > 0) {
                    // boost to next if moving towards the right, and positive velocity
                    return 1;
                } else if (distance < 0 && delta < 0) {
                    // boost to previous if moving towards the left, and negative velocity
                    return -1;
                }
                return 0;
            };

            // ----- staticClick ----- //

            proto.staticClick = function(event, pointer) {
                // get clickedCell, if cell was clicked
                var clickedCell = this.getParentCell(event.target);
                var cellElem = clickedCell && clickedCell.element;
                var cellIndex = clickedCell && this.cells.indexOf(clickedCell);
                this.dispatchEvent('staticClick', event, [pointer, cellElem, cellIndex]);
            };

            // ----- scroll ----- //

            proto.onscroll = function() {
                var scroll = getScrollPosition();
                var scrollMoveX = this.pointerDownScroll.x - scroll.x;
                var scrollMoveY = this.pointerDownScroll.y - scroll.y;
                // cancel click/tap if scroll is too much
                if (Math.abs(scrollMoveX) > 3 || Math.abs(scrollMoveY) > 3) {
                    this._pointerDone();
                }
            };

            // ----- utils ----- //

            function getScrollPosition() {
                return {
                    x: window.pageXOffset,
                    y: window.pageYOffset
                };
            }

            // -----  ----- //

            return Flickity;

        }));


        /***/
    }),
    /* 29 */
    /***/
    (function(module, exports, __webpack_require__) {

        var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;
        /*!
         * Unidragger v2.2.3
         * Draggable base class
         * MIT license
         */

        /*jshint browser: true, unused: true, undef: true, strict: true */

        (function(window, factory) {
            // universal module definition
            /*jshint strict: false */
            /*globals define, module, require */

            if (true) {
                // AMD
                !(__WEBPACK_AMD_DEFINE_ARRAY__ = [
                        __webpack_require__(6)
                    ], __WEBPACK_AMD_DEFINE_RESULT__ = function(Unipointer) {
                        return factory(window, Unipointer);
                    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
                    __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
            } else if (typeof module == 'object' && module.exports) {
                // CommonJS
                module.exports = factory(
                    window,
                    require('unipointer')
                );
            } else {
                // browser global
                window.Unidragger = factory(
                    window,
                    window.Unipointer
                );
            }

        }(window, function factory(window, Unipointer) {

            'use strict';

            // -------------------------- Unidragger -------------------------- //

            function Unidragger() {}

            // inherit Unipointer & EvEmitter
            var proto = Unidragger.prototype = Object.create(Unipointer.prototype);

            // ----- bind start ----- //

            proto.bindHandles = function() {
                this._bindHandles(true);
            };

            proto.unbindHandles = function() {
                this._bindHandles(false);
            };

            /**
             * works as unbinder, as you can .bindHandles( false ) to unbind
             * @param {Boolean} isBind - will unbind if falsey
             */
            proto._bindHandles = function(isBind) {
                // munge isBind, default to true
                isBind = isBind === undefined ? true : !!isBind;
                // bind each handle
                var bindMethod = isBind ? 'addEventListener' : 'removeEventListener';
                for (var i = 0; i < this.handles.length; i++) {
                    var handle = this.handles[i];
                    this._bindStartEvent(handle, isBind);
                    handle[bindMethod]('click', this);
                    // touch-action: none to override browser touch gestures
                    // metafizzy/flickity#540
                    if (window.PointerEvent) {
                        handle.style.touchAction = isBind ? this._touchActionValue : '';
                    }
                }
            };

            // prototype so it can be overwriteable by Flickity
            proto._touchActionValue = 'none';

            // ----- start event ----- //

            /**
             * pointer start
             * @param {Event} event
             * @param {Event or Touch} pointer
             */
            proto.pointerDown = function(event, pointer) {
                // dismiss range sliders
                if (event.target.nodeName == 'INPUT' && event.target.type == 'range') {
                    // reset pointerDown logic
                    this.isPointerDown = false;
                    delete this.pointerIdentifier;
                    return;
                }

                this._dragPointerDown(event, pointer);
                // kludge to blur focused inputs in dragger
                var focused = document.activeElement;
                if (focused && focused.blur) {
                    focused.blur();
                }
                // bind move and end events
                this._bindPostStartEvents(event);
                this.emitEvent('pointerDown', [event, pointer]);
            };

            // base pointer down logic
            proto._dragPointerDown = function(event, pointer) {
                // track to see when dragging starts
                this.pointerDownPoint = Unipointer.getPointerPoint(pointer);

                var canPreventDefault = this.canPreventDefaultOnPointerDown(event, pointer);
                if (canPreventDefault) {
                    event.preventDefault();
                }
            };

            // overwriteable method so Flickity can prevent for scrolling
            proto.canPreventDefaultOnPointerDown = function(event) {
                // prevent default, unless touchstart or <select>
                return event.target.nodeName != 'SELECT';
            };

            // ----- move event ----- //

            /**
             * drag move
             * @param {Event} event
             * @param {Event or Touch} pointer
             */
            proto.pointerMove = function(event, pointer) {
                var moveVector = this._dragPointerMove(event, pointer);
                this.emitEvent('pointerMove', [event, pointer, moveVector]);
                this._dragMove(event, pointer, moveVector);
            };

            // base pointer move logic
            proto._dragPointerMove = function(event, pointer) {
                var movePoint = Unipointer.getPointerPoint(pointer);
                var moveVector = {
                    x: movePoint.x - this.pointerDownPoint.x,
                    y: movePoint.y - this.pointerDownPoint.y
                };
                // start drag if pointer has moved far enough to start drag
                if (!this.isDragging && this.hasDragStarted(moveVector)) {
                    this._dragStart(event, pointer);
                }
                return moveVector;
            };

            // condition if pointer has moved far enough to start drag
            proto.hasDragStarted = function(moveVector) {
                return Math.abs(moveVector.x) > 3 || Math.abs(moveVector.y) > 3;
            };


            // ----- end event ----- //

            /**
             * pointer up
             * @param {Event} event
             * @param {Event or Touch} pointer
             */
            proto.pointerUp = function(event, pointer) {
                this.emitEvent('pointerUp', [event, pointer]);
                this._dragPointerUp(event, pointer);
            };

            proto._dragPointerUp = function(event, pointer) {
                if (this.isDragging) {
                    this._dragEnd(event, pointer);
                } else {
                    // pointer didn't move enough for drag to start
                    this._staticClick(event, pointer);
                }
            };

            // -------------------------- drag -------------------------- //

            // dragStart
            proto._dragStart = function(event, pointer) {
                this.isDragging = true;
                this.dragStartPoint = Unipointer.getPointerPoint(pointer);
                // prevent clicks
                this.isPreventingClicks = true;

                this.dragStart(event, pointer);
            };

            proto.dragStart = function(event, pointer) {
                this.emitEvent('dragStart', [event, pointer]);
            };

            // dragMove
            proto._dragMove = function(event, pointer, moveVector) {
                // do not drag if not dragging yet
                if (!this.isDragging) {
                    return;
                }

                this.dragMove(event, pointer, moveVector);
            };

            proto.dragMove = function(event, pointer, moveVector) {
                event.preventDefault();
                this.emitEvent('dragMove', [event, pointer, moveVector]);
            };

            // dragEnd
            proto._dragEnd = function(event, pointer) {
                // set flags
                this.isDragging = false;
                // re-enable clicking async
                setTimeout(function() {
                    delete this.isPreventingClicks;
                }.bind(this));

                this.dragEnd(event, pointer);
            };

            proto.dragEnd = function(event, pointer) {
                this.emitEvent('dragEnd', [event, pointer]);
            };

            // ----- onclick ----- //

            // handle all clicks and prevent clicks when dragging
            proto.onclick = function(event) {
                if (this.isPreventingClicks) {
                    event.preventDefault();
                }
            };

            // ----- staticClick ----- //

            // triggered after pointer down & up with no/tiny movement
            proto._staticClick = function(event, pointer) {
                // ignore emulated mouse up clicks
                if (this.isIgnoringMouseUp && event.type == 'mouseup') {
                    return;
                }

                // allow click in <input>s and <textarea>s
                var nodeName = event.target.nodeName;
                if (nodeName == 'INPUT' || nodeName == 'TEXTAREA') {
                    event.target.focus();
                }
                this.staticClick(event, pointer);

                // set flag for emulated clicks 300ms after touchend
                if (event.type != 'mouseup') {
                    this.isIgnoringMouseUp = true;
                    // reset flag after 300ms
                    setTimeout(function() {
                        delete this.isIgnoringMouseUp;
                    }.bind(this), 400);
                }
            };

            proto.staticClick = function(event, pointer) {
                this.emitEvent('staticClick', [event, pointer]);
            };

            // ----- utils ----- //

            Unidragger.getPointerPoint = Unipointer.getPointerPoint;

            // -----  ----- //

            return Unidragger;

        }));


        /***/
    }),
    /* 30 */
    /***/
    (function(module, exports, __webpack_require__) {

        var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__; // prev/next buttons
        (function(window, factory) {
            // universal module definition
            /* jshint strict: false */
            if (true) {
                // AMD
                !(__WEBPACK_AMD_DEFINE_ARRAY__ = [
                        __webpack_require__(1),
                        __webpack_require__(7),
                        __webpack_require__(0)
                    ], __WEBPACK_AMD_DEFINE_RESULT__ = function(Flickity, TapListener, utils) {
                        return factory(window, Flickity, TapListener, utils);
                    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
                    __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
            } else if (typeof module == 'object' && module.exports) {
                // CommonJS
                module.exports = factory(
                    window,
                    require('./flickity'),
                    require('tap-listener'),
                    require('fizzy-ui-utils')
                );
            } else {
                // browser global
                factory(
                    window,
                    window.Flickity,
                    window.TapListener,
                    window.fizzyUIUtils
                );
            }

        }(window, function factory(window, Flickity, TapListener, utils) {
            'use strict';

            var svgURI = 'http://www.w3.org/2000/svg';

            // -------------------------- PrevNextButton -------------------------- //

            function PrevNextButton(direction, parent) {
                this.direction = direction;
                this.parent = parent;
                this._create();
            }

            PrevNextButton.prototype = new TapListener();

            PrevNextButton.prototype._create = function() {
                // properties
                this.isEnabled = true;
                this.isPrevious = this.direction == -1;
                var leftDirection = this.parent.options.rightToLeft ? 1 : -1;
                this.isLeft = this.direction == leftDirection;

                var element = this.element = document.createElement('button');
                element.className = 'flickity-prev-next-button';
                element.className += this.isPrevious ? ' previous' : ' next';
                // prevent button from submitting form http://stackoverflow.com/a/10836076/182183
                element.setAttribute('type', 'button');
                // init as disabled
                this.disable();

                element.setAttribute('aria-label', this.isPrevious ? 'previous' : 'next');

                // create arrow
                var svg = this.createSVG();
                element.appendChild(svg);
                // events
                this.on('tap', this.onTap);
                this.parent.on('select', this.update.bind(this));
                this.on('pointerDown', this.parent.childUIPointerDown.bind(this.parent));
            };

            PrevNextButton.prototype.activate = function() {
                this.bindTap(this.element);
                // click events from keyboard
                this.element.addEventListener('click', this);
                // add to DOM
                this.parent.element.appendChild(this.element);
            };

            PrevNextButton.prototype.deactivate = function() {
                // remove from DOM
                this.parent.element.removeChild(this.element);
                // do regular TapListener destroy
                TapListener.prototype.destroy.call(this);
                // click events from keyboard
                this.element.removeEventListener('click', this);
            };

            PrevNextButton.prototype.createSVG = function() {
                var svg = document.createElementNS(svgURI, 'svg');
                svg.setAttribute('viewBox', '0 0 100 100');
                var path = document.createElementNS(svgURI, 'path');
                var pathMovements = getArrowMovements(this.parent.options.arrowShape);
                path.setAttribute('d', pathMovements);
                path.setAttribute('class', 'arrow');
                // rotate arrow
                if (!this.isLeft) {
                    path.setAttribute('transform', 'translate(100, 100) rotate(180) ');
                }
                svg.appendChild(path);
                return svg;
            };

            // get SVG path movmement
            function getArrowMovements(shape) {
                // use shape as movement if string
                if (typeof shape == 'string') {
                    return shape;
                }
                // create movement string
                return 'M ' + shape.x0 + ',50' +
                    ' L ' + shape.x1 + ',' + (shape.y1 + 50) +
                    ' L ' + shape.x2 + ',' + (shape.y2 + 50) +
                    ' L ' + shape.x3 + ',50 ' +
                    ' L ' + shape.x2 + ',' + (50 - shape.y2) +
                    ' L ' + shape.x1 + ',' + (50 - shape.y1) +
                    ' Z';
            }

            PrevNextButton.prototype.onTap = function() {
                if (!this.isEnabled) {
                    return;
                }
                this.parent.uiChange();
                var method = this.isPrevious ? 'previous' : 'next';
                this.parent[method]();
            };

            PrevNextButton.prototype.handleEvent = utils.handleEvent;

            PrevNextButton.prototype.onclick = function() {
                // only allow clicks from keyboard
                var focused = document.activeElement;
                if (focused && focused == this.element) {
                    this.onTap();
                }
            };

            // -----  ----- //

            PrevNextButton.prototype.enable = function() {
                if (this.isEnabled) {
                    return;
                }
                this.element.disabled = false;
                this.isEnabled = true;
            };

            PrevNextButton.prototype.disable = function() {
                if (!this.isEnabled) {
                    return;
                }
                this.element.disabled = true;
                this.isEnabled = false;
            };

            PrevNextButton.prototype.update = function() {
                // index of first or last slide, if previous or next
                var slides = this.parent.slides;
                // enable is wrapAround and at least 2 slides
                if (this.parent.options.wrapAround && slides.length > 1) {
                    this.enable();
                    return;
                }
                var lastIndex = slides.length ? slides.length - 1 : 0;
                var boundIndex = this.isPrevious ? 0 : lastIndex;
                var method = this.parent.selectedIndex == boundIndex ? 'disable' : 'enable';
                this[method]();
            };

            PrevNextButton.prototype.destroy = function() {
                this.deactivate();
            };

            // -------------------------- Flickity prototype -------------------------- //

            utils.extend(Flickity.defaults, {
                prevNextButtons: true,
                arrowShape: {
                    x0: 10,
                    x1: 60,
                    y1: 50,
                    x2: 70,
                    y2: 40,
                    x3: 30
                }
            });

            Flickity.createMethods.push('_createPrevNextButtons');
            var proto = Flickity.prototype;

            proto._createPrevNextButtons = function() {
                if (!this.options.prevNextButtons) {
                    return;
                }

                this.prevButton = new PrevNextButton(-1, this);
                this.nextButton = new PrevNextButton(1, this);

                this.on('activate', this.activatePrevNextButtons);
            };

            proto.activatePrevNextButtons = function() {
                this.prevButton.activate();
                this.nextButton.activate();
                this.on('deactivate', this.deactivatePrevNextButtons);
            };

            proto.deactivatePrevNextButtons = function() {
                this.prevButton.deactivate();
                this.nextButton.deactivate();
                this.off('deactivate', this.deactivatePrevNextButtons);
            };

            // --------------------------  -------------------------- //

            Flickity.PrevNextButton = PrevNextButton;

            return Flickity;

        }));


        /***/
    }),
    /* 31 */
    /***/
    (function(module, exports, __webpack_require__) {

        var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__; // page dots
        (function(window, factory) {
            // universal module definition
            /* jshint strict: false */
            if (true) {
                // AMD
                !(__WEBPACK_AMD_DEFINE_ARRAY__ = [
                        __webpack_require__(1),
                        __webpack_require__(7),
                        __webpack_require__(0)
                    ], __WEBPACK_AMD_DEFINE_RESULT__ = function(Flickity, TapListener, utils) {
                        return factory(window, Flickity, TapListener, utils);
                    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
                    __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
            } else if (typeof module == 'object' && module.exports) {
                // CommonJS
                module.exports = factory(
                    window,
                    require('./flickity'),
                    require('tap-listener'),
                    require('fizzy-ui-utils')
                );
            } else {
                // browser global
                factory(
                    window,
                    window.Flickity,
                    window.TapListener,
                    window.fizzyUIUtils
                );
            }

        }(window, function factory(window, Flickity, TapListener, utils) {

            // -------------------------- PageDots -------------------------- //

            'use strict';

            function PageDots(parent) {
                this.parent = parent;
                this._create();
            }

            PageDots.prototype = new TapListener();

            PageDots.prototype._create = function() {
                // create holder element
                this.holder = document.createElement('ol');
                this.holder.className = 'flickity-page-dots';
                // create dots, array of elements
                this.dots = [];
                // events
                this.on('tap', this.onTap);
                this.on('pointerDown', this.parent.childUIPointerDown.bind(this.parent));
            };

            PageDots.prototype.activate = function() {
                this.setDots();
                this.bindTap(this.holder);
                // add to DOM
                this.parent.element.appendChild(this.holder);
            };

            PageDots.prototype.deactivate = function() {
                // remove from DOM
                this.parent.element.removeChild(this.holder);
                TapListener.prototype.destroy.call(this);
            };

            PageDots.prototype.setDots = function() {
                // get difference between number of slides and number of dots
                var delta = this.parent.slides.length - this.dots.length;
                if (delta > 0) {
                    this.addDots(delta);
                } else if (delta < 0) {
                    this.removeDots(-delta);
                }
            };

            PageDots.prototype.addDots = function(count) {
                var fragment = document.createDocumentFragment();
                var newDots = [];
                while (count) {
                    var dot = document.createElement('li');
                    dot.className = 'dot';
                    fragment.appendChild(dot);
                    newDots.push(dot);
                    count--;
                }
                this.holder.appendChild(fragment);
                this.dots = this.dots.concat(newDots);
            };

            PageDots.prototype.removeDots = function(count) {
                // remove from this.dots collection
                var removeDots = this.dots.splice(this.dots.length - count, count);
                // remove from DOM
                removeDots.forEach(function(dot) {
                    this.holder.removeChild(dot);
                }, this);
            };

            PageDots.prototype.updateSelected = function() {
                // remove selected class on previous
                if (this.selectedDot) {
                    this.selectedDot.className = 'dot';
                }
                // don't proceed if no dots
                if (!this.dots.length) {
                    return;
                }
                this.selectedDot = this.dots[this.parent.selectedIndex];
                this.selectedDot.className = 'dot is-selected';
            };

            PageDots.prototype.onTap = function(event) {
                var target = event.target;
                // only care about dot clicks
                if (target.nodeName != 'LI') {
                    return;
                }

                this.parent.uiChange();
                var index = this.dots.indexOf(target);
                this.parent.select(index);
            };

            PageDots.prototype.destroy = function() {
                this.deactivate();
            };

            Flickity.PageDots = PageDots;

            // -------------------------- Flickity -------------------------- //

            utils.extend(Flickity.defaults, {
                pageDots: true
            });

            Flickity.createMethods.push('_createPageDots');

            var proto = Flickity.prototype;

            proto._createPageDots = function() {
                if (!this.options.pageDots) {
                    return;
                }
                this.pageDots = new PageDots(this);
                // events
                this.on('activate', this.activatePageDots);
                this.on('select', this.updateSelectedPageDots);
                this.on('cellChange', this.updatePageDots);
                this.on('resize', this.updatePageDots);
                this.on('deactivate', this.deactivatePageDots);
            };

            proto.activatePageDots = function() {
                this.pageDots.activate();
            };

            proto.updateSelectedPageDots = function() {
                this.pageDots.updateSelected();
            };

            proto.updatePageDots = function() {
                this.pageDots.setDots();
            };

            proto.deactivatePageDots = function() {
                this.pageDots.deactivate();
            };

            // -----  ----- //

            Flickity.PageDots = PageDots;

            return Flickity;

        }));


        /***/
    }),
    /* 32 */
    /***/
    (function(module, exports, __webpack_require__) {

        var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__; // player & autoPlay
        (function(window, factory) {
            // universal module definition
            /* jshint strict: false */
            if (true) {
                // AMD
                !(__WEBPACK_AMD_DEFINE_ARRAY__ = [
                        __webpack_require__(4),
                        __webpack_require__(0),
                        __webpack_require__(1)
                    ], __WEBPACK_AMD_DEFINE_RESULT__ = function(EvEmitter, utils, Flickity) {
                        return factory(EvEmitter, utils, Flickity);
                    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
                    __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
            } else if (typeof module == 'object' && module.exports) {
                // CommonJS
                module.exports = factory(
                    require('ev-emitter'),
                    require('fizzy-ui-utils'),
                    require('./flickity')
                );
            } else {
                // browser global
                factory(
                    window.EvEmitter,
                    window.fizzyUIUtils,
                    window.Flickity
                );
            }

        }(window, function factory(EvEmitter, utils, Flickity) {

            'use strict';

            // -------------------------- Page Visibility -------------------------- //
            // https://developer.mozilla.org/en-US/docs/Web/Guide/User_experience/Using_the_Page_Visibility_API

            var hiddenProperty, visibilityEvent;
            if ('hidden' in document) {
                hiddenProperty = 'hidden';
                visibilityEvent = 'visibilitychange';
            } else if ('webkitHidden' in document) {
                hiddenProperty = 'webkitHidden';
                visibilityEvent = 'webkitvisibilitychange';
            }

            // -------------------------- Player -------------------------- //

            function Player(parent) {
                this.parent = parent;
                this.state = 'stopped';
                // visibility change event handler
                if (visibilityEvent) {
                    this.onVisibilityChange = function() {
                        this.visibilityChange();
                    }.bind(this);
                    this.onVisibilityPlay = function() {
                        this.visibilityPlay();
                    }.bind(this);
                }
            }

            Player.prototype = Object.create(EvEmitter.prototype);

            // start play
            Player.prototype.play = function() {
                if (this.state == 'playing') {
                    return;
                }
                // do not play if page is hidden, start playing when page is visible
                var isPageHidden = document[hiddenProperty];
                if (visibilityEvent && isPageHidden) {
                    document.addEventListener(visibilityEvent, this.onVisibilityPlay);
                    return;
                }

                this.state = 'playing';
                // listen to visibility change
                if (visibilityEvent) {
                    document.addEventListener(visibilityEvent, this.onVisibilityChange);
                }
                // start ticking
                this.tick();
            };

            Player.prototype.tick = function() {
                // do not tick if not playing
                if (this.state != 'playing') {
                    return;
                }

                var time = this.parent.options.autoPlay;
                // default to 3 seconds
                time = typeof time == 'number' ? time : 3000;
                var _this = this;
                // HACK: reset ticks if stopped and started within interval
                this.clear();
                this.timeout = setTimeout(function() {
                    _this.parent.next(true);
                    _this.tick();
                }, time);
            };

            Player.prototype.stop = function() {
                this.state = 'stopped';
                this.clear();
                // remove visibility change event
                if (visibilityEvent) {
                    document.removeEventListener(visibilityEvent, this.onVisibilityChange);
                }
            };

            Player.prototype.clear = function() {
                clearTimeout(this.timeout);
            };

            Player.prototype.pause = function() {
                if (this.state == 'playing') {
                    this.state = 'paused';
                    this.clear();
                }
            };

            Player.prototype.unpause = function() {
                // re-start play if paused
                if (this.state == 'paused') {
                    this.play();
                }
            };

            // pause if page visibility is hidden, unpause if visible
            Player.prototype.visibilityChange = function() {
                var isPageHidden = document[hiddenProperty];
                this[isPageHidden ? 'pause' : 'unpause']();
            };

            Player.prototype.visibilityPlay = function() {
                this.play();
                document.removeEventListener(visibilityEvent, this.onVisibilityPlay);
            };

            // -------------------------- Flickity -------------------------- //

            utils.extend(Flickity.defaults, {
                pauseAutoPlayOnHover: true
            });

            Flickity.createMethods.push('_createPlayer');
            var proto = Flickity.prototype;

            proto._createPlayer = function() {
                this.player = new Player(this);

                this.on('activate', this.activatePlayer);
                this.on('uiChange', this.stopPlayer);
                this.on('pointerDown', this.stopPlayer);
                this.on('deactivate', this.deactivatePlayer);
            };

            proto.activatePlayer = function() {
                if (!this.options.autoPlay) {
                    return;
                }
                this.player.play();
                this.element.addEventListener('mouseenter', this);
            };

            // Player API, don't hate the ... thanks I know where the door is

            proto.playPlayer = function() {
                this.player.play();
            };

            proto.stopPlayer = function() {
                this.player.stop();
            };

            proto.pausePlayer = function() {
                this.player.pause();
            };

            proto.unpausePlayer = function() {
                this.player.unpause();
            };

            proto.deactivatePlayer = function() {
                this.player.stop();
                this.element.removeEventListener('mouseenter', this);
            };

            // ----- mouseenter/leave ----- //

            // pause auto-play on hover
            proto.onmouseenter = function() {
                if (!this.options.pauseAutoPlayOnHover) {
                    return;
                }
                this.player.pause();
                this.element.addEventListener('mouseleave', this);
            };

            // resume auto-play on hover off
            proto.onmouseleave = function() {
                this.player.unpause();
                this.element.removeEventListener('mouseleave', this);
            };

            // -----  ----- //

            Flickity.Player = Player;

            return Flickity;

        }));


        /***/
    }),
    /* 33 */
    /***/
    (function(module, exports, __webpack_require__) {

        var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__; // add, remove cell
        (function(window, factory) {
            // universal module definition
            /* jshint strict: false */
            if (true) {
                // AMD
                !(__WEBPACK_AMD_DEFINE_ARRAY__ = [
                        __webpack_require__(1),
                        __webpack_require__(0)
                    ], __WEBPACK_AMD_DEFINE_RESULT__ = function(Flickity, utils) {
                        return factory(window, Flickity, utils);
                    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
                    __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
            } else if (typeof module == 'object' && module.exports) {
                // CommonJS
                module.exports = factory(
                    window,
                    require('./flickity'),
                    require('fizzy-ui-utils')
                );
            } else {
                // browser global
                factory(
                    window,
                    window.Flickity,
                    window.fizzyUIUtils
                );
            }

        }(window, function factory(window, Flickity, utils) {

            'use strict';

            // append cells to a document fragment
            function getCellsFragment(cells) {
                var fragment = document.createDocumentFragment();
                cells.forEach(function(cell) {
                    fragment.appendChild(cell.element);
                });
                return fragment;
            }

            // -------------------------- add/remove cell prototype -------------------------- //

            var proto = Flickity.prototype;

            /**
             * Insert, prepend, or append cells
             * @param {Element, Array, NodeList} elems
             * @param {Integer} index
             */
            proto.insert = function(elems, index) {
                var cells = this._makeCells(elems);
                if (!cells || !cells.length) {
                    return;
                }
                var len = this.cells.length;
                // default to append
                index = index === undefined ? len : index;
                // add cells with document fragment
                var fragment = getCellsFragment(cells);
                // append to slider
                var isAppend = index == len;
                if (isAppend) {
                    this.slider.appendChild(fragment);
                } else {
                    var insertCellElement = this.cells[index].element;
                    this.slider.insertBefore(fragment, insertCellElement);
                }
                // add to this.cells
                if (index === 0) {
                    // prepend, add to start
                    this.cells = cells.concat(this.cells);
                } else if (isAppend) {
                    // append, add to end
                    this.cells = this.cells.concat(cells);
                } else {
                    // insert in this.cells
                    var endCells = this.cells.splice(index, len - index);
                    this.cells = this.cells.concat(cells).concat(endCells);
                }

                this._sizeCells(cells);

                var selectedIndexDelta = index > this.selectedIndex ? 0 : cells.length;
                this._cellAddedRemoved(index, selectedIndexDelta);
            };

            proto.append = function(elems) {
                this.insert(elems, this.cells.length);
            };

            proto.prepend = function(elems) {
                this.insert(elems, 0);
            };

            /**
             * Remove cells
             * @param {Element, Array, NodeList} elems
             */
            proto.remove = function(elems) {
                var cells = this.getCells(elems);
                var selectedIndexDelta = 0;
                var len = cells.length;
                var i, cell;
                // calculate selectedIndexDelta, easier if done in seperate loop
                for (i = 0; i < len; i++) {
                    cell = cells[i];
                    var wasBefore = this.cells.indexOf(cell) < this.selectedIndex;
                    selectedIndexDelta -= wasBefore ? 1 : 0;
                }

                for (i = 0; i < len; i++) {
                    cell = cells[i];
                    cell.remove();
                    // remove item from collection
                    utils.removeFrom(this.cells, cell);
                }

                if (cells.length) {
                    // update stuff
                    this._cellAddedRemoved(0, selectedIndexDelta);
                }
            };

            // updates when cells are added or removed
            proto._cellAddedRemoved = function(changedCellIndex, selectedIndexDelta) {
                // TODO this math isn't perfect with grouped slides
                selectedIndexDelta = selectedIndexDelta || 0;
                this.selectedIndex += selectedIndexDelta;
                this.selectedIndex = Math.max(0, Math.min(this.slides.length - 1, this.selectedIndex));

                this.cellChange(changedCellIndex, true);
                // backwards compatibility
                this.emitEvent('cellAddedRemoved', [changedCellIndex, selectedIndexDelta]);
            };

            /**
             * logic to be run after a cell's size changes
             * @param {Element} elem - cell's element
             */
            proto.cellSizeChange = function(elem) {
                var cell = this.getCell(elem);
                if (!cell) {
                    return;
                }
                cell.getSize();

                var index = this.cells.indexOf(cell);
                this.cellChange(index);
            };

            /**
             * logic any time a cell is changed: added, removed, or size changed
             * @param {Integer} changedCellIndex - index of the changed cell, optional
             */
            proto.cellChange = function(changedCellIndex, isPositioningSlider) {
                var prevSlideableWidth = this.slideableWidth;
                this._positionCells(changedCellIndex);
                this._getWrapShiftCells();
                this.setGallerySize();
                this.emitEvent('cellChange', [changedCellIndex]);
                // position slider
                if (this.options.freeScroll) {
                    // shift x by change in slideableWidth
                    // TODO fix position shifts when prepending w/ freeScroll
                    var deltaX = prevSlideableWidth - this.slideableWidth;
                    this.x += deltaX * this.cellAlign;
                    this.positionSlider();
                } else {
                    // do not position slider after lazy load
                    if (isPositioningSlider) {
                        this.positionSliderAtSelected();
                    }
                    this.select(this.selectedIndex);
                }
            };

            // -----  ----- //

            return Flickity;

        }));


        /***/
    }),
    /* 34 */
    /***/
    (function(module, exports, __webpack_require__) {

        var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__; // lazyload
        (function(window, factory) {
            // universal module definition
            /* jshint strict: false */
            if (true) {
                // AMD
                !(__WEBPACK_AMD_DEFINE_ARRAY__ = [
                        __webpack_require__(1),
                        __webpack_require__(0)
                    ], __WEBPACK_AMD_DEFINE_RESULT__ = function(Flickity, utils) {
                        return factory(window, Flickity, utils);
                    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
                    __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
            } else if (typeof module == 'object' && module.exports) {
                // CommonJS
                module.exports = factory(
                    window,
                    require('./flickity'),
                    require('fizzy-ui-utils')
                );
            } else {
                // browser global
                factory(
                    window,
                    window.Flickity,
                    window.fizzyUIUtils
                );
            }

        }(window, function factory(window, Flickity, utils) {
            'use strict';

            Flickity.createMethods.push('_createLazyload');
            var proto = Flickity.prototype;

            proto._createLazyload = function() {
                this.on('select', this.lazyLoad);
            };

            proto.lazyLoad = function() {
                var lazyLoad = this.options.lazyLoad;
                if (!lazyLoad) {
                    return;
                }
                // get adjacent cells, use lazyLoad option for adjacent count
                var adjCount = typeof lazyLoad == 'number' ? lazyLoad : 0;
                var cellElems = this.getAdjacentCellElements(adjCount);
                // get lazy images in those cells
                var lazyImages = [];
                cellElems.forEach(function(cellElem) {
                    var lazyCellImages = getCellLazyImages(cellElem);
                    lazyImages = lazyImages.concat(lazyCellImages);
                });
                // load lazy images
                lazyImages.forEach(function(img) {
                    new LazyLoader(img, this);
                }, this);
            };

            function getCellLazyImages(cellElem) {
                // check if cell element is lazy image
                if (cellElem.nodeName == 'IMG' &&
                    cellElem.getAttribute('data-flickity-lazyload')) {
                    return [cellElem];
                }
                // select lazy images in cell
                var imgs = cellElem.querySelectorAll('img[data-flickity-lazyload]');
                return utils.makeArray(imgs);
            }

            // -------------------------- LazyLoader -------------------------- //

            /**
             * class to handle loading images
             */
            function LazyLoader(img, flickity) {
                this.img = img;
                this.flickity = flickity;
                this.load();
            }

            LazyLoader.prototype.handleEvent = utils.handleEvent;

            LazyLoader.prototype.load = function() {
                this.img.addEventListener('load', this);
                this.img.addEventListener('error', this);
                // load image
                this.img.src = this.img.getAttribute('data-flickity-lazyload');
                // remove attr
                this.img.removeAttribute('data-flickity-lazyload');
            };

            LazyLoader.prototype.onload = function(event) {
                this.complete(event, 'flickity-lazyloaded');
            };

            LazyLoader.prototype.onerror = function(event) {
                this.complete(event, 'flickity-lazyerror');
            };

            LazyLoader.prototype.complete = function(event, className) {
                // unbind events
                this.img.removeEventListener('load', this);
                this.img.removeEventListener('error', this);

                var cell = this.flickity.getParentCell(this.img);
                var cellElem = cell && cell.element;
                this.flickity.cellSizeChange(cellElem);

                this.img.classList.add(className);
                this.flickity.dispatchEvent('lazyLoad', event, cellElem);
            };

            // -----  ----- //

            Flickity.LazyLoader = LazyLoader;

            return Flickity;

        }));


        /***/
    }),
    /* 35 */
    /***/
    (function(module, exports, __webpack_require__) {

        "use strict";


        var _fancybox = __webpack_require__(8);

        var _fancybox2 = _interopRequireDefault(_fancybox);

        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }

        /***/
    }),
    /* 36 */
    /***/
    (function(module, exports, __webpack_require__) {

        "use strict";
        /* WEBPACK VAR INJECTION */
        (function($) {

            var _fancybox = __webpack_require__(8);

            var _fancybox2 = _interopRequireDefault(_fancybox);

            function _interopRequireDefault(obj) {
                return obj && obj.__esModule ? obj : {
                    default: obj
                };
            }

            $('[data-teaser]').fancybox({
                toolbar: false,
                smallBtn: true,
                youtube: {
                    controls: 0,
                    showinfo: 0,
                    autoplay: 1
                }
                // baseTpl:
                //     '<div class="fancybox-container fancybox-teaser" role="dialog" tabindex="-1">' +
                //         '<div class="fancybox-bg"></div>' +
                //         '<div class="fancybox-inner">' +
                //             '<div class="fancybox-stage">' +
                //             '</div>' +
                //         '</div>' +
                //     '</div>',
            });
            /* WEBPACK VAR INJECTION */
        }.call(exports, __webpack_require__(2)))

        /***/
    }),
    /* 37 */
    /***/
    (function(module, exports, __webpack_require__) {

        "use strict";


        var FallbackCustomScheme = __webpack_require__(38);

        var fcs = new FallbackCustomScheme({
            urlScheme: '' + window.i18n.displaysUrlApp, // your application custom scheme
            fallback: '' + window.i18n.displaysUrlRedirect // if not installed the applicaiton, handling (ex. app store, google play store etc)
                // browserback: 'back',
        });

        var displaysBtn = document.querySelector('.js-displays-btn');

        displaysBtn.addEventListener('click', function(e) {
            e.preventDefault();
            fcs.launch();
        });

        /***/
    }),
    /* 38 */
    /***/
    (function(module, exports, __webpack_require__) {

        (function(global, factory) {
            true ? module.exports = factory() :
                typeof define === 'function' && define.amd ? define(factory) :
                (global.FallbackCustomScheme = factory());
        }(this, (function() {
            'use strict';

            var classCallCheck = function(instance, Constructor) {
                if (!(instance instanceof Constructor)) {
                    throw new TypeError("Cannot call a class as a function");
                }
            };

            var createClass = function() {
                function defineProperties(target, props) {
                    for (var i = 0; i < props.length; i++) {
                        var descriptor = props[i];
                        descriptor.enumerable = descriptor.enumerable || false;
                        descriptor.configurable = true;
                        if ("value" in descriptor) descriptor.writable = true;
                        Object.defineProperty(target, descriptor.key, descriptor);
                    }
                }

                return function(Constructor, protoProps, staticProps) {
                    if (protoProps) defineProperties(Constructor.prototype, protoProps);
                    if (staticProps) defineProperties(Constructor, staticProps);
                    return Constructor;
                };
            }();

            var inherits = function(subClass, superClass) {
                if (typeof superClass !== "function" && superClass !== null) {
                    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
                }

                subClass.prototype = Object.create(superClass && superClass.prototype, {
                    constructor: {
                        value: subClass,
                        enumerable: false,
                        writable: true,
                        configurable: true
                    }
                });
                if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
            };

            var possibleConstructorReturn = function(self, call) {
                if (!self) {
                    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                }

                return call && (typeof call === "object" || typeof call === "function") ? call : self;
            };

            var RE_IS_IPHONE = /(iPhone\sOS)\s([\d_]+)/;
            var RE_IS_IPAD = /(iPad).*OS\s([\d_]+)/;
            var RE_IS_IPOD_TOUCH = /(iPod touch).*OS\s([\d_]+)/;
            var RE_IS_ANDROID = /(Android)\s+([\d.]+)/;
            var RE_IS_WIN = /Windows/;
            var RE_IS_MAC = /Mac OS/;

            var UserAgent = function UserAgent() {
                classCallCheck(this, UserAgent);
                this.isIOS = null;
                this.isAndroid = null;
                this.isWin = null;
                this.isMac = null;
                this.isPC = null;
                this.osVer = null;

                var ua = navigator.userAgent;
                this.isIOS = !!ua.match(RE_IS_IPHONE) || ua.match(RE_IS_IPAD) || ua.match(RE_IS_IPOD_TOUCH);
                this.isAndroid = !!ua.match(RE_IS_ANDROID);
                this.isWin = !!ua.match(RE_IS_WIN);
                this.isMac = !!ua.match(RE_IS_MAC);
                this.isPC = !!(this.isWin || this.isMac);
                if (this.isIOS || this.isAndroid) {
                    var ver = ua.match(/(OS|Android) ([0-9_\.]+){1,3}/);
                    ver = ver && ver[2].replace(/_/g, '.');
                    this.osVer = ver && Number(ver[0]);
                } else {
                    this.osVer = null;
                }
            };

            function createCommonjsModule(fn, module) {
                return module = {
                    exports: {}
                }, fn(module, module.exports), module.exports;
            }

            var __moduleExports = createCommonjsModule(function(module) {
                'use strict';

                module.exports = function(str) {
                    return encodeURIComponent(str).replace(/[!'()*]/g, function(c) {
                        return '%' + c.charCodeAt(0).toString(16).toUpperCase();
                    });
                };
            });

            var __moduleExports$1 = createCommonjsModule(function(module) {
                'use strict';
                /* eslint-disable no-unused-vars */

                var hasOwnProperty = Object.prototype.hasOwnProperty;
                var propIsEnumerable = Object.prototype.propertyIsEnumerable;

                function toObject(val) {
                    if (val === null || val === undefined) {
                        throw new TypeError('Object.assign cannot be called with null or undefined');
                    }

                    return Object(val);
                }

                function shouldUseNative() {
                    try {
                        if (!Object.assign) {
                            return false;
                        }

                        // Detect buggy property enumeration order in older V8 versions.

                        // https://bugs.chromium.org/p/v8/issues/detail?id=4118
                        var test1 = new String('abc'); // eslint-disable-line
                        test1[5] = 'de';
                        if (Object.getOwnPropertyNames(test1)[0] === '5') {
                            return false;
                        }

                        // https://bugs.chromium.org/p/v8/issues/detail?id=3056
                        var test2 = {};
                        for (var i = 0; i < 10; i++) {
                            test2['_' + String.fromCharCode(i)] = i;
                        }
                        var order2 = Object.getOwnPropertyNames(test2).map(function(n) {
                            return test2[n];
                        });
                        if (order2.join('') !== '0123456789') {
                            return false;
                        }

                        // https://bugs.chromium.org/p/v8/issues/detail?id=3056
                        var test3 = {};
                        'abcdefghijklmnopqrst'.split('').forEach(function(letter) {
                            test3[letter] = letter;
                        });
                        if (Object.keys(Object.assign({}, test3)).join('') !== 'abcdefghijklmnopqrst') {
                            return false;
                        }

                        return true;
                    } catch (e) {
                        // We don't expect any of the above to throw, but better to be safe.
                        return false;
                    }
                }

                module.exports = shouldUseNative() ? Object.assign : function(target, source) {
                    var from;
                    var to = toObject(target);
                    var symbols;

                    for (var s = 1; s < arguments.length; s++) {
                        from = Object(arguments[s]);

                        for (var key in from) {
                            if (hasOwnProperty.call(from, key)) {
                                to[key] = from[key];
                            }
                        }

                        if (Object.getOwnPropertySymbols) {
                            symbols = Object.getOwnPropertySymbols(from);
                            for (var i = 0; i < symbols.length; i++) {
                                if (propIsEnumerable.call(from, symbols[i])) {
                                    to[symbols[i]] = from[symbols[i]];
                                }
                            }
                        }
                    }

                    return to;
                };
            });

            var index = createCommonjsModule(function(module, exports) {
                'use strict';

                var strictUriEncode = __moduleExports;
                var objectAssign = __moduleExports$1;

                function encode(value, opts) {
                    if (opts.encode) {
                        return opts.strict ? strictUriEncode(value) : encodeURIComponent(value);
                    }

                    return value;
                }

                exports.extract = function(str) {
                    return str.split('?')[1] || '';
                };

                exports.parse = function(str) {
                    // Create an object with no prototype
                    // https://github.com/sindresorhus/query-string/issues/47
                    var ret = Object.create(null);

                    if (typeof str !== 'string') {
                        return ret;
                    }

                    str = str.trim().replace(/^(\?|#|&)/, '');

                    if (!str) {
                        return ret;
                    }

                    str.split('&').forEach(function(param) {
                        var parts = param.replace(/\+/g, ' ').split('=');
                        // Firefox (pre 40) decodes `%3D` to `=`
                        // https://github.com/sindresorhus/query-string/pull/37
                        var key = parts.shift();
                        var val = parts.length > 0 ? parts.join('=') : undefined;

                        key = decodeURIComponent(key);

                        // missing `=` should be `null`:
                        // http://w3.org/TR/2012/WD-url-20120524/#collect-url-parameters
                        val = val === undefined ? null : decodeURIComponent(val);

                        if (ret[key] === undefined) {
                            ret[key] = val;
                        } else if (Array.isArray(ret[key])) {
                            ret[key].push(val);
                        } else {
                            ret[key] = [ret[key], val];
                        }
                    });

                    return ret;
                };

                exports.stringify = function(obj, opts) {
                    var defaults = {
                        encode: true,
                        strict: true
                    };

                    opts = objectAssign(defaults, opts);

                    return obj ? Object.keys(obj).sort().map(function(key) {
                        var val = obj[key];

                        if (val === undefined) {
                            return '';
                        }

                        if (val === null) {
                            return encode(key, opts);
                        }

                        if (Array.isArray(val)) {
                            var result = [];

                            val.slice().forEach(function(val2) {
                                if (val2 === undefined) {
                                    return;
                                }

                                if (val2 === null) {
                                    result.push(encode(key, opts));
                                } else {
                                    result.push(encode(key, opts) + '=' + encode(val2, opts));
                                }
                            });

                            return result.join('&');
                        }

                        return encode(key, opts) + '=' + encode(val, opts);
                    }).filter(function(x) {
                        return x.length > 0;
                    }).join('&') : '';
                };
            });

            var Context = function() {
                function Context(context) {
                    classCallCheck(this, Context);
                    this._urlScheme = null;
                    this.query = null;
                    this.fallback = null;
                    this.onFallback = null;
                    this.browserback = null;
                    this.onBrowserback = null;

                    context && this.extend(context);
                }

                createClass(Context, [{
                    key: 'extend',
                    value: function extend(target) {
                        target.urlScheme && (this._urlScheme = target.urlScheme);
                        target.query && (this.query = target.query);
                        target.fallback && (this.fallback = target.fallback);
                        target.onFallback && (this.onFallback = target.onFallback);
                        target.browserback && (this.browserback = target.browserback);
                        target.onBrowserback && (this.onBrowserback = target.onBrowserback);
                    }
                }, {
                    key: 'handleFallback',
                    value: function handleFallback() {
                        var fallback = this.fallback;

                        if (fallback) {
                            location.href = fallback;
                        }
                        this.onFallback && this.onFallback();
                    }
                }, {
                    key: 'handleBrowserBack',
                    value: function handleBrowserBack() {
                        var browserback = this.browserback;

                        if (browserback === 'back') {
                            history.back();
                        }
                        this.onBrowserback && this.onBrowserback();
                    }
                }, {
                    key: 'urlScheme',
                    get: function get() {
                        var query = this.query;
                        var _urlScheme = this._urlScheme;

                        var fullPath = _urlScheme;
                        if (query) {
                            var queryStr = index.stringify(query);
                            var parsed = new URL(fullPath);
                            parsed.search += (parsed.search ? '&' : '?') + queryStr;
                            fullPath = parsed.href;
                        }

                        return fullPath;
                    }
                }]);
                return Context;
            }();

            var _window = window;
            var document$1 = _window.document;
            var location$1 = _window.location;


            var openURLByIFrame = function openURLByIFrame(url) {
                var iframe = document$1.createElement('iframe');
                iframe.src = url;
                iframe.setAttribute('height', 0);
                iframe.setAttribute('width', 0);
                iframe.style.display = 'none';
                document$1.body.appendChild(iframe);
                return iframe;
            };

            var openURLByHref = function openURLByHref(url, isReplace) {
                if (isReplace) {
                    location$1.replace(url);
                } else {
                    location$1.href = url;
                }
            };

            var parseQuery = function parseQuery(str) {
                var queries = {};
                var queryStr = str.replace(/^(\?|#|&)/, '');
                var elements = queryStr.split('&');
                for (var i = 0; i < elements.length; i++) {
                    var param = elements[i];
                    var parts = param.replace(/\+/g, ' ').split('=');
                    var key = parts.shift();
                    var val = parts.length > 0 ? parts.join('=') : undefined;
                    key = decodeURIComponent(key);
                    val = val === undefined ? null : decodeURIComponent(val);

                    if (queries[key] === undefined) {
                        queries[key] = val;
                    } else if (Array.isArray(queries[key])) {
                        queries[key].push(val);
                    } else {
                        queries[key] = [queries[key], val];
                    }
                }

                return queries;
            };

            var util$1 = {
                openURLByIFrame: openURLByIFrame,
                openURLByHref: openURLByHref,
                parseQuery: parseQuery
            };

            var BrowserBackgroundObserver = function() {
                function BrowserBackgroundObserver(onReturn, onLeave, useRequestAnimationFrame) {
                    var _this = this;

                    classCallCheck(this, BrowserBackgroundObserver);
                    this.isReturnBrowser = false;
                    this.isLeaveBrowser = false;

                    this.onReturn = onReturn;
                    this.onLeave = onLeave;
                    this.useRequestAnimationFrame = useRequestAnimationFrame;

                    this._onLeave = this._onLeave.bind(this);
                    this._onBlur = this._onBlur.bind(this);
                    this._onFocus = this._onFocus.bind(this);
                    this._onVisibilityChange = this._onVisibilityChange.bind(this);
                    this._onWebkitVisibilityChange = this._onWebkitVisibilityChange.bind(this);

                    window.focus();
                    window.addEventListener('blur', this._onBlur);
                    if (document.hidden !== undefined) {
                        document.addEventListener('visibilitychange', this._onVisibilityChange);
                    } else if (document.webkitHidden !== undefined) {
                        document.addEventListener('webkitvisibilitychange', this._onWebkitVisibilityChange);
                    }

                    if (useRequestAnimationFrame) {
                        (function() {
                            var observe = function observe() {
                                _this.rafId = window.requestAnimationFrame(observe);
                                if (_this.rafTimer !== false) {
                                    clearTimeout(_this.rafTimer);
                                }

                                _this.rafTimer = setTimeout(function() {
                                    if (!isReturnBrowser) {
                                        _onReturn();
                                    }

                                    window.cancelAnimationFrame(_this.rafId);
                                }, 1000);
                            };

                            observe();
                        })();
                    }
                }

                createClass(BrowserBackgroundObserver, [{
                    key: '_onReturn',
                    value: function _onReturn() {
                        var rafTimer = this.rafTimer;
                        var rafId = this.rafId;

                        this.isReturnBrowser = true;
                        document.removeEventListener('visibilitychange', this._onVisibilityChange);
                        document.removeEventListener('webkitvisibilitychange', this._onWebkitVisibilityChange);
                        window.removeEventListener('focus', this._onFocus);
                        clearTimeout(rafTimer);
                        window.cancelAnimationFrame && window.cancelAnimationFrame(rafId);

                        this.onReturn && this.onReturn();
                    }
                }, {
                    key: '_onLeave',
                    value: function _onLeave() {
                        this.isLeaveBrowser = true;
                        this.onLeave && this.onLeave();
                    }
                }, {
                    key: '_onBlur',
                    value: function _onBlur() {
                        var isLeaveBrowser = this.isLeaveBrowser;

                        window.removeEventListener('blur', this._onBlur);
                        window.addEventListener('focus', this._onFocus);
                        if (!isLeaveBrowser) {
                            this._onLeave();
                        }
                    }
                }, {
                    key: '_onFocus',
                    value: function _onFocus() {
                        var isReturnBrowser = this.isReturnBrowser;

                        if (!isReturnBrowser) {
                            this._onReturn();
                        }
                    }
                }, {
                    key: '_onVisibilityChange',
                    value: function _onVisibilityChange() {
                        var isLeaveBrowser = this.isLeaveBrowser;
                        var isReturnBrowser = this.isReturnBrowser;

                        if (!isLeaveBrowser && document.hidden) {
                            this._onLeave();
                        } else if (!isReturnBrowser && !document.hidden) {
                            this._onReturn();
                        }
                    }
                }, {
                    key: '_onWebkitVisibilityChange',
                    value: function _onWebkitVisibilityChange() {
                        var isLeaveBrowser = this.isLeaveBrowser;
                        var isReturnBrowser = this.isReturnBrowser;

                        if (!isLeaveBrowser && document.webkitHidden) {
                            this._onLeave();
                        } else if (!isReturnBrowser && !document.webkitHidden) {
                            this._onReturn();
                        }
                    }
                }]);
                return BrowserBackgroundObserver;
            }();

            var BaseLauncher = function() {
                function BaseLauncher(context) {
                    classCallCheck(this, BaseLauncher);
                    this._context = null;
                    this._fallbackTime = 500;

                    this._context = context;

                    this._handleTimeout = this._handleTimeout.bind(this);
                    this._handleLeaveBrowser = this._handleLeaveBrowser.bind(this);
                    this._handleBrowserBack = this._handleBrowserBack.bind(this);
                }

                createClass(BaseLauncher, [{
                    key: 'launch',
                    value: function launch() {
                        util$1.openURLByIFrame(this._context.urlScheme);
                        this._timerId = setTimeout(this._handleTimeout, this._fallbackTime);
                        this._observer = new BrowserBackgroundObserver(this._handleBrowserBack, this._handleLeaveBrowser, true);
                    }
                }, {
                    key: '_handleTimeout',
                    value: function _handleTimeout() {
                        this._context.handleFallback();
                    }
                }, {
                    key: '_handleLeaveBrowser',
                    value: function _handleLeaveBrowser() {
                        var _timerId = this._timerId;

                        clearTimeout(_timerId);
                    }
                }, {
                    key: '_handleBrowserBack',
                    value: function _handleBrowserBack() {
                        this._context.handleBrowserBack();
                    }
                }]);
                return BaseLauncher;
            }();

            var IOS = function(_BaseLauncher) {
                inherits(IOS, _BaseLauncher);

                function IOS() {
                    classCallCheck(this, IOS);
                    return possibleConstructorReturn(this, (IOS.__proto__ || Object.getPrototypeOf(IOS)).apply(this, arguments));
                }

                createClass(IOS, [{
                    key: 'launch',
                    value: function launch() {
                        var _context = this._context;

                        if (_context.osVer > 8) {
                            util$1.openURLByHref(_context.urlScheme);
                        } else {
                            util$1.openURLByIFrame(_context.urlScheme);
                        }

                        this._timerId = setTimeout(this._handleTimeout, this._fallbackTime);
                        this._observer = new BrowserBackgroundObserver(this._handleBrowserBack, this._handleLeaveBrowser, true);
                    }
                }]);
                return IOS;
            }(BaseLauncher);

            var Android = function(_BaseLauncher) {
                inherits(Android, _BaseLauncher);

                function Android() {
                    classCallCheck(this, Android);
                    return possibleConstructorReturn(this, (Android.__proto__ || Object.getPrototypeOf(Android)).apply(this, arguments));
                }

                return Android;
            }(BaseLauncher);

            var PC = function(_BaseLauncher) {
                inherits(PC, _BaseLauncher);

                function PC(context) {
                    classCallCheck(this, PC);

                    var _this = possibleConstructorReturn(this, (PC.__proto__ || Object.getPrototypeOf(PC)).call(this, context));

                    _this._enableEventListener(window);
                    _this._enableEventListener(document);
                    return _this;
                }

                createClass(PC, [{
                    key: 'launch',
                    value: function launch() {
                        util$1.openURLByIFrame(this._context.urlScheme);
                        this._timerId = setTimeout(this._handleTimeout, this._fallbackTime);
                        this._observer = new BrowserBackgroundObserver(this._handleBrowserBack, this._handleLeaveBrowser, true);
                    }
                }, {
                    key: '_enableEventListener',
                    value: function _enableEventListener(target) {
                        if (!target.addEventListener) {
                            target.addEventListener = function(type, callback) {
                                target.attachEvent('on' + type, callback);
                            };
                        }

                        if (!target.removeEventListener) {
                            target.removeEventListener = function(type, callback) {
                                target.detachEvent('on' + type, callback);
                            };
                        }
                    }
                }]);
                return PC;
            }(BaseLauncher);

            var util = {
                IOS: IOS,
                Android: Android,
                PC: PC
            };

            var FallbackCustomScheme = function() {
                function FallbackCustomScheme(options) {
                    classCallCheck(this, FallbackCustomScheme);
                    this._ua = new UserAgent();

                    this._context = new Context(options);
                }

                createClass(FallbackCustomScheme, [{
                    key: 'launch',
                    value: function launch(options) {
                        var _context = this._context;
                        var _ua = this._ua;

                        options && _context.extend(options);
                        var urlScheme = _context.urlScheme;
                        var isIOS = _ua.isIOS;
                        var isAndroid = _ua.isAndroid;
                        var isPC = _ua.isPC;


                        if (!urlScheme) {
                            throw new Error('you must set "urlScheme"');
                        }

                        if (isIOS) {
                            this._launcher = new IOS(_context);
                        } else if (isAndroid) {
                            this._launcher = new Android(_context);
                        } else if (isPC) {
                            this._launcher = new PC(_context);
                        }
                        if (this._launcher) {
                            this._launcher.launch();
                        }
                    }
                }]);
                return FallbackCustomScheme;
            }();

            return FallbackCustomScheme;

        })));

        /***/
    }),
    /* 39 */
    /***/
    (function(module, exports, __webpack_require__) {

        "use strict";


        var _preact = __webpack_require__(3);

        var _ViewportSwitch = __webpack_require__(40);

        var _ViewportSwitch2 = _interopRequireDefault(_ViewportSwitch);

        var _Desktop = __webpack_require__(51);

        var _Desktop2 = _interopRequireDefault(_Desktop);

        var _Mobile = __webpack_require__(52);

        var _Mobile2 = _interopRequireDefault(_Mobile);

        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }

        var abilitiesData = [{
            key: '' + window.i18n.abilities.passive.titleShort,
            keyLong: 'PASSIVE',
            title: '' + window.i18n.abilities.passive.titleCombined,
            subtitle: '' + window.i18n.abilities.passive.subtitle,
            description: ['' + window.i18n.abilities.passive.causticWounds, '' + window.i18n.abilities.passive.livingWeapon],
            youtubeId: '' + window.i18n.abilities.passive.youtubeid,
            thumbnail: '/img/content/abilities/icon-p.jpg'
        }, {
            key: false
        }, {
            key: '' + window.i18n.abilities.q.titleShort,
            title: '' + window.i18n.abilities.q.titleCombined,
            subtitle: '' + window.i18n.abilities.q.subtitle,
            description: ['' + window.i18n.abilities.q.copy, '' + window.i18n.abilities.q.livingWeapon],
            youtubeId: '' + window.i18n.abilities.q.youtubeid,
            thumbnail: '/img/content/abilities/icon-q.jpg'
        }, {
            key: '' + window.i18n.abilities.w.titleShort,
            title: '' + window.i18n.abilities.w.titleCombined,
            subtitle: '' + window.i18n.abilities.w.subtitle,
            description: ['' + window.i18n.abilities.w.copy, '' + window.i18n.abilities.w.livingWeapon],
            youtubeId: '' + window.i18n.abilities.w.youtubeid,
            thumbnail: '/img/content/abilities/icon-w.jpg'
        }, {
            key: '' + window.i18n.abilities.e.titleShort,
            title: '' + window.i18n.abilities.e.titleCombined,
            subtitle: '' + window.i18n.abilities.e.subtitle,
            description: ['' + window.i18n.abilities.e.copy, '' + window.i18n.abilities.e.livingWeapon],
            youtubeId: '' + window.i18n.abilities.e.youtubeid,
            thumbnail: '/img/content/abilities/icon-e.jpg'
        }, {
            key: '' + window.i18n.abilities.r.titleShort,
            title: '' + window.i18n.abilities.r.titleCombined,
            subtitle: '' + window.i18n.abilities.r.subtitle,
            description: ['' + window.i18n.abilities.r.copy],
            youtubeId: '' + window.i18n.abilities.r.youtubeid,
            thumbnail: '/img/content/abilities/icon-r.jpg'
        }];

        (0, _preact.render)((0, _preact.h)(_ViewportSwitch2.default, {
            queryString: '(min-width: 768px)',
            PassComponent: (0, _preact.h)(_Desktop2.default, {
                data: abilitiesData
            }),
            FailComponent: (0, _preact.h)(_Mobile2.default, {
                data: abilitiesData
            })
        }), document.querySelector('#abilities-app'));

        /***/
    }),
    /* 40 */
    /***/
    (function(module, exports, __webpack_require__) {

        "use strict";


        Object.defineProperty(exports, "__esModule", {
            value: true
        });

        var _createClass = function() {
            function defineProperties(target, props) {
                for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || false;
                    descriptor.configurable = true;
                    if ("value" in descriptor) descriptor.writable = true;
                    Object.defineProperty(target, descriptor.key, descriptor);
                }
            }
            return function(Constructor, protoProps, staticProps) {
                if (protoProps) defineProperties(Constructor.prototype, protoProps);
                if (staticProps) defineProperties(Constructor, staticProps);
                return Constructor;
            };
        }();

        var _preact = __webpack_require__(3);

        var _debounce = __webpack_require__(41);

        var _debounce2 = _interopRequireDefault(_debounce);

        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                default: obj
            };
        }

        function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
            }
        }

        function _possibleConstructorReturn(self, call) {
            if (!self) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }
            return call && (typeof call === "object" || typeof call === "function") ? call : self;
        }

        function _inherits(subClass, superClass) {
            if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            }
            subClass.prototype = Object.create(superClass && superClass.prototype, {
                constructor: {
                    value: subClass,
                    enumerable: false,
                    writable: true,
                    configurable: true
                }
            });
            if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
        }

        var ViewportSwitch = function(_Component) {
            _inherits(ViewportSwitch, _Component);

            function ViewportSwitch(props) {
                _classCallCheck(this, ViewportSwitch);

                var _this = _possibleConstructorReturn(this, (ViewportSwitch.__proto__ || Object.getPrototypeOf(ViewportSwitch)).call(this, props));

                _this.state = {
                    match: -1
                };
                return _this;
            }

            _createClass(ViewportSwitch, [{
                key: 'componentDidMount',
                value: function componentDidMount() {
                    this.testMatch();

                    this.handleResize = (0, _debounce2.default)(this.testMatch.bind(this), 100);

                    window.addEventListener('resize', this.handleResize);
                }
            }, {
                key: 'componentWillUnmount',
                value: function componentWillUnmount() {
                    window.removeEventListener('resize', this.handleResize);
                }
            }, {
                key: 'testMatch',
                value: function testMatch() {
                    var match = window.matchMedia(this.props.queryString).matches;

                    if (match !== this.state.match) {
                        this.setState({
                            match: match
                        });
                    }
                }
            }, {
                key: 'render',
                value: function render() {
                    var _props = this.props,
                        _props$PassComponent = _props.PassComponent,
                        PassComponent = _props$PassComponent === undefined ? (0, _preact.h)('span', null) : _props$PassComponent,
                        _props$FailComponent = _props.FailComponent,
                        FailComponent = _props$FailComponent === undefined ? (0, _preact.h)('span', null) : _props$FailComponent;


                    if (this.state.match === -1) {
                        return null;
                    }

                    // React.Children.only let's us return the correct component without
                    // wrapping it in another tag. Helps with markup specific styles
                    // console.log(this.state.match);
                    return this.state.match ? PassComponent : FailComponent;
                }
            }]);

            return ViewportSwitch;
        }(_preact.Component);

        exports.default = ViewportSwitch;

        /***/
    }),
    /* 41 */
    /***/
    (function(module, exports, __webpack_require__) {

        var isObject = __webpack_require__(9),
            now = __webpack_require__(42),
            toNumber = __webpack_require__(45);

        /** Error message constants. */
        var FUNC_ERROR_TEXT = 'Expected a function';

        /* Built-in method references for those with the same name as other `lodash` methods. */
        var nativeMax = Math.max,
            nativeMin = Math.min;

        /**
         * Creates a debounced function that delays invoking `func` until after `wait`
         * milliseconds have elapsed since the last time the debounced function was
         * invoked. The debounced function comes with a `cancel` method to cancel
         * delayed `func` invocations and a `flush` method to immediately invoke them.
         * Provide `options` to indicate whether `func` should be invoked on the
         * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
         * with the last arguments provided to the debounced function. Subsequent
         * calls to the debounced function return the result of the last `func`
         * invocation.
         *
         * **Note:** If `leading` and `trailing` options are `true`, `func` is
         * invoked on the trailing edge of the timeout only if the debounced function
         * is invoked more than once during the `wait` timeout.
         *
         * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
         * until to the next tick, similar to `setTimeout` with a timeout of `0`.
         *
         * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
         * for details over the differences between `_.debounce` and `_.throttle`.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Function
         * @param {Function} func The function to debounce.
         * @param {number} [wait=0] The number of milliseconds to delay.
         * @param {Object} [options={}] The options object.
         * @param {boolean} [options.leading=false]
         *  Specify invoking on the leading edge of the timeout.
         * @param {number} [options.maxWait]
         *  The maximum time `func` is allowed to be delayed before it's invoked.
         * @param {boolean} [options.trailing=true]
         *  Specify invoking on the trailing edge of the timeout.
         * @returns {Function} Returns the new debounced function.
         * @example
         *
         * // Avoid costly calculations while the window size is in flux.
         * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
         *
         * // Invoke `sendMail` when clicked, debouncing subsequent calls.
         * jQuery(element).on('click', _.debounce(sendMail, 300, {
         *   'leading': true,
         *   'trailing': false
         * }));
         *
         * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
         * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
         * var source = new EventSource('/stream');
         * jQuery(source).on('message', debounced);
         *
         * // Cancel the trailing debounced invocation.
         * jQuery(window).on('popstate', debounced.cancel);
         */
        function debounce(func, wait, options) {
            var lastArgs,
                lastThis,
                maxWait,
                result,
                timerId,
                lastCallTime,
                lastInvokeTime = 0,
                leading = false,
                maxing = false,
                trailing = true;

            if (typeof func != 'function') {
                throw new TypeError(FUNC_ERROR_TEXT);
            }
            wait = toNumber(wait) || 0;
            if (isObject(options)) {
                leading = !!options.leading;
                maxing = 'maxWait' in options;
                maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
                trailing = 'trailing' in options ? !!options.trailing : trailing;
            }

            function invokeFunc(time) {
                var args = lastArgs,
                    thisArg = lastThis;

                lastArgs = lastThis = undefined;
                lastInvokeTime = time;
                result = func.apply(thisArg, args);
                return result;
            }

            function leadingEdge(time) {
                // Reset any `maxWait` timer.
                lastInvokeTime = time;
                // Start the timer for the trailing edge.
                timerId = setTimeout(timerExpired, wait);
                // Invoke the leading edge.
                return leading ? invokeFunc(time) : result;
            }

            function remainingWait(time) {
                var timeSinceLastCall = time - lastCallTime,
                    timeSinceLastInvoke = time - lastInvokeTime,
                    result = wait - timeSinceLastCall;

                return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;
            }

            function shouldInvoke(time) {
                var timeSinceLastCall = time - lastCallTime,
                    timeSinceLastInvoke = time - lastInvokeTime;

                // Either this is the first call, activity has stopped and we're at the
                // trailing edge, the system time has gone backwards and we're treating
                // it as the trailing edge, or we've hit the `maxWait` limit.
                return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
                    (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
            }

            function timerExpired() {
                var time = now();
                if (shouldInvoke(time)) {
                    return trailingEdge(time);
                }
                // Restart the timer.
                timerId = setTimeout(timerExpired, remainingWait(time));
            }

            function trailingEdge(time) {
                timerId = undefined;

                // Only invoke if we have `lastArgs` which means `func` has been
                // debounced at least once.
                if (trailing && lastArgs) {
                    return invokeFunc(time);
                }
                lastArgs = lastThis = undefined;
                return result;
            }

            function cancel() {
                if (timerId !== undefined) {
                    clearTimeout(timerId);
                }
                lastInvokeTime = 0;
                lastArgs = lastCallTime = lastThis = timerId = undefined;
            }

            function flush() {
                return timerId === undefined ? result : trailingEdge(now());
            }

            function debounced() {
                var time = now(),
                    isInvoking = shouldInvoke(time);

                lastArgs = arguments;
                lastThis = this;
                lastCallTime = time;

                if (isInvoking) {
                    if (timerId === undefined) {
                        return leadingEdge(lastCallTime);
                    }
                    if (maxing) {
                        // Handle invocations in a tight loop.
                        timerId = setTimeout(timerExpired, wait);
                        return invokeFunc(lastCallTime);
                    }
                }
                if (timerId === undefined) {
                    timerId = setTimeout(timerExpired, wait);
                }
                return result;
            }
            debounced.cancel = cancel;
            debounced.flush = flush;
            return debounced;
        }

        module.exports = debounce;


        /***/
    }),
    /* 42 */
    /***/
    (function(module, exports, __webpack_require__) {

        var root = __webpack_require__(10);

        /**
         * Gets the timestamp of the number of milliseconds that have elapsed since
         * the Unix epoch (1 January 1970 00:00:00 UTC).
         *
         * @static
         * @memberOf _
         * @since 2.4.0
         * @category Date
         * @returns {number} Returns the timestamp.
         * @example
         *
         * _.defer(function(stamp) {
         *   console.log(_.now() - stamp);
         * }, _.now());
         * // => Logs the number of milliseconds it took for the deferred invocation.
         */
        var now = function() {
            return root.Date.now();
        };

        module.exports = now;


        /***/
    }),
    /* 43 */
    /***/
    (function(module, exports, __webpack_require__) {

        /* WEBPACK VAR INJECTION */
        (function(global) { /** Detect free variable `global` from Node.js. */
            var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

            module.exports = freeGlobal;

            /* WEBPACK VAR INJECTION */
        }.call(exports, __webpack_require__(44)))

        /***/
    }),
    /* 44 */
    /***/
    (function(module, exports) {

        var g;

        // This works in non-strict mode
        g = (function() {
            return this;
        })();

        try {
            // This works if eval is allowed (see CSP)
            g = g || Function("return this")() || (1, eval)("this");
        } catch (e) {
            // This works if the window reference is available
            if (typeof window === "object")
                g = window;
        }

        // g can still be undefined, but nothing to do about it...
        // We return undefined, instead of nothing here, so it's
        // easier to handle this case. if(!global) { ...}

        module.exports = g;


        /***/
    }),
    /* 45 */
    /***/
    (function(module, exports, __webpack_require__) {

        var isObject = __webpack_require__(9),
            isSymbol = __webpack_require__(46);

        /** Used as references for various `Number` constants. */
        var NAN = 0 / 0;

        /** Used to match leading and trailing whitespace. */
        var reTrim = /^\s+|\s+$/g;

        /** Used to detect bad signed hexadecimal string values. */
        var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

        /** Used to detect binary string values. */
        var reIsBinary = /^0b[01]+$/i;

        /** Used to detect octal string values. */
        var reIsOctal = /^0o[0-7]+$/i;

        /** Built-in method references without a dependency on `root`. */
        var freeParseInt = parseInt;

        /**
         * Converts `value` to a number.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Lang
         * @param {*} value The value to process.
         * @returns {number} Returns the number.
         * @example
         *
         * _.toNumber(3.2);
         * // => 3.2
         *
         * _.toNumber(Number.MIN_VALUE);
         * // => 5e-324
         *
         * _.toNumber(Infinity);
         * // => Infinity
         *
         * _.toNumber('3.2');
         * // => 3.2
         */
        function toNumber(value) {
            if (typeof value == 'number') {
                return value;
            }
            if (isSymbol(value)) {
                return NAN;
            }
            if (isObject(value)) {
                var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
                value = isObject(other) ? (other + '') : other;
            }
            if (typeof value != 'string') {
                return value === 0 ? value : +value;
            }
            value = value.replace(reTrim, '');
            var isBinary = reIsBinary.test(value);
            return (isBinary || reIsOctal.test(value)) ?
                freeParseInt(value.slice(2), isBinary ? 2 : 8) :
                (reIsBadHex.test(value) ? NAN : +value);
        }

        module.exports = toNumber;


        /***/
    }),
    /* 46 */
    /***/
    (function(module, exports, __webpack_require__) {

        var baseGetTag = __webpack_require__(47),
            isObjectLike = __webpack_require__(50);

        /** `Object#toString` result references. */
        var symbolTag = '[object Symbol]';

        /**
         * Checks if `value` is classified as a `Symbol` primitive or object.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
         * @example
         *
         * _.isSymbol(Symbol.iterator);
         * // => true
         *
         * _.isSymbol('abc');
         * // => false
         */
        function isSymbol(value) {
            return typeof value == 'symbol' ||
                (isObjectLike(value) && baseGetTag(value) == symbolTag);
        }

        module.exports = isSymbol;


        /***/
    }),
    /* 47 */
    /***/
    (function(module, exports, __webpack_require__) {

        var Symbol = __webpack_require__(11),
            getRawTag = __webpack_require__(48),
            objectToString = __webpack_require__(49);

        /** `Object#toString` result references. */
        var nullTag = '[object Null]',
            undefinedTag = '[object Undefined]';

        /** Built-in value references. */
        var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

        /**
         * The base implementation of `getTag` without fallbacks for buggy environments.
         *
         * @private
         * @param {*} value The value to query.
         * @returns {string} Returns the `toStringTag`.
         */
        function baseGetTag(value) {
            if (value == null) {
                return value === undefined ? undefinedTag : nullTag;
            }
            return (symToStringTag && symToStringTag in Object(value)) ?
                getRawTag(value) :
                objectToString(value);
        }

        module.exports = baseGetTag;


        /***/
    }),
    /* 48 */
    /***/
    (function(module, exports, __webpack_require__) {

        var Symbol = __webpack_require__(11);

        /** Used for built-in method references. */
        var objectProto = Object.prototype;

        /** Used to check objects for own properties. */
        var hasOwnProperty = objectProto.hasOwnProperty;

        /**
         * Used to resolve the
         * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
         * of values.
         */
        var nativeObjectToString = objectProto.toString;

        /** Built-in value references. */
        var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

        /**
         * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
         *
         * @private
         * @param {*} value The value to query.
         * @returns {string} Returns the raw `toStringTag`.
         */
        function getRawTag(value) {
            var isOwn = hasOwnProperty.call(value, symToStringTag),
                tag = value[symToStringTag];

            try {
                value[symToStringTag] = undefined;
                var unmasked = true;
            } catch (e) {}

            var result = nativeObjectToString.call(value);
            if (unmasked) {
                if (isOwn) {
                    value[symToStringTag] = tag;
                } else {
                    delete value[symToStringTag];
                }
            }
            return result;
        }

        module.exports = getRawTag;


        /***/
    }),
    /* 49 */
    /***/
    (function(module, exports) {

        /** Used for built-in method references. */
        var objectProto = Object.prototype;

        /**
         * Used to resolve the
         * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
         * of values.
         */
        var nativeObjectToString = objectProto.toString;

        /**
         * Converts `value` to a string using `Object.prototype.toString`.
         *
         * @private
         * @param {*} value The value to convert.
         * @returns {string} Returns the converted string.
         */
        function objectToString(value) {
            return nativeObjectToString.call(value);
        }

        module.exports = objectToString;


        /***/
    }),
    /* 50 */
    /***/
    (function(module, exports) {

        /**
         * Checks if `value` is object-like. A value is object-like if it's not `null`
         * and has a `typeof` result of "object".
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
         * @example
         *
         * _.isObjectLike({});
         * // => true
         *
         * _.isObjectLike([1, 2, 3]);
         * // => true
         *
         * _.isObjectLike(_.noop);
         * // => false
         *
         * _.isObjectLike(null);
         * // => false
         */
        function isObjectLike(value) {
            return value != null && typeof value == 'object';
        }

        module.exports = isObjectLike;


        /***/
    }),
    /* 51 */
    /***/
    (function(module, exports, __webpack_require__) {

        "use strict";


        Object.defineProperty(exports, "__esModule", {
            value: true
        });

        var _createClass = function() {
            function defineProperties(target, props) {
                for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || false;
                    descriptor.configurable = true;
                    if ("value" in descriptor) descriptor.writable = true;
                    Object.defineProperty(target, descriptor.key, descriptor);
                }
            }
            return function(Constructor, protoProps, staticProps) {
                if (protoProps) defineProperties(Constructor.prototype, protoProps);
                if (staticProps) defineProperties(Constructor, staticProps);
                return Constructor;
            };
        }();

        var _preact = __webpack_require__(3);

        function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
                throw new TypeError("Cannot call a class as a function");
            }
        }

        function _possibleConstructorReturn(self, call) {
            if (!self) {
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }
            return call && (typeof call === "object" || typeof call === "function") ? call : self;
        }

        function _inherits(subClass, superClass) {
            if (typeof superClass !== "function" && superClass !== null) {
                throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
            }
            subClass.prototype = Object.create(superClass && superClass.prototype, {
                constructor: {
                    value: subClass,
                    enumerable: false,
                    writable: true,
                    configurable: true
                }
            });
            if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
        }

        var Desktop = function(_Component) {
            _inherits(Desktop, _Component);

            function Desktop() {
                _classCallCheck(this, Desktop);

                var _this = _possibleConstructorReturn(this, (Desktop.__proto__ || Object.getPrototypeOf(Desktop)).call(this));

                _this.state = {
                    current: 0,
                    autoplay: 0
                };

                _this.setCurrent = function(current) {
                    _this.setState({
                        current: current
                    });
                };
                return _this;
            }

            _createClass(Desktop, [{
                key: "render",
                value: function render() {
                    var _this2 = this;

                    var data = this.props.data;


                    var currentAbility = data[this.state.current];

                    return (0, _preact.h)(
                        "div", {
                            className: "o-media-layout u-spacing-220"
                        },
                        (0, _preact.h)(
                            "div", {
                                className: "o-media-layout__content"
                            },
                            (0, _preact.h)(
                                "div", {
                                    className: "c-frame"
                                },
                                (0, _preact.h)(
                                    "div", {
                                        className: "o-aspect o-aspect--16x9"
                                    },
                                    (0, _preact.h)("iframe", {
                                        width: "560",
                                        height: "315",
                                        src: "https://www.youtube.com/embed/" + currentAbility.youtubeId + "?showinfo=0&rel=0&autoplay=" + this.state.autoplay,
                                        frameBorder: "0",
                                        allow: "autoplay; encrypted-media",
                                        allowFullScreen: true
                                    })
                                )
                            ),
                            (0, _preact.h)(
                                "div", {
                                    className: "c-media-controls"
                                },
                                (0, _preact.h)(
                                    "ul", {
                                        className: "o-list-unstyled c-media-controls__list"
                                    },
                                    data.map(function(ability, abilityIndex) {
                                        if (ability.key === false) {
                                            return (0, _preact.h)("li", {
                                                key: "divider",
                                                className: "c-media-controls__item c-media-controls__item--divider"
                                            });
                                        }

                                        var onClick = function onClick() {
                                            _this2.setCurrent(abilityIndex);
                                            _this2.setState({
                                                autoplay: 1
                                            });
                                        };

                                        var className = "c-thumb " + (abilityIndex === _this2.state.current && 'is-active');

                                        return (0, _preact.h)(
                                            "li", {
                                                key: ability.key,
                                                className: "c-media-controls__item"
                                            },
                                            (0, _preact.h)(
                                                "button", {
                                                    className: className,
                                                    onClick: onClick
                                                },
                                                (0, _preact.h)(
                                                    "span", {
                                                        className: "o-aspect"
                                                    },
                                                    (0, _preact.h)("img", {
                                                        src: "" + window.versionedAssetPath + ability.thumbnail,
                                                        alt: ""
                                                    })
                                                )
                                            ),
                                            (0, _preact.h)(
                                                "div", {
                                                    className: "c-media-controls__label"
                                                },
                                                ability.key
                                            )
                                        );
                                    })
                                )
                            )
                        ),
                        (0, _preact.h)(
                            "div", {
                                className: "o-media-layout__aside"
                            },
                            (0, _preact.h)(
                                "div", {
                                    className: "c-thumb c-thumb--big u-spacing-40"
                                },
                                (0, _preact.h)(
                                    "span", {
                                        className: "o-aspect"
                                    },
                                    (0, _preact.h)("img", {
                                        src: "" + window.versionedAssetPath + currentAbility.thumbnail,
                                        alt: ""
                                    })
                                )
                            ),
                            (0, _preact.h)(
                                "h3", {
                                    className: "c-heading-18 u-color-putty u-spacing-40"
                                },
                                currentAbility.title
                            ),
                            currentAbility.description.map(function(line) {
                                return (0, _preact.h)("p", {
                                    dangerouslySetInnerHTML: {
                                        __html: line
                                    }
                                });
                            })
                        )
                    );
                }
            }]);

            return Desktop;
        }(_preact.Component);

        exports.default = Desktop;

        /***/
    }),
    /* 52 */
    /***/
    (function(module, exports, __webpack_require__) {

        "use strict";


        Object.defineProperty(exports, "__esModule", {
            value: true
        });

        var _preact = __webpack_require__(3);

        var Mobile = function Mobile(_ref) {
            var data = _ref.data;
            return (0, _preact.h)(
                "div",
                null,
                (0, _preact.h)(
                    "ul", {
                        className: "o-list-unstyled"
                    },
                    data.map(function(ability, abilityIndex) {
                        if (ability.key === false) {
                            return null;
                        }

                        return (0, _preact.h)(
                            "li", {
                                key: ability.key
                            },
                            (0, _preact.h)(
                                "div", {
                                    className: "c-frame"
                                },
                                (0, _preact.h)(
                                    "div", {
                                        className: "o-aspect o-aspect--16x9"
                                    },
                                    (0, _preact.h)("iframe", {
                                        width: "560",
                                        height: "315",
                                        src: "https://www.youtube.com/embed/" + ability.youtubeId + "?rel=0&showinfo=0",
                                        frameBorder: "0",
                                        allow: "autoplay; encrypted-media",
                                        allowFullScreen: true
                                    })
                                )
                            ),
                            (0, _preact.h)(
                                "div", {
                                    className: "o-media"
                                },
                                (0, _preact.h)(
                                    "div", {
                                        className: "o-media__block"
                                    },
                                    (0, _preact.h)(
                                        "div", {
                                            className: "c-thumb c-thumb--big"
                                        },
                                        (0, _preact.h)(
                                            "span", {
                                                className: "o-aspect"
                                            },
                                            (0, _preact.h)("img", {
                                                src: "" + window.versionedAssetPath + ability.thumbnail,
                                                alt: ""
                                            })
                                        )
                                    )
                                ),
                                (0, _preact.h)(
                                    "div", {
                                        className: "o-media__block"
                                    },
                                    (0, _preact.h)(
                                        "h3", {
                                            className: "c-heading-28 u-color-white u-spacing-none"
                                        },
                                        ability.key
                                    ),
                                    (0, _preact.h)(
                                        "h3", {
                                            className: "c-heading-18 u-color-putty u-spacing-none"
                                        },
                                        ability.subtitle
                                    )
                                )
                            ),
                            ability.description.map(function(line) {
                                return (0, _preact.h)("p", {
                                    dangerouslySetInnerHTML: {
                                        __html: line
                                    }
                                });
                            })
                        );
                    })
                )
            );
        };

        exports.default = Mobile;

        /***/
    })
    /******/
]);
//# sourceMappingURL=main.js.map